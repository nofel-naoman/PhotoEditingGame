"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-window";
exports.ids = ["vendor-chunks/react-window"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-window/dist/index.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-window/dist/index.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedSizeGrid: () => (/* binding */ FixedSizeGrid),\n/* harmony export */   FixedSizeList: () => (/* binding */ FixedSizeList),\n/* harmony export */   VariableSizeGrid: () => (/* binding */ VariableSizeGrid),\n/* harmony export */   VariableSizeList: () => (/* binding */ VariableSizeList),\n/* harmony export */   areEqual: () => (/* binding */ areEqual),\n/* harmony export */   shouldComponentUpdate: () => (/* binding */ shouldComponentUpdate)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! memoize-one */ \"(ssr)/./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\");\n\n\n\n\n\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\nvar now = hasNativePerformanceNow ? function() {\n    return performance.now();\n} : function() {\n    return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n    cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n    var start = now();\n    function tick() {\n        if (now() - start >= delay) {\n            callback.call(null);\n        } else {\n            timeoutID.id = requestAnimationFrame(tick);\n        }\n    }\n    var timeoutID = {\n        id: requestAnimationFrame(tick)\n    };\n    return timeoutID;\n}\nvar size = -1; // This utility copied from \"dom-helpers\" package.\nfunction getScrollbarSize(recalculate) {\n    if (recalculate === void 0) {\n        recalculate = false;\n    }\n    if (size === -1 || recalculate) {\n        var div = document.createElement(\"div\");\n        var style = div.style;\n        style.width = \"50px\";\n        style.height = \"50px\";\n        style.overflow = \"scroll\";\n        document.body.appendChild(div);\n        size = div.offsetWidth - div.clientWidth;\n        document.body.removeChild(div);\n    }\n    return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nfunction getRTLOffsetType(recalculate) {\n    if (recalculate === void 0) {\n        recalculate = false;\n    }\n    if (cachedRTLResult === null || recalculate) {\n        var outerDiv = document.createElement(\"div\");\n        var outerStyle = outerDiv.style;\n        outerStyle.width = \"50px\";\n        outerStyle.height = \"50px\";\n        outerStyle.overflow = \"scroll\";\n        outerStyle.direction = \"rtl\";\n        var innerDiv = document.createElement(\"div\");\n        var innerStyle = innerDiv.style;\n        innerStyle.width = \"100px\";\n        innerStyle.height = \"100px\";\n        outerDiv.appendChild(innerDiv);\n        document.body.appendChild(outerDiv);\n        if (outerDiv.scrollLeft > 0) {\n            cachedRTLResult = \"positive-descending\";\n        } else {\n            outerDiv.scrollLeft = 1;\n            if (outerDiv.scrollLeft === 0) {\n                cachedRTLResult = \"negative\";\n            } else {\n                cachedRTLResult = \"positive-ascending\";\n            }\n        }\n        document.body.removeChild(outerDiv);\n        return cachedRTLResult;\n    }\n    return cachedRTLResult;\n}\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\nvar defaultItemKey = function defaultItemKey(_ref) {\n    var columnIndex = _ref.columnIndex, data = _ref.data, rowIndex = _ref.rowIndex;\n    return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\nif (true) {\n    if (false) {}\n}\nfunction createGridComponent(_ref2) {\n    var _class;\n    var getColumnOffset = _ref2.getColumnOffset, getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset, getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex, getColumnWidth = _ref2.getColumnWidth, getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight, getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth, getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment, getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment, getRowHeight = _ref2.getRowHeight, getRowOffset = _ref2.getRowOffset, getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset, getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex, initInstanceProps = _ref2.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange, validateProps = _ref2.validateProps;\n    return _class = /*#__PURE__*/ function(_PureComponent) {\n        (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Grid, _PureComponent);\n        // Always use explicit constructor for React components.\n        // It produces less code after transpilation. (#26)\n        // eslint-disable-next-line no-useless-constructor\n        function Grid(props) {\n            var _this;\n            _this = _PureComponent.call(this, props) || this;\n            _this._instanceProps = initInstanceProps(_this.props, (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this));\n            _this._resetIsScrollingTimeoutId = null;\n            _this._outerRef = void 0;\n            _this.state = {\n                instance: (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this),\n                isScrolling: false,\n                horizontalScrollDirection: \"forward\",\n                scrollLeft: typeof _this.props.initialScrollLeft === \"number\" ? _this.props.initialScrollLeft : 0,\n                scrollTop: typeof _this.props.initialScrollTop === \"number\" ? _this.props.initialScrollTop : 0,\n                scrollUpdateWasRequested: false,\n                verticalScrollDirection: \"forward\"\n            };\n            _this._callOnItemsRendered = void 0;\n            _this._callOnItemsRendered = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n                return _this.props.onItemsRendered({\n                    overscanColumnStartIndex: overscanColumnStartIndex,\n                    overscanColumnStopIndex: overscanColumnStopIndex,\n                    overscanRowStartIndex: overscanRowStartIndex,\n                    overscanRowStopIndex: overscanRowStopIndex,\n                    visibleColumnStartIndex: visibleColumnStartIndex,\n                    visibleColumnStopIndex: visibleColumnStopIndex,\n                    visibleRowStartIndex: visibleRowStartIndex,\n                    visibleRowStopIndex: visibleRowStopIndex\n                });\n            });\n            _this._callOnScroll = void 0;\n            _this._callOnScroll = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n                return _this.props.onScroll({\n                    horizontalScrollDirection: horizontalScrollDirection,\n                    scrollLeft: scrollLeft,\n                    scrollTop: scrollTop,\n                    verticalScrollDirection: verticalScrollDirection,\n                    scrollUpdateWasRequested: scrollUpdateWasRequested\n                });\n            });\n            _this._getItemStyle = void 0;\n            _this._getItemStyle = function(rowIndex, columnIndex) {\n                var _this$props = _this.props, columnWidth = _this$props.columnWidth, direction = _this$props.direction, rowHeight = _this$props.rowHeight;\n                var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n                var key = rowIndex + \":\" + columnIndex;\n                var style;\n                if (itemStyleCache.hasOwnProperty(key)) {\n                    style = itemStyleCache[key];\n                } else {\n                    var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n                    var isRtl = direction === \"rtl\";\n                    itemStyleCache[key] = style = {\n                        position: \"absolute\",\n                        left: isRtl ? undefined : _offset,\n                        right: isRtl ? _offset : undefined,\n                        top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n                        height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n                        width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n                    };\n                }\n                return style;\n            };\n            _this._getItemStyleCache = void 0;\n            _this._getItemStyleCache = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(_, __, ___) {\n                return {};\n            });\n            _this._onScroll = function(event) {\n                var _event$currentTarget = event.currentTarget, clientHeight = _event$currentTarget.clientHeight, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollTop = _event$currentTarget.scrollTop, scrollHeight = _event$currentTarget.scrollHeight, scrollWidth = _event$currentTarget.scrollWidth;\n                _this.setState(function(prevState) {\n                    if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n                        // Scroll position may have been updated by cDM/cDU,\n                        // In which case we don't need to trigger another render,\n                        // And we don't want to update state.isScrolling.\n                        return null;\n                    }\n                    var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                    // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                    // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n                    // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n                    var calculatedScrollLeft = scrollLeft;\n                    if (direction === \"rtl\") {\n                        switch(getRTLOffsetType()){\n                            case \"negative\":\n                                calculatedScrollLeft = -scrollLeft;\n                                break;\n                            case \"positive-descending\":\n                                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                                break;\n                        }\n                    } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n                    calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n                    var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n                    return {\n                        isScrolling: true,\n                        horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? \"forward\" : \"backward\",\n                        scrollLeft: calculatedScrollLeft,\n                        scrollTop: calculatedScrollTop,\n                        verticalScrollDirection: prevState.scrollTop < scrollTop ? \"forward\" : \"backward\",\n                        scrollUpdateWasRequested: false\n                    };\n                }, _this._resetIsScrollingDebounced);\n            };\n            _this._outerRefSetter = function(ref) {\n                var outerRef = _this.props.outerRef;\n                _this._outerRef = ref;\n                if (typeof outerRef === \"function\") {\n                    outerRef(ref);\n                } else if (outerRef != null && typeof outerRef === \"object\" && outerRef.hasOwnProperty(\"current\")) {\n                    outerRef.current = ref;\n                }\n            };\n            _this._resetIsScrollingDebounced = function() {\n                if (_this._resetIsScrollingTimeoutId !== null) {\n                    cancelTimeout(_this._resetIsScrollingTimeoutId);\n                }\n                _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n            };\n            _this._resetIsScrolling = function() {\n                _this._resetIsScrollingTimeoutId = null;\n                _this.setState({\n                    isScrolling: false\n                }, function() {\n                    // Clear style cache after state update has been committed.\n                    // This way we don't break pure sCU for items that don't use isScrolling param.\n                    _this._getItemStyleCache(-1);\n                });\n            };\n            return _this;\n        }\n        Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n            validateSharedProps(nextProps, prevState);\n            validateProps(nextProps);\n            return null;\n        };\n        var _proto = Grid.prototype;\n        _proto.scrollTo = function scrollTo(_ref3) {\n            var scrollLeft = _ref3.scrollLeft, scrollTop = _ref3.scrollTop;\n            if (scrollLeft !== undefined) {\n                scrollLeft = Math.max(0, scrollLeft);\n            }\n            if (scrollTop !== undefined) {\n                scrollTop = Math.max(0, scrollTop);\n            }\n            this.setState(function(prevState) {\n                if (scrollLeft === undefined) {\n                    scrollLeft = prevState.scrollLeft;\n                }\n                if (scrollTop === undefined) {\n                    scrollTop = prevState.scrollTop;\n                }\n                if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n                    return null;\n                }\n                return {\n                    horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? \"forward\" : \"backward\",\n                    scrollLeft: scrollLeft,\n                    scrollTop: scrollTop,\n                    scrollUpdateWasRequested: true,\n                    verticalScrollDirection: prevState.scrollTop < scrollTop ? \"forward\" : \"backward\"\n                };\n            }, this._resetIsScrollingDebounced);\n        };\n        _proto.scrollToItem = function scrollToItem(_ref4) {\n            var _ref4$align = _ref4.align, align = _ref4$align === void 0 ? \"auto\" : _ref4$align, columnIndex = _ref4.columnIndex, rowIndex = _ref4.rowIndex;\n            var _this$props2 = this.props, columnCount = _this$props2.columnCount, height = _this$props2.height, rowCount = _this$props2.rowCount, width = _this$props2.width;\n            var _this$state = this.state, scrollLeft = _this$state.scrollLeft, scrollTop = _this$state.scrollTop;\n            var scrollbarSize = getScrollbarSize();\n            if (columnIndex !== undefined) {\n                columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n            }\n            if (rowIndex !== undefined) {\n                rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n            }\n            var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n            var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n            // to ensure it's fully visible.\n            // But we only need to account for its size when it's actually visible.\n            var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n            var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n            this.scrollTo({\n                scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n                scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n            });\n        };\n        _proto.componentDidMount = function componentDidMount() {\n            var _this$props3 = this.props, initialScrollLeft = _this$props3.initialScrollLeft, initialScrollTop = _this$props3.initialScrollTop;\n            if (this._outerRef != null) {\n                var outerRef = this._outerRef;\n                if (typeof initialScrollLeft === \"number\") {\n                    outerRef.scrollLeft = initialScrollLeft;\n                }\n                if (typeof initialScrollTop === \"number\") {\n                    outerRef.scrollTop = initialScrollTop;\n                }\n            }\n            this._callPropsCallbacks();\n        };\n        _proto.componentDidUpdate = function componentDidUpdate() {\n            var direction = this.props.direction;\n            var _this$state2 = this.state, scrollLeft = _this$state2.scrollLeft, scrollTop = _this$state2.scrollTop, scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n            if (scrollUpdateWasRequested && this._outerRef != null) {\n                // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                // So we need to determine which browser behavior we're dealing with, and mimic it.\n                var outerRef = this._outerRef;\n                if (direction === \"rtl\") {\n                    switch(getRTLOffsetType()){\n                        case \"negative\":\n                            outerRef.scrollLeft = -scrollLeft;\n                            break;\n                        case \"positive-ascending\":\n                            outerRef.scrollLeft = scrollLeft;\n                            break;\n                        default:\n                            var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;\n                            outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                            break;\n                    }\n                } else {\n                    outerRef.scrollLeft = Math.max(0, scrollLeft);\n                }\n                outerRef.scrollTop = Math.max(0, scrollTop);\n            }\n            this._callPropsCallbacks();\n        };\n        _proto.componentWillUnmount = function componentWillUnmount() {\n            if (this._resetIsScrollingTimeoutId !== null) {\n                cancelTimeout(this._resetIsScrollingTimeoutId);\n            }\n        };\n        _proto.render = function render() {\n            var _this$props4 = this.props, children = _this$props4.children, className = _this$props4.className, columnCount = _this$props4.columnCount, direction = _this$props4.direction, height = _this$props4.height, innerRef = _this$props4.innerRef, innerElementType = _this$props4.innerElementType, innerTagName = _this$props4.innerTagName, itemData = _this$props4.itemData, _this$props4$itemKey = _this$props4.itemKey, itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey, outerElementType = _this$props4.outerElementType, outerTagName = _this$props4.outerTagName, rowCount = _this$props4.rowCount, style = _this$props4.style, useIsScrolling = _this$props4.useIsScrolling, width = _this$props4.width;\n            var isScrolling = this.state.isScrolling;\n            var _this$_getHorizontalR = this._getHorizontalRangeToRender(), columnStartIndex = _this$_getHorizontalR[0], columnStopIndex = _this$_getHorizontalR[1];\n            var _this$_getVerticalRan = this._getVerticalRangeToRender(), rowStartIndex = _this$_getVerticalRan[0], rowStopIndex = _this$_getVerticalRan[1];\n            var items = [];\n            if (columnCount > 0 && rowCount) {\n                for(var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++){\n                    for(var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++){\n                        items.push(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(children, {\n                            columnIndex: _columnIndex,\n                            data: itemData,\n                            isScrolling: useIsScrolling ? isScrolling : undefined,\n                            key: itemKey({\n                                columnIndex: _columnIndex,\n                                data: itemData,\n                                rowIndex: _rowIndex\n                            }),\n                            rowIndex: _rowIndex,\n                            style: this._getItemStyle(_rowIndex, _columnIndex)\n                        }));\n                    }\n                }\n            } // Read this value AFTER items have been created,\n            // So their actual sizes (if variable) are taken into consideration.\n            var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n            var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(outerElementType || outerTagName || \"div\", {\n                className: className,\n                onScroll: this._onScroll,\n                ref: this._outerRefSetter,\n                style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n                    position: \"relative\",\n                    height: height,\n                    width: width,\n                    overflow: \"auto\",\n                    WebkitOverflowScrolling: \"touch\",\n                    willChange: \"transform\",\n                    direction: direction\n                }, style)\n            }, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(innerElementType || innerTagName || \"div\", {\n                children: items,\n                ref: innerRef,\n                style: {\n                    height: estimatedTotalHeight,\n                    pointerEvents: isScrolling ? \"none\" : undefined,\n                    width: estimatedTotalWidth\n                }\n            }));\n        };\n        _proto._callPropsCallbacks = function _callPropsCallbacks() {\n            var _this$props5 = this.props, columnCount = _this$props5.columnCount, onItemsRendered = _this$props5.onItemsRendered, onScroll = _this$props5.onScroll, rowCount = _this$props5.rowCount;\n            if (typeof onItemsRendered === \"function\") {\n                if (columnCount > 0 && rowCount > 0) {\n                    var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(), _overscanColumnStartIndex = _this$_getHorizontalR2[0], _overscanColumnStopIndex = _this$_getHorizontalR2[1], _visibleColumnStartIndex = _this$_getHorizontalR2[2], _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n                    var _this$_getVerticalRan2 = this._getVerticalRangeToRender(), _overscanRowStartIndex = _this$_getVerticalRan2[0], _overscanRowStopIndex = _this$_getVerticalRan2[1], _visibleRowStartIndex = _this$_getVerticalRan2[2], _visibleRowStopIndex = _this$_getVerticalRan2[3];\n                    this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n                }\n            }\n            if (typeof onScroll === \"function\") {\n                var _this$state3 = this.state, _horizontalScrollDirection = _this$state3.horizontalScrollDirection, _scrollLeft = _this$state3.scrollLeft, _scrollTop = _this$state3.scrollTop, _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested, _verticalScrollDirection = _this$state3.verticalScrollDirection;\n                this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n            }\n        } // Lazily create and cache item styles while scrolling,\n        ;\n        _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n            var _this$props6 = this.props, columnCount = _this$props6.columnCount, overscanColumnCount = _this$props6.overscanColumnCount, overscanColumnsCount = _this$props6.overscanColumnsCount, overscanCount = _this$props6.overscanCount, rowCount = _this$props6.rowCount;\n            var _this$state4 = this.state, horizontalScrollDirection = _this$state4.horizontalScrollDirection, isScrolling = _this$state4.isScrolling, scrollLeft = _this$state4.scrollLeft;\n            var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n            if (columnCount === 0 || rowCount === 0) {\n                return [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n            var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n            // If there isn't at least one extra item, tab loops back around.\n            var overscanBackward = !isScrolling || horizontalScrollDirection === \"backward\" ? Math.max(1, overscanCountResolved) : 1;\n            var overscanForward = !isScrolling || horizontalScrollDirection === \"forward\" ? Math.max(1, overscanCountResolved) : 1;\n            return [\n                Math.max(0, startIndex - overscanBackward),\n                Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\n                startIndex,\n                stopIndex\n            ];\n        };\n        _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n            var _this$props7 = this.props, columnCount = _this$props7.columnCount, overscanCount = _this$props7.overscanCount, overscanRowCount = _this$props7.overscanRowCount, overscanRowsCount = _this$props7.overscanRowsCount, rowCount = _this$props7.rowCount;\n            var _this$state5 = this.state, isScrolling = _this$state5.isScrolling, verticalScrollDirection = _this$state5.verticalScrollDirection, scrollTop = _this$state5.scrollTop;\n            var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n            if (columnCount === 0 || rowCount === 0) {\n                return [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n            var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n            // If there isn't at least one extra item, tab loops back around.\n            var overscanBackward = !isScrolling || verticalScrollDirection === \"backward\" ? Math.max(1, overscanCountResolved) : 1;\n            var overscanForward = !isScrolling || verticalScrollDirection === \"forward\" ? Math.max(1, overscanCountResolved) : 1;\n            return [\n                Math.max(0, startIndex - overscanBackward),\n                Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\n                startIndex,\n                stopIndex\n            ];\n        };\n        return Grid;\n    }(react__WEBPACK_IMPORTED_MODULE_3__.PureComponent), _class.defaultProps = {\n        direction: \"ltr\",\n        itemData: undefined,\n        useIsScrolling: false\n    }, _class;\n}\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n    var children = _ref5.children, direction = _ref5.direction, height = _ref5.height, innerTagName = _ref5.innerTagName, outerTagName = _ref5.outerTagName, overscanColumnsCount = _ref5.overscanColumnsCount, overscanCount = _ref5.overscanCount, overscanRowsCount = _ref5.overscanRowsCount, width = _ref5.width;\n    var instance = _ref6.instance;\n    if (true) {\n        if (typeof overscanCount === \"number\") {\n            if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n                devWarningsOverscanCount.add(instance);\n                console.warn(\"The overscanCount prop has been deprecated. \" + \"Please use the overscanColumnCount and overscanRowCount props instead.\");\n            }\n        }\n        if (typeof overscanColumnsCount === \"number\" || typeof overscanRowsCount === \"number\") {\n            if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n                devWarningsOverscanRowsColumnsCount.add(instance);\n                console.warn(\"The overscanColumnsCount and overscanRowsCount props have been deprecated. \" + \"Please use the overscanColumnCount and overscanRowCount props instead.\");\n            }\n        }\n        if (innerTagName != null || outerTagName != null) {\n            if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n                devWarningsTagName.add(instance);\n                console.warn(\"The innerTagName and outerTagName props have been deprecated. \" + \"Please use the innerElementType and outerElementType props instead.\");\n            }\n        }\n        if (children == null) {\n            throw Error('An invalid \"children\" prop has been specified. ' + \"Value should be a React component. \" + ('\"' + (children === null ? \"null\" : typeof children) + '\" was specified.'));\n        }\n        switch(direction){\n            case \"ltr\":\n            case \"rtl\":\n                break;\n            default:\n                throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + ('\"' + direction + '\" was specified.'));\n        }\n        if (typeof width !== \"number\") {\n            throw Error('An invalid \"width\" prop has been specified. ' + \"Grids must specify a number for width. \" + ('\"' + (width === null ? \"null\" : typeof width) + '\" was specified.'));\n        }\n        if (typeof height !== \"number\") {\n            throw Error('An invalid \"height\" prop has been specified. ' + \"Grids must specify a number for height. \" + ('\"' + (height === null ? \"null\" : typeof height) + '\" was specified.'));\n        }\n    }\n};\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n    var rowCount = _ref.rowCount;\n    var rowMetadataMap = _ref2.rowMetadataMap, estimatedRowHeight = _ref2.estimatedRowHeight, lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n    var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n    // https://github.com/bvaughn/react-window/pull/138\n    if (lastMeasuredRowIndex >= rowCount) {\n        lastMeasuredRowIndex = rowCount - 1;\n    }\n    if (lastMeasuredRowIndex >= 0) {\n        var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n        totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n    }\n    var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n    var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n    return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n    var columnCount = _ref3.columnCount;\n    var columnMetadataMap = _ref4.columnMetadataMap, estimatedColumnWidth = _ref4.estimatedColumnWidth, lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n    var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n    // https://github.com/bvaughn/react-window/pull/138\n    if (lastMeasuredColumnIndex >= columnCount) {\n        lastMeasuredColumnIndex = columnCount - 1;\n    }\n    if (lastMeasuredColumnIndex >= 0) {\n        var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n        totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n    }\n    var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n    var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n    return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n    var itemMetadataMap, itemSize, lastMeasuredIndex;\n    if (itemType === \"column\") {\n        itemMetadataMap = instanceProps.columnMetadataMap;\n        itemSize = props.columnWidth;\n        lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n    } else {\n        itemMetadataMap = instanceProps.rowMetadataMap;\n        itemSize = props.rowHeight;\n        lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n    }\n    if (index > lastMeasuredIndex) {\n        var offset = 0;\n        if (lastMeasuredIndex >= 0) {\n            var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n            offset = itemMetadata.offset + itemMetadata.size;\n        }\n        for(var i = lastMeasuredIndex + 1; i <= index; i++){\n            var size = itemSize(i);\n            itemMetadataMap[i] = {\n                offset: offset,\n                size: size\n            };\n            offset += size;\n        }\n        if (itemType === \"column\") {\n            instanceProps.lastMeasuredColumnIndex = index;\n        } else {\n            instanceProps.lastMeasuredRowIndex = index;\n        }\n    }\n    return itemMetadataMap[index];\n};\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n    var itemMetadataMap, lastMeasuredIndex;\n    if (itemType === \"column\") {\n        itemMetadataMap = instanceProps.columnMetadataMap;\n        lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n    } else {\n        itemMetadataMap = instanceProps.rowMetadataMap;\n        lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n    }\n    var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n    if (lastMeasuredItemOffset >= offset) {\n        // If we've already measured items within this range just use a binary search as it's faster.\n        return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n    } else {\n        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n        // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n        // The overall complexity for this approach is O(log n).\n        return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n    }\n};\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n    while(low <= high){\n        var middle = low + Math.floor((high - low) / 2);\n        var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n        if (currentOffset === offset) {\n            return middle;\n        } else if (currentOffset < offset) {\n            low = middle + 1;\n        } else if (currentOffset > offset) {\n            high = middle - 1;\n        }\n    }\n    if (low > 0) {\n        return low - 1;\n    } else {\n        return 0;\n    }\n};\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n    var itemCount = itemType === \"column\" ? props.columnCount : props.rowCount;\n    var interval = 1;\n    while(index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset){\n        index += interval;\n        interval *= 2;\n    }\n    return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    var size = itemType === \"column\" ? props.width : props.height;\n    var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n    var estimatedTotalSize = itemType === \"column\" ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n    if (align === \"smart\") {\n        if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n            align = \"auto\";\n        } else {\n            align = \"center\";\n        }\n    }\n    switch(align){\n        case \"start\":\n            return maxOffset;\n        case \"end\":\n            return minOffset;\n        case \"center\":\n            return Math.round(minOffset + (maxOffset - minOffset) / 2);\n        case \"auto\":\n        default:\n            if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n                return scrollOffset;\n            } else if (minOffset > maxOffset) {\n                // Because we only take into account the scrollbar size when calculating minOffset\n                // this value can be larger than maxOffset when at the end of the list\n                return minOffset;\n            } else if (scrollOffset < minOffset) {\n                return minOffset;\n            } else {\n                return maxOffset;\n            }\n    }\n};\nvar VariableSizeGrid = /*#__PURE__*/ createGridComponent({\n    getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n        return getItemMetadata(\"column\", props, index, instanceProps).offset;\n    },\n    getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n        return findNearestItem(\"column\", props, instanceProps, scrollLeft);\n    },\n    getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n        var columnCount = props.columnCount, width = props.width;\n        var itemMetadata = getItemMetadata(\"column\", props, startIndex, instanceProps);\n        var maxOffset = scrollLeft + width;\n        var offset = itemMetadata.offset + itemMetadata.size;\n        var stopIndex = startIndex;\n        while(stopIndex < columnCount - 1 && offset < maxOffset){\n            stopIndex++;\n            offset += getItemMetadata(\"column\", props, stopIndex, instanceProps).size;\n        }\n        return stopIndex;\n    },\n    getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n        return instanceProps.columnMetadataMap[index].size;\n    },\n    getEstimatedTotalHeight: getEstimatedTotalHeight,\n    getEstimatedTotalWidth: getEstimatedTotalWidth,\n    getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n        return getOffsetForIndexAndAlignment(\"column\", props, index, align, scrollOffset, instanceProps, scrollbarSize);\n    },\n    getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n        return getOffsetForIndexAndAlignment(\"row\", props, index, align, scrollOffset, instanceProps, scrollbarSize);\n    },\n    getRowOffset: function getRowOffset(props, index, instanceProps) {\n        return getItemMetadata(\"row\", props, index, instanceProps).offset;\n    },\n    getRowHeight: function getRowHeight(props, index, instanceProps) {\n        return instanceProps.rowMetadataMap[index].size;\n    },\n    getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n        return findNearestItem(\"row\", props, instanceProps, scrollTop);\n    },\n    getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n        var rowCount = props.rowCount, height = props.height;\n        var itemMetadata = getItemMetadata(\"row\", props, startIndex, instanceProps);\n        var maxOffset = scrollTop + height;\n        var offset = itemMetadata.offset + itemMetadata.size;\n        var stopIndex = startIndex;\n        while(stopIndex < rowCount - 1 && offset < maxOffset){\n            stopIndex++;\n            offset += getItemMetadata(\"row\", props, stopIndex, instanceProps).size;\n        }\n        return stopIndex;\n    },\n    initInstanceProps: function initInstanceProps(props, instance) {\n        var _ref5 = props, estimatedColumnWidth = _ref5.estimatedColumnWidth, estimatedRowHeight = _ref5.estimatedRowHeight;\n        var instanceProps = {\n            columnMetadataMap: {},\n            estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n            estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n            lastMeasuredColumnIndex: -1,\n            lastMeasuredRowIndex: -1,\n            rowMetadataMap: {}\n        };\n        instance.resetAfterColumnIndex = function(columnIndex, shouldForceUpdate) {\n            if (shouldForceUpdate === void 0) {\n                shouldForceUpdate = true;\n            }\n            instance.resetAfterIndices({\n                columnIndex: columnIndex,\n                shouldForceUpdate: shouldForceUpdate\n            });\n        };\n        instance.resetAfterRowIndex = function(rowIndex, shouldForceUpdate) {\n            if (shouldForceUpdate === void 0) {\n                shouldForceUpdate = true;\n            }\n            instance.resetAfterIndices({\n                rowIndex: rowIndex,\n                shouldForceUpdate: shouldForceUpdate\n            });\n        };\n        instance.resetAfterIndices = function(_ref6) {\n            var columnIndex = _ref6.columnIndex, rowIndex = _ref6.rowIndex, _ref6$shouldForceUpda = _ref6.shouldForceUpdate, shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n            if (typeof columnIndex === \"number\") {\n                instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n            }\n            if (typeof rowIndex === \"number\") {\n                instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n            } // We could potentially optimize further by only evicting styles after this index,\n            // But since styles are only cached while scrolling is in progress-\n            // It seems an unnecessary optimization.\n            // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n            instance._getItemStyleCache(-1);\n            if (shouldForceUpdate) {\n                instance.forceUpdate();\n            }\n        };\n        return instanceProps;\n    },\n    shouldResetStyleCacheOnItemSizeChange: false,\n    validateProps: function validateProps(_ref7) {\n        var columnWidth = _ref7.columnWidth, rowHeight = _ref7.rowHeight;\n        if (true) {\n            if (typeof columnWidth !== \"function\") {\n                throw Error('An invalid \"columnWidth\" prop has been specified. ' + \"Value should be a function. \" + ('\"' + (columnWidth === null ? \"null\" : typeof columnWidth) + '\" was specified.'));\n            } else if (typeof rowHeight !== \"function\") {\n                throw Error('An invalid \"rowHeight\" prop has been specified. ' + \"Value should be a function. \" + ('\"' + (rowHeight === null ? \"null\" : typeof rowHeight) + '\" was specified.'));\n            }\n        }\n    }\n});\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n    return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\nif (true) {\n    if (false) {}\n}\nfunction createListComponent(_ref) {\n    var _class;\n    var getItemOffset = _ref.getItemOffset, getEstimatedTotalSize = _ref.getEstimatedTotalSize, getItemSize = _ref.getItemSize, getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment, getStartIndexForOffset = _ref.getStartIndexForOffset, getStopIndexForStartIndex = _ref.getStopIndexForStartIndex, initInstanceProps = _ref.initInstanceProps, shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange, validateProps = _ref.validateProps;\n    return _class = /*#__PURE__*/ function(_PureComponent) {\n        (0,_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(List, _PureComponent);\n        // Always use explicit constructor for React components.\n        // It produces less code after transpilation. (#26)\n        // eslint-disable-next-line no-useless-constructor\n        function List(props) {\n            var _this;\n            _this = _PureComponent.call(this, props) || this;\n            _this._instanceProps = initInstanceProps(_this.props, (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this));\n            _this._outerRef = void 0;\n            _this._resetIsScrollingTimeoutId = null;\n            _this.state = {\n                instance: (0,_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this),\n                isScrolling: false,\n                scrollDirection: \"forward\",\n                scrollOffset: typeof _this.props.initialScrollOffset === \"number\" ? _this.props.initialScrollOffset : 0,\n                scrollUpdateWasRequested: false\n            };\n            _this._callOnItemsRendered = void 0;\n            _this._callOnItemsRendered = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n                return _this.props.onItemsRendered({\n                    overscanStartIndex: overscanStartIndex,\n                    overscanStopIndex: overscanStopIndex,\n                    visibleStartIndex: visibleStartIndex,\n                    visibleStopIndex: visibleStopIndex\n                });\n            });\n            _this._callOnScroll = void 0;\n            _this._callOnScroll = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n                return _this.props.onScroll({\n                    scrollDirection: scrollDirection,\n                    scrollOffset: scrollOffset,\n                    scrollUpdateWasRequested: scrollUpdateWasRequested\n                });\n            });\n            _this._getItemStyle = void 0;\n            _this._getItemStyle = function(index) {\n                var _this$props = _this.props, direction = _this$props.direction, itemSize = _this$props.itemSize, layout = _this$props.layout;\n                var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n                var style;\n                if (itemStyleCache.hasOwnProperty(index)) {\n                    style = itemStyleCache[index];\n                } else {\n                    var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n                    var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n                    var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n                    var isRtl = direction === \"rtl\";\n                    var offsetHorizontal = isHorizontal ? _offset : 0;\n                    itemStyleCache[index] = style = {\n                        position: \"absolute\",\n                        left: isRtl ? undefined : offsetHorizontal,\n                        right: isRtl ? offsetHorizontal : undefined,\n                        top: !isHorizontal ? _offset : 0,\n                        height: !isHorizontal ? size : \"100%\",\n                        width: isHorizontal ? size : \"100%\"\n                    };\n                }\n                return style;\n            };\n            _this._getItemStyleCache = void 0;\n            _this._getItemStyleCache = (0,memoize_one__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(function(_, __, ___) {\n                return {};\n            });\n            _this._onScrollHorizontal = function(event) {\n                var _event$currentTarget = event.currentTarget, clientWidth = _event$currentTarget.clientWidth, scrollLeft = _event$currentTarget.scrollLeft, scrollWidth = _event$currentTarget.scrollWidth;\n                _this.setState(function(prevState) {\n                    if (prevState.scrollOffset === scrollLeft) {\n                        // Scroll position may have been updated by cDM/cDU,\n                        // In which case we don't need to trigger another render,\n                        // And we don't want to update state.isScrolling.\n                        return null;\n                    }\n                    var direction = _this.props.direction;\n                    var scrollOffset = scrollLeft;\n                    if (direction === \"rtl\") {\n                        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n                        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n                        switch(getRTLOffsetType()){\n                            case \"negative\":\n                                scrollOffset = -scrollLeft;\n                                break;\n                            case \"positive-descending\":\n                                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                                break;\n                        }\n                    } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n                    scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n                    return {\n                        isScrolling: true,\n                        scrollDirection: prevState.scrollOffset < scrollOffset ? \"forward\" : \"backward\",\n                        scrollOffset: scrollOffset,\n                        scrollUpdateWasRequested: false\n                    };\n                }, _this._resetIsScrollingDebounced);\n            };\n            _this._onScrollVertical = function(event) {\n                var _event$currentTarget2 = event.currentTarget, clientHeight = _event$currentTarget2.clientHeight, scrollHeight = _event$currentTarget2.scrollHeight, scrollTop = _event$currentTarget2.scrollTop;\n                _this.setState(function(prevState) {\n                    if (prevState.scrollOffset === scrollTop) {\n                        // Scroll position may have been updated by cDM/cDU,\n                        // In which case we don't need to trigger another render,\n                        // And we don't want to update state.isScrolling.\n                        return null;\n                    } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n                    var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n                    return {\n                        isScrolling: true,\n                        scrollDirection: prevState.scrollOffset < scrollOffset ? \"forward\" : \"backward\",\n                        scrollOffset: scrollOffset,\n                        scrollUpdateWasRequested: false\n                    };\n                }, _this._resetIsScrollingDebounced);\n            };\n            _this._outerRefSetter = function(ref) {\n                var outerRef = _this.props.outerRef;\n                _this._outerRef = ref;\n                if (typeof outerRef === \"function\") {\n                    outerRef(ref);\n                } else if (outerRef != null && typeof outerRef === \"object\" && outerRef.hasOwnProperty(\"current\")) {\n                    outerRef.current = ref;\n                }\n            };\n            _this._resetIsScrollingDebounced = function() {\n                if (_this._resetIsScrollingTimeoutId !== null) {\n                    cancelTimeout(_this._resetIsScrollingTimeoutId);\n                }\n                _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n            };\n            _this._resetIsScrolling = function() {\n                _this._resetIsScrollingTimeoutId = null;\n                _this.setState({\n                    isScrolling: false\n                }, function() {\n                    // Clear style cache after state update has been committed.\n                    // This way we don't break pure sCU for items that don't use isScrolling param.\n                    _this._getItemStyleCache(-1, null);\n                });\n            };\n            return _this;\n        }\n        List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n            validateSharedProps$1(nextProps, prevState);\n            validateProps(nextProps);\n            return null;\n        };\n        var _proto = List.prototype;\n        _proto.scrollTo = function scrollTo(scrollOffset) {\n            scrollOffset = Math.max(0, scrollOffset);\n            this.setState(function(prevState) {\n                if (prevState.scrollOffset === scrollOffset) {\n                    return null;\n                }\n                return {\n                    scrollDirection: prevState.scrollOffset < scrollOffset ? \"forward\" : \"backward\",\n                    scrollOffset: scrollOffset,\n                    scrollUpdateWasRequested: true\n                };\n            }, this._resetIsScrollingDebounced);\n        };\n        _proto.scrollToItem = function scrollToItem(index, align) {\n            if (align === void 0) {\n                align = \"auto\";\n            }\n            var _this$props2 = this.props, itemCount = _this$props2.itemCount, layout = _this$props2.layout;\n            var scrollOffset = this.state.scrollOffset;\n            index = Math.max(0, Math.min(index, itemCount - 1)); // The scrollbar size should be considered when scrolling an item into view, to ensure it's fully visible.\n            // But we only need to account for its size when it's actually visible.\n            // This is an edge case for lists; normally they only scroll in the dominant direction.\n            var scrollbarSize = 0;\n            if (this._outerRef) {\n                var outerRef = this._outerRef;\n                if (layout === \"vertical\") {\n                    scrollbarSize = outerRef.scrollWidth > outerRef.clientWidth ? getScrollbarSize() : 0;\n                } else {\n                    scrollbarSize = outerRef.scrollHeight > outerRef.clientHeight ? getScrollbarSize() : 0;\n                }\n            }\n            this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps, scrollbarSize));\n        };\n        _proto.componentDidMount = function componentDidMount() {\n            var _this$props3 = this.props, direction = _this$props3.direction, initialScrollOffset = _this$props3.initialScrollOffset, layout = _this$props3.layout;\n            if (typeof initialScrollOffset === \"number\" && this._outerRef != null) {\n                var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n                if (direction === \"horizontal\" || layout === \"horizontal\") {\n                    outerRef.scrollLeft = initialScrollOffset;\n                } else {\n                    outerRef.scrollTop = initialScrollOffset;\n                }\n            }\n            this._callPropsCallbacks();\n        };\n        _proto.componentDidUpdate = function componentDidUpdate() {\n            var _this$props4 = this.props, direction = _this$props4.direction, layout = _this$props4.layout;\n            var _this$state = this.state, scrollOffset = _this$state.scrollOffset, scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n            if (scrollUpdateWasRequested && this._outerRef != null) {\n                var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n                if (direction === \"horizontal\" || layout === \"horizontal\") {\n                    if (direction === \"rtl\") {\n                        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n                        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n                        // So we need to determine which browser behavior we're dealing with, and mimic it.\n                        switch(getRTLOffsetType()){\n                            case \"negative\":\n                                outerRef.scrollLeft = -scrollOffset;\n                                break;\n                            case \"positive-ascending\":\n                                outerRef.scrollLeft = scrollOffset;\n                                break;\n                            default:\n                                var clientWidth = outerRef.clientWidth, scrollWidth = outerRef.scrollWidth;\n                                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                                break;\n                        }\n                    } else {\n                        outerRef.scrollLeft = scrollOffset;\n                    }\n                } else {\n                    outerRef.scrollTop = scrollOffset;\n                }\n            }\n            this._callPropsCallbacks();\n        };\n        _proto.componentWillUnmount = function componentWillUnmount() {\n            if (this._resetIsScrollingTimeoutId !== null) {\n                cancelTimeout(this._resetIsScrollingTimeoutId);\n            }\n        };\n        _proto.render = function render() {\n            var _this$props5 = this.props, children = _this$props5.children, className = _this$props5.className, direction = _this$props5.direction, height = _this$props5.height, innerRef = _this$props5.innerRef, innerElementType = _this$props5.innerElementType, innerTagName = _this$props5.innerTagName, itemCount = _this$props5.itemCount, itemData = _this$props5.itemData, _this$props5$itemKey = _this$props5.itemKey, itemKey = _this$props5$itemKey === void 0 ? defaultItemKey$1 : _this$props5$itemKey, layout = _this$props5.layout, outerElementType = _this$props5.outerElementType, outerTagName = _this$props5.outerTagName, style = _this$props5.style, useIsScrolling = _this$props5.useIsScrolling, width = _this$props5.width;\n            var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n            var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n            var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n            var _this$_getRangeToRend = this._getRangeToRender(), startIndex = _this$_getRangeToRend[0], stopIndex = _this$_getRangeToRend[1];\n            var items = [];\n            if (itemCount > 0) {\n                for(var _index = startIndex; _index <= stopIndex; _index++){\n                    items.push(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(children, {\n                        data: itemData,\n                        key: itemKey(_index, itemData),\n                        index: _index,\n                        isScrolling: useIsScrolling ? isScrolling : undefined,\n                        style: this._getItemStyle(_index)\n                    }));\n                }\n            } // Read this value AFTER items have been created,\n            // So their actual sizes (if variable) are taken into consideration.\n            var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(outerElementType || outerTagName || \"div\", {\n                className: className,\n                onScroll: onScroll,\n                ref: this._outerRefSetter,\n                style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n                    position: \"relative\",\n                    height: height,\n                    width: width,\n                    overflow: \"auto\",\n                    WebkitOverflowScrolling: \"touch\",\n                    willChange: \"transform\",\n                    direction: direction\n                }, style)\n            }, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_3__.createElement)(innerElementType || innerTagName || \"div\", {\n                children: items,\n                ref: innerRef,\n                style: {\n                    height: isHorizontal ? \"100%\" : estimatedTotalSize,\n                    pointerEvents: isScrolling ? \"none\" : undefined,\n                    width: isHorizontal ? estimatedTotalSize : \"100%\"\n                }\n            }));\n        };\n        _proto._callPropsCallbacks = function _callPropsCallbacks() {\n            if (typeof this.props.onItemsRendered === \"function\") {\n                var itemCount = this.props.itemCount;\n                if (itemCount > 0) {\n                    var _this$_getRangeToRend2 = this._getRangeToRender(), _overscanStartIndex = _this$_getRangeToRend2[0], _overscanStopIndex = _this$_getRangeToRend2[1], _visibleStartIndex = _this$_getRangeToRend2[2], _visibleStopIndex = _this$_getRangeToRend2[3];\n                    this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n                }\n            }\n            if (typeof this.props.onScroll === \"function\") {\n                var _this$state2 = this.state, _scrollDirection = _this$state2.scrollDirection, _scrollOffset = _this$state2.scrollOffset, _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n                this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n            }\n        } // Lazily create and cache item styles while scrolling,\n        ;\n        _proto._getRangeToRender = function _getRangeToRender() {\n            var _this$props6 = this.props, itemCount = _this$props6.itemCount, overscanCount = _this$props6.overscanCount;\n            var _this$state3 = this.state, isScrolling = _this$state3.isScrolling, scrollDirection = _this$state3.scrollDirection, scrollOffset = _this$state3.scrollOffset;\n            if (itemCount === 0) {\n                return [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n            var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n            // If there isn't at least one extra item, tab loops back around.\n            var overscanBackward = !isScrolling || scrollDirection === \"backward\" ? Math.max(1, overscanCount) : 1;\n            var overscanForward = !isScrolling || scrollDirection === \"forward\" ? Math.max(1, overscanCount) : 1;\n            return [\n                Math.max(0, startIndex - overscanBackward),\n                Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\n                startIndex,\n                stopIndex\n            ];\n        };\n        return List;\n    }(react__WEBPACK_IMPORTED_MODULE_3__.PureComponent), _class.defaultProps = {\n        direction: \"ltr\",\n        itemData: undefined,\n        layout: \"vertical\",\n        overscanCount: 2,\n        useIsScrolling: false\n    }, _class;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n    var children = _ref2.children, direction = _ref2.direction, height = _ref2.height, layout = _ref2.layout, innerTagName = _ref2.innerTagName, outerTagName = _ref2.outerTagName, width = _ref2.width;\n    var instance = _ref3.instance;\n    if (true) {\n        if (innerTagName != null || outerTagName != null) {\n            if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n                devWarningsTagName$1.add(instance);\n                console.warn(\"The innerTagName and outerTagName props have been deprecated. \" + \"Please use the innerElementType and outerElementType props instead.\");\n            }\n        } // TODO Deprecate direction \"horizontal\"\n        var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n        switch(direction){\n            case \"horizontal\":\n            case \"vertical\":\n                if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n                    devWarningsDirection.add(instance);\n                    console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n                }\n                break;\n            case \"ltr\":\n            case \"rtl\":\n                break;\n            default:\n                throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + ('\"' + direction + '\" was specified.'));\n        }\n        switch(layout){\n            case \"horizontal\":\n            case \"vertical\":\n                break;\n            default:\n                throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + ('\"' + layout + '\" was specified.'));\n        }\n        if (children == null) {\n            throw Error('An invalid \"children\" prop has been specified. ' + \"Value should be a React component. \" + ('\"' + (children === null ? \"null\" : typeof children) + '\" was specified.'));\n        }\n        if (isHorizontal && typeof width !== \"number\") {\n            throw Error('An invalid \"width\" prop has been specified. ' + \"Horizontal lists must specify a number for width. \" + ('\"' + (width === null ? \"null\" : typeof width) + '\" was specified.'));\n        } else if (!isHorizontal && typeof height !== \"number\") {\n            throw Error('An invalid \"height\" prop has been specified. ' + \"Vertical lists must specify a number for height. \" + ('\"' + (height === null ? \"null\" : typeof height) + '\" was specified.'));\n        }\n    }\n};\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n    var _ref = props, itemSize = _ref.itemSize;\n    var itemMetadataMap = instanceProps.itemMetadataMap, lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n    if (index > lastMeasuredIndex) {\n        var offset = 0;\n        if (lastMeasuredIndex >= 0) {\n            var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n            offset = itemMetadata.offset + itemMetadata.size;\n        }\n        for(var i = lastMeasuredIndex + 1; i <= index; i++){\n            var size = itemSize(i);\n            itemMetadataMap[i] = {\n                offset: offset,\n                size: size\n            };\n            offset += size;\n        }\n        instanceProps.lastMeasuredIndex = index;\n    }\n    return itemMetadataMap[index];\n};\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n    var itemMetadataMap = instanceProps.itemMetadataMap, lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n    var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n    if (lastMeasuredItemOffset >= offset) {\n        // If we've already measured items within this range just use a binary search as it's faster.\n        return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n    } else {\n        // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n        // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n        // The overall complexity for this approach is O(log n).\n        return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n    }\n};\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n    while(low <= high){\n        var middle = low + Math.floor((high - low) / 2);\n        var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n        if (currentOffset === offset) {\n            return middle;\n        } else if (currentOffset < offset) {\n            low = middle + 1;\n        } else if (currentOffset > offset) {\n            high = middle - 1;\n        }\n    }\n    if (low > 0) {\n        return low - 1;\n    } else {\n        return 0;\n    }\n};\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n    var itemCount = props.itemCount;\n    var interval = 1;\n    while(index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset){\n        index += interval;\n        interval *= 2;\n    }\n    return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n    var itemCount = _ref2.itemCount;\n    var itemMetadataMap = _ref3.itemMetadataMap, estimatedItemSize = _ref3.estimatedItemSize, lastMeasuredIndex = _ref3.lastMeasuredIndex;\n    var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n    // https://github.com/bvaughn/react-window/pull/138\n    if (lastMeasuredIndex >= itemCount) {\n        lastMeasuredIndex = itemCount - 1;\n    }\n    if (lastMeasuredIndex >= 0) {\n        var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n        totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n    }\n    var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n    var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n    return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\nvar VariableSizeList = /*#__PURE__*/ createListComponent({\n    getItemOffset: function getItemOffset(props, index, instanceProps) {\n        return getItemMetadata$1(props, index, instanceProps).offset;\n    },\n    getItemSize: function getItemSize(props, index, instanceProps) {\n        return instanceProps.itemMetadataMap[index].size;\n    },\n    getEstimatedTotalSize: getEstimatedTotalSize,\n    getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n        var direction = props.direction, height = props.height, layout = props.layout, width = props.width; // TODO Deprecate direction \"horizontal\"\n        var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n        var size = isHorizontal ? width : height;\n        var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n        // To ensure it reflects actual measurements instead of just estimates.\n        var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n        var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n        var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size + scrollbarSize);\n        if (align === \"smart\") {\n            if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n                align = \"auto\";\n            } else {\n                align = \"center\";\n            }\n        }\n        switch(align){\n            case \"start\":\n                return maxOffset;\n            case \"end\":\n                return minOffset;\n            case \"center\":\n                return Math.round(minOffset + (maxOffset - minOffset) / 2);\n            case \"auto\":\n            default:\n                if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n                    return scrollOffset;\n                } else if (scrollOffset < minOffset) {\n                    return minOffset;\n                } else {\n                    return maxOffset;\n                }\n        }\n    },\n    getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n        return findNearestItem$1(props, instanceProps, offset);\n    },\n    getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n        var direction = props.direction, height = props.height, itemCount = props.itemCount, layout = props.layout, width = props.width; // TODO Deprecate direction \"horizontal\"\n        var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n        var size = isHorizontal ? width : height;\n        var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n        var maxOffset = scrollOffset + size;\n        var offset = itemMetadata.offset + itemMetadata.size;\n        var stopIndex = startIndex;\n        while(stopIndex < itemCount - 1 && offset < maxOffset){\n            stopIndex++;\n            offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n        }\n        return stopIndex;\n    },\n    initInstanceProps: function initInstanceProps(props, instance) {\n        var _ref4 = props, estimatedItemSize = _ref4.estimatedItemSize;\n        var instanceProps = {\n            itemMetadataMap: {},\n            estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n            lastMeasuredIndex: -1\n        };\n        instance.resetAfterIndex = function(index, shouldForceUpdate) {\n            if (shouldForceUpdate === void 0) {\n                shouldForceUpdate = true;\n            }\n            instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n            // But since styles are only cached while scrolling is in progress-\n            // It seems an unnecessary optimization.\n            // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n            instance._getItemStyleCache(-1);\n            if (shouldForceUpdate) {\n                instance.forceUpdate();\n            }\n        };\n        return instanceProps;\n    },\n    shouldResetStyleCacheOnItemSizeChange: false,\n    validateProps: function validateProps(_ref5) {\n        var itemSize = _ref5.itemSize;\n        if (true) {\n            if (typeof itemSize !== \"function\") {\n                throw Error('An invalid \"itemSize\" prop has been specified. ' + \"Value should be a function. \" + ('\"' + (itemSize === null ? \"null\" : typeof itemSize) + '\" was specified.'));\n            }\n        }\n    }\n});\nvar FixedSizeGrid = /*#__PURE__*/ createGridComponent({\n    getColumnOffset: function getColumnOffset(_ref, index) {\n        var columnWidth = _ref.columnWidth;\n        return index * columnWidth;\n    },\n    getColumnWidth: function getColumnWidth(_ref2, index) {\n        var columnWidth = _ref2.columnWidth;\n        return columnWidth;\n    },\n    getRowOffset: function getRowOffset(_ref3, index) {\n        var rowHeight = _ref3.rowHeight;\n        return index * rowHeight;\n    },\n    getRowHeight: function getRowHeight(_ref4, index) {\n        var rowHeight = _ref4.rowHeight;\n        return rowHeight;\n    },\n    getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n        var rowCount = _ref5.rowCount, rowHeight = _ref5.rowHeight;\n        return rowHeight * rowCount;\n    },\n    getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n        var columnCount = _ref6.columnCount, columnWidth = _ref6.columnWidth;\n        return columnWidth * columnCount;\n    },\n    getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n        var columnCount = _ref7.columnCount, columnWidth = _ref7.columnWidth, width = _ref7.width;\n        var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n        var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n        var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n        if (align === \"smart\") {\n            if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n                align = \"auto\";\n            } else {\n                align = \"center\";\n            }\n        }\n        switch(align){\n            case \"start\":\n                return maxOffset;\n            case \"end\":\n                return minOffset;\n            case \"center\":\n                // \"Centered\" offset is usually the average of the min and max.\n                // But near the edges of the list, this doesn't hold true.\n                var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n                if (middleOffset < Math.ceil(width / 2)) {\n                    return 0; // near the beginning\n                } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n                    return lastColumnOffset; // near the end\n                } else {\n                    return middleOffset;\n                }\n            case \"auto\":\n            default:\n                if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n                    return scrollLeft;\n                } else if (minOffset > maxOffset) {\n                    // Because we only take into account the scrollbar size when calculating minOffset\n                    // this value can be larger than maxOffset when at the end of the list\n                    return minOffset;\n                } else if (scrollLeft < minOffset) {\n                    return minOffset;\n                } else {\n                    return maxOffset;\n                }\n        }\n    },\n    getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n        var rowHeight = _ref8.rowHeight, height = _ref8.height, rowCount = _ref8.rowCount;\n        var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n        var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n        var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n        if (align === \"smart\") {\n            if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n                align = \"auto\";\n            } else {\n                align = \"center\";\n            }\n        }\n        switch(align){\n            case \"start\":\n                return maxOffset;\n            case \"end\":\n                return minOffset;\n            case \"center\":\n                // \"Centered\" offset is usually the average of the min and max.\n                // But near the edges of the list, this doesn't hold true.\n                var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n                if (middleOffset < Math.ceil(height / 2)) {\n                    return 0; // near the beginning\n                } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n                    return lastRowOffset; // near the end\n                } else {\n                    return middleOffset;\n                }\n            case \"auto\":\n            default:\n                if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n                    return scrollTop;\n                } else if (minOffset > maxOffset) {\n                    // Because we only take into account the scrollbar size when calculating minOffset\n                    // this value can be larger than maxOffset when at the end of the list\n                    return minOffset;\n                } else if (scrollTop < minOffset) {\n                    return minOffset;\n                } else {\n                    return maxOffset;\n                }\n        }\n    },\n    getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n        var columnWidth = _ref9.columnWidth, columnCount = _ref9.columnCount;\n        return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n    },\n    getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n        var columnWidth = _ref10.columnWidth, columnCount = _ref10.columnCount, width = _ref10.width;\n        var left = startIndex * columnWidth;\n        var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n        return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n        ));\n    },\n    getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n        var rowHeight = _ref11.rowHeight, rowCount = _ref11.rowCount;\n        return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n    },\n    getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n        var rowHeight = _ref12.rowHeight, rowCount = _ref12.rowCount, height = _ref12.height;\n        var top = startIndex * rowHeight;\n        var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n        return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n        ));\n    },\n    initInstanceProps: function initInstanceProps(props) {},\n    shouldResetStyleCacheOnItemSizeChange: true,\n    validateProps: function validateProps(_ref13) {\n        var columnWidth = _ref13.columnWidth, rowHeight = _ref13.rowHeight;\n        if (true) {\n            if (typeof columnWidth !== \"number\") {\n                throw Error('An invalid \"columnWidth\" prop has been specified. ' + \"Value should be a number. \" + ('\"' + (columnWidth === null ? \"null\" : typeof columnWidth) + '\" was specified.'));\n            }\n            if (typeof rowHeight !== \"number\") {\n                throw Error('An invalid \"rowHeight\" prop has been specified. ' + \"Value should be a number. \" + ('\"' + (rowHeight === null ? \"null\" : typeof rowHeight) + '\" was specified.'));\n            }\n        }\n    }\n});\nvar FixedSizeList = /*#__PURE__*/ createListComponent({\n    getItemOffset: function getItemOffset(_ref, index) {\n        var itemSize = _ref.itemSize;\n        return index * itemSize;\n    },\n    getItemSize: function getItemSize(_ref2, index) {\n        var itemSize = _ref2.itemSize;\n        return itemSize;\n    },\n    getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n        var itemCount = _ref3.itemCount, itemSize = _ref3.itemSize;\n        return itemSize * itemCount;\n    },\n    getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset, instanceProps, scrollbarSize) {\n        var direction = _ref4.direction, height = _ref4.height, itemCount = _ref4.itemCount, itemSize = _ref4.itemSize, layout = _ref4.layout, width = _ref4.width;\n        // TODO Deprecate direction \"horizontal\"\n        var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n        var size = isHorizontal ? width : height;\n        var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n        var maxOffset = Math.min(lastItemOffset, index * itemSize);\n        var minOffset = Math.max(0, index * itemSize - size + itemSize + scrollbarSize);\n        if (align === \"smart\") {\n            if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n                align = \"auto\";\n            } else {\n                align = \"center\";\n            }\n        }\n        switch(align){\n            case \"start\":\n                return maxOffset;\n            case \"end\":\n                return minOffset;\n            case \"center\":\n                {\n                    // \"Centered\" offset is usually the average of the min and max.\n                    // But near the edges of the list, this doesn't hold true.\n                    var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n                    if (middleOffset < Math.ceil(size / 2)) {\n                        return 0; // near the beginning\n                    } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n                        return lastItemOffset; // near the end\n                    } else {\n                        return middleOffset;\n                    }\n                }\n            case \"auto\":\n            default:\n                if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n                    return scrollOffset;\n                } else if (scrollOffset < minOffset) {\n                    return minOffset;\n                } else {\n                    return maxOffset;\n                }\n        }\n    },\n    getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n        var itemCount = _ref5.itemCount, itemSize = _ref5.itemSize;\n        return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n    },\n    getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n        var direction = _ref6.direction, height = _ref6.height, itemCount = _ref6.itemCount, itemSize = _ref6.itemSize, layout = _ref6.layout, width = _ref6.width;\n        // TODO Deprecate direction \"horizontal\"\n        var isHorizontal = direction === \"horizontal\" || layout === \"horizontal\";\n        var offset = startIndex * itemSize;\n        var size = isHorizontal ? width : height;\n        var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n        return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n        ));\n    },\n    initInstanceProps: function initInstanceProps(props) {},\n    shouldResetStyleCacheOnItemSizeChange: true,\n    validateProps: function validateProps(_ref7) {\n        var itemSize = _ref7.itemSize;\n        if (true) {\n            if (typeof itemSize !== \"number\") {\n                throw Error('An invalid \"itemSize\" prop has been specified. ' + \"Value should be a number. \" + ('\"' + (itemSize === null ? \"null\" : typeof itemSize) + '\" was specified.'));\n            }\n        }\n    }\n});\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n    for(var attribute in prev){\n        if (!(attribute in next)) {\n            return true;\n        }\n    }\n    for(var _attribute in next){\n        if (prev[_attribute] !== next[_attribute]) {\n            return true;\n        }\n    }\n    return false;\n}\nvar _excluded = [\n    \"style\"\n], _excluded2 = [\n    \"style\"\n];\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\nfunction areEqual(prevProps, nextProps) {\n    var prevStyle = prevProps.style, prevRest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(prevProps, _excluded);\n    var nextStyle = nextProps.style, nextRest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(nextProps, _excluded2);\n    return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\nfunction shouldComponentUpdate(nextProps, nextState) {\n    return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtd2luZG93L2Rpc3QvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDNEI7QUFDaEI7QUFDakM7QUFDZ0I7QUFDK0M7QUFFcEcsc0RBQXNEO0FBQ3RELDZGQUE2RjtBQUM3RixJQUFJTywwQkFBMEIsT0FBT0MsZ0JBQWdCLFlBQVksT0FBT0EsWUFBWUMsR0FBRyxLQUFLO0FBQzVGLElBQUlBLE1BQU1GLDBCQUEwQjtJQUNsQyxPQUFPQyxZQUFZQyxHQUFHO0FBQ3hCLElBQUk7SUFDRixPQUFPQyxLQUFLRCxHQUFHO0FBQ2pCO0FBQ0EsU0FBU0UsY0FBY0MsU0FBUztJQUM5QkMscUJBQXFCRCxVQUFVRSxFQUFFO0FBQ25DO0FBQ0EsU0FBU0MsZUFBZUMsUUFBUSxFQUFFQyxLQUFLO0lBQ3JDLElBQUlDLFFBQVFUO0lBRVosU0FBU1U7UUFDUCxJQUFJVixRQUFRUyxTQUFTRCxPQUFPO1lBQzFCRCxTQUFTSSxJQUFJLENBQUM7UUFDaEIsT0FBTztZQUNMUixVQUFVRSxFQUFFLEdBQUdPLHNCQUFzQkY7UUFDdkM7SUFDRjtJQUVBLElBQUlQLFlBQVk7UUFDZEUsSUFBSU8sc0JBQXNCRjtJQUM1QjtJQUNBLE9BQU9QO0FBQ1Q7QUFFQSxJQUFJVSxPQUFPLENBQUMsR0FBRyxrREFBa0Q7QUFFakUsU0FBU0MsaUJBQWlCQyxXQUFXO0lBQ25DLElBQUlBLGdCQUFnQixLQUFLLEdBQUc7UUFDMUJBLGNBQWM7SUFDaEI7SUFFQSxJQUFJRixTQUFTLENBQUMsS0FBS0UsYUFBYTtRQUM5QixJQUFJQyxNQUFNQyxTQUFTdEIsYUFBYSxDQUFDO1FBQ2pDLElBQUl1QixRQUFRRixJQUFJRSxLQUFLO1FBQ3JCQSxNQUFNQyxLQUFLLEdBQUc7UUFDZEQsTUFBTUUsTUFBTSxHQUFHO1FBQ2ZGLE1BQU1HLFFBQVEsR0FBRztRQUNqQkosU0FBU0ssSUFBSSxDQUFDQyxXQUFXLENBQUNQO1FBQzFCSCxPQUFPRyxJQUFJUSxXQUFXLEdBQUdSLElBQUlTLFdBQVc7UUFDeENSLFNBQVNLLElBQUksQ0FBQ0ksV0FBVyxDQUFDVjtJQUM1QjtJQUVBLE9BQU9IO0FBQ1Q7QUFDQSxJQUFJYyxrQkFBa0IsTUFBTSx3RkFBd0Y7QUFDcEgsc0dBQXNHO0FBQ3RHLG9HQUFvRztBQUNwRywwRUFBMEU7QUFDMUUsa0ZBQWtGO0FBQ2xGLHFGQUFxRjtBQUVyRixTQUFTQyxpQkFBaUJiLFdBQVc7SUFDbkMsSUFBSUEsZ0JBQWdCLEtBQUssR0FBRztRQUMxQkEsY0FBYztJQUNoQjtJQUVBLElBQUlZLG9CQUFvQixRQUFRWixhQUFhO1FBQzNDLElBQUljLFdBQVdaLFNBQVN0QixhQUFhLENBQUM7UUFDdEMsSUFBSW1DLGFBQWFELFNBQVNYLEtBQUs7UUFDL0JZLFdBQVdYLEtBQUssR0FBRztRQUNuQlcsV0FBV1YsTUFBTSxHQUFHO1FBQ3BCVSxXQUFXVCxRQUFRLEdBQUc7UUFDdEJTLFdBQVdDLFNBQVMsR0FBRztRQUN2QixJQUFJQyxXQUFXZixTQUFTdEIsYUFBYSxDQUFDO1FBQ3RDLElBQUlzQyxhQUFhRCxTQUFTZCxLQUFLO1FBQy9CZSxXQUFXZCxLQUFLLEdBQUc7UUFDbkJjLFdBQVdiLE1BQU0sR0FBRztRQUNwQlMsU0FBU04sV0FBVyxDQUFDUztRQUNyQmYsU0FBU0ssSUFBSSxDQUFDQyxXQUFXLENBQUNNO1FBRTFCLElBQUlBLFNBQVNLLFVBQVUsR0FBRyxHQUFHO1lBQzNCUCxrQkFBa0I7UUFDcEIsT0FBTztZQUNMRSxTQUFTSyxVQUFVLEdBQUc7WUFFdEIsSUFBSUwsU0FBU0ssVUFBVSxLQUFLLEdBQUc7Z0JBQzdCUCxrQkFBa0I7WUFDcEIsT0FBTztnQkFDTEEsa0JBQWtCO1lBQ3BCO1FBQ0Y7UUFFQVYsU0FBU0ssSUFBSSxDQUFDSSxXQUFXLENBQUNHO1FBQzFCLE9BQU9GO0lBQ1Q7SUFFQSxPQUFPQTtBQUNUO0FBRUEsSUFBSVEsaUNBQWlDO0FBRXJDLElBQUlDLGlCQUFpQixTQUFTQSxlQUFlQyxJQUFJO0lBQy9DLElBQUlDLGNBQWNELEtBQUtDLFdBQVcsRUFDOUJDLE9BQU9GLEtBQUtFLElBQUksRUFDaEJDLFdBQVdILEtBQUtHLFFBQVE7SUFDNUIsT0FBT0EsV0FBVyxNQUFNRjtBQUMxQixHQUFHLGlGQUFpRjtBQUNwRixnRUFBZ0U7QUFHaEUsSUFBSUcsMkJBQTJCO0FBQy9CLElBQUlDLHNDQUFzQztBQUMxQyxJQUFJQyxxQkFBcUI7QUFFekIsSUFBSUMsSUFBeUIsRUFBYztJQUN6QyxJQUFJLEtBQTJELEVBQWEsRUFJM0U7QUFDSDtBQUVBLFNBQVNHLG9CQUFvQkMsS0FBSztJQUNoQyxJQUFJQztJQUVKLElBQUlDLGtCQUFrQkYsTUFBTUUsZUFBZSxFQUN2Q0MsK0JBQStCSCxNQUFNRyw0QkFBNEIsRUFDakVDLGtDQUFrQ0osTUFBTUksK0JBQStCLEVBQ3ZFQyxpQkFBaUJMLE1BQU1LLGNBQWMsRUFDckNDLDBCQUEwQk4sTUFBTU0sdUJBQXVCLEVBQ3ZEQyx5QkFBeUJQLE1BQU1PLHNCQUFzQixFQUNyREMsaUNBQWlDUixNQUFNUSw4QkFBOEIsRUFDckVDLDhCQUE4QlQsTUFBTVMsMkJBQTJCLEVBQy9EQyxlQUFlVixNQUFNVSxZQUFZLEVBQ2pDQyxlQUFlWCxNQUFNVyxZQUFZLEVBQ2pDQyw0QkFBNEJaLE1BQU1ZLHlCQUF5QixFQUMzREMsK0JBQStCYixNQUFNYSw0QkFBNEIsRUFDakVDLG9CQUFvQmQsTUFBTWMsaUJBQWlCLEVBQzNDQyx3Q0FBd0NmLE1BQU1lLHFDQUFxQyxFQUNuRkMsZ0JBQWdCaEIsTUFBTWdCLGFBQWE7SUFDdkMsT0FBT2YsU0FBUyxXQUFXLEdBQUUsU0FBVWdCLGNBQWM7UUFDbkR4RSxvRkFBY0EsQ0FBQ3lFLE1BQU1EO1FBRXJCLHdEQUF3RDtRQUN4RCxtREFBbUQ7UUFDbkQsa0RBQWtEO1FBQ2xELFNBQVNDLEtBQUtDLEtBQUs7WUFDakIsSUFBSUM7WUFFSkEsUUFBUUgsZUFBZXRELElBQUksQ0FBQyxJQUFJLEVBQUV3RCxVQUFVLElBQUk7WUFDaERDLE1BQU1DLGNBQWMsR0FBR1Asa0JBQWtCTSxNQUFNRCxLQUFLLEVBQUUzRSw0RkFBc0JBLENBQUM0RTtZQUM3RUEsTUFBTUUsMEJBQTBCLEdBQUc7WUFDbkNGLE1BQU1HLFNBQVMsR0FBRyxLQUFLO1lBQ3ZCSCxNQUFNSSxLQUFLLEdBQUc7Z0JBQ1pDLFVBQVVqRiw0RkFBc0JBLENBQUM0RTtnQkFDakNNLGFBQWE7Z0JBQ2JDLDJCQUEyQjtnQkFDM0J6QyxZQUFZLE9BQU9rQyxNQUFNRCxLQUFLLENBQUNTLGlCQUFpQixLQUFLLFdBQVdSLE1BQU1ELEtBQUssQ0FBQ1MsaUJBQWlCLEdBQUc7Z0JBQ2hHQyxXQUFXLE9BQU9ULE1BQU1ELEtBQUssQ0FBQ1csZ0JBQWdCLEtBQUssV0FBV1YsTUFBTUQsS0FBSyxDQUFDVyxnQkFBZ0IsR0FBRztnQkFDN0ZDLDBCQUEwQjtnQkFDMUJDLHlCQUF5QjtZQUMzQjtZQUNBWixNQUFNYSxvQkFBb0IsR0FBRyxLQUFLO1lBQ2xDYixNQUFNYSxvQkFBb0IsR0FBR3ZGLHVEQUFVQSxDQUFDLFNBQVV3Rix3QkFBd0IsRUFBRUMsdUJBQXVCLEVBQUVDLHFCQUFxQixFQUFFQyxvQkFBb0IsRUFBRUMsdUJBQXVCLEVBQUVDLHNCQUFzQixFQUFFQyxvQkFBb0IsRUFBRUMsbUJBQW1CO2dCQUMxTyxPQUFPckIsTUFBTUQsS0FBSyxDQUFDdUIsZUFBZSxDQUFDO29CQUNqQ1IsMEJBQTBCQTtvQkFDMUJDLHlCQUF5QkE7b0JBQ3pCQyx1QkFBdUJBO29CQUN2QkMsc0JBQXNCQTtvQkFDdEJDLHlCQUF5QkE7b0JBQ3pCQyx3QkFBd0JBO29CQUN4QkMsc0JBQXNCQTtvQkFDdEJDLHFCQUFxQkE7Z0JBQ3ZCO1lBQ0Y7WUFDQXJCLE1BQU11QixhQUFhLEdBQUcsS0FBSztZQUMzQnZCLE1BQU11QixhQUFhLEdBQUdqRyx1REFBVUEsQ0FBQyxTQUFVd0MsVUFBVSxFQUFFMkMsU0FBUyxFQUFFRix5QkFBeUIsRUFBRUssdUJBQXVCLEVBQUVELHdCQUF3QjtnQkFDNUksT0FBT1gsTUFBTUQsS0FBSyxDQUFDeUIsUUFBUSxDQUFDO29CQUMxQmpCLDJCQUEyQkE7b0JBQzNCekMsWUFBWUE7b0JBQ1oyQyxXQUFXQTtvQkFDWEcseUJBQXlCQTtvQkFDekJELDBCQUEwQkE7Z0JBQzVCO1lBQ0Y7WUFDQVgsTUFBTXlCLGFBQWEsR0FBRyxLQUFLO1lBRTNCekIsTUFBTXlCLGFBQWEsR0FBRyxTQUFVckQsUUFBUSxFQUFFRixXQUFXO2dCQUNuRCxJQUFJd0QsY0FBYzFCLE1BQU1ELEtBQUssRUFDekI0QixjQUFjRCxZQUFZQyxXQUFXLEVBQ3JDaEUsWUFBWStELFlBQVkvRCxTQUFTLEVBQ2pDaUUsWUFBWUYsWUFBWUUsU0FBUztnQkFFckMsSUFBSUMsaUJBQWlCN0IsTUFBTThCLGtCQUFrQixDQUFDbkMseUNBQXlDZ0MsYUFBYWhDLHlDQUF5Q2hDLFdBQVdnQyx5Q0FBeUNpQztnQkFFak0sSUFBSUcsTUFBTTNELFdBQVcsTUFBTUY7Z0JBQzNCLElBQUlwQjtnQkFFSixJQUFJK0UsZUFBZUcsY0FBYyxDQUFDRCxNQUFNO29CQUN0Q2pGLFFBQVErRSxjQUFjLENBQUNFLElBQUk7Z0JBQzdCLE9BQU87b0JBQ0wsSUFBSUUsVUFBVW5ELGdCQUFnQmtCLE1BQU1ELEtBQUssRUFBRTdCLGFBQWE4QixNQUFNQyxjQUFjO29CQUU1RSxJQUFJaUMsUUFBUXZFLGNBQWM7b0JBQzFCa0UsY0FBYyxDQUFDRSxJQUFJLEdBQUdqRixRQUFRO3dCQUM1QnFGLFVBQVU7d0JBQ1ZDLE1BQU1GLFFBQVFHLFlBQVlKO3dCQUMxQkssT0FBT0osUUFBUUQsVUFBVUk7d0JBQ3pCRSxLQUFLaEQsYUFBYVMsTUFBTUQsS0FBSyxFQUFFM0IsVUFBVTRCLE1BQU1DLGNBQWM7d0JBQzdEakQsUUFBUXNDLGFBQWFVLE1BQU1ELEtBQUssRUFBRTNCLFVBQVU0QixNQUFNQyxjQUFjO3dCQUNoRWxELE9BQU9rQyxlQUFlZSxNQUFNRCxLQUFLLEVBQUU3QixhQUFhOEIsTUFBTUMsY0FBYztvQkFDdEU7Z0JBQ0Y7Z0JBRUEsT0FBT25EO1lBQ1Q7WUFFQWtELE1BQU04QixrQkFBa0IsR0FBRyxLQUFLO1lBQ2hDOUIsTUFBTThCLGtCQUFrQixHQUFHeEcsdURBQVVBLENBQUMsU0FBVWtILENBQUMsRUFBRUMsRUFBRSxFQUFFQyxHQUFHO2dCQUN4RCxPQUFPLENBQUM7WUFDVjtZQUVBMUMsTUFBTTJDLFNBQVMsR0FBRyxTQUFVQyxLQUFLO2dCQUMvQixJQUFJQyx1QkFBdUJELE1BQU1FLGFBQWEsRUFDMUNDLGVBQWVGLHFCQUFxQkUsWUFBWSxFQUNoRDFGLGNBQWN3RixxQkFBcUJ4RixXQUFXLEVBQzlDUyxhQUFhK0UscUJBQXFCL0UsVUFBVSxFQUM1QzJDLFlBQVlvQyxxQkFBcUJwQyxTQUFTLEVBQzFDdUMsZUFBZUgscUJBQXFCRyxZQUFZLEVBQ2hEQyxjQUFjSixxQkFBcUJJLFdBQVc7Z0JBRWxEakQsTUFBTWtELFFBQVEsQ0FBQyxTQUFVQyxTQUFTO29CQUNoQyxJQUFJQSxVQUFVckYsVUFBVSxLQUFLQSxjQUFjcUYsVUFBVTFDLFNBQVMsS0FBS0EsV0FBVzt3QkFDNUUsb0RBQW9EO3dCQUNwRCx5REFBeUQ7d0JBQ3pELGlEQUFpRDt3QkFDakQsT0FBTztvQkFDVDtvQkFFQSxJQUFJOUMsWUFBWXFDLE1BQU1ELEtBQUssQ0FBQ3BDLFNBQVMsRUFBRSx3RkFBd0Y7b0JBQy9ILHdIQUF3SDtvQkFDeEgsNEdBQTRHO29CQUM1RywrR0FBK0c7b0JBRS9HLElBQUl5Rix1QkFBdUJ0RjtvQkFFM0IsSUFBSUgsY0FBYyxPQUFPO3dCQUN2QixPQUFRSDs0QkFDTixLQUFLO2dDQUNINEYsdUJBQXVCLENBQUN0RjtnQ0FDeEI7NEJBRUYsS0FBSztnQ0FDSHNGLHVCQUF1QkgsY0FBYzVGLGNBQWNTO2dDQUNuRDt3QkFDSjtvQkFDRixFQUFFLDZGQUE2RjtvQkFHL0ZzRix1QkFBdUJDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUNILHNCQUFzQkgsY0FBYzVGO29CQUNoRixJQUFJbUcsc0JBQXNCSCxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDOUMsV0FBV3VDLGVBQWVEO29CQUN6RSxPQUFPO3dCQUNMekMsYUFBYTt3QkFDYkMsMkJBQTJCNEMsVUFBVXJGLFVBQVUsR0FBR0EsYUFBYSxZQUFZO3dCQUMzRUEsWUFBWXNGO3dCQUNaM0MsV0FBVytDO3dCQUNYNUMseUJBQXlCdUMsVUFBVTFDLFNBQVMsR0FBR0EsWUFBWSxZQUFZO3dCQUN2RUUsMEJBQTBCO29CQUM1QjtnQkFDRixHQUFHWCxNQUFNeUQsMEJBQTBCO1lBQ3JDO1lBRUF6RCxNQUFNMEQsZUFBZSxHQUFHLFNBQVVDLEdBQUc7Z0JBQ25DLElBQUlDLFdBQVc1RCxNQUFNRCxLQUFLLENBQUM2RCxRQUFRO2dCQUNuQzVELE1BQU1HLFNBQVMsR0FBR3dEO2dCQUVsQixJQUFJLE9BQU9DLGFBQWEsWUFBWTtvQkFDbENBLFNBQVNEO2dCQUNYLE9BQU8sSUFBSUMsWUFBWSxRQUFRLE9BQU9BLGFBQWEsWUFBWUEsU0FBUzVCLGNBQWMsQ0FBQyxZQUFZO29CQUNqRzRCLFNBQVNDLE9BQU8sR0FBR0Y7Z0JBQ3JCO1lBQ0Y7WUFFQTNELE1BQU15RCwwQkFBMEIsR0FBRztnQkFDakMsSUFBSXpELE1BQU1FLDBCQUEwQixLQUFLLE1BQU07b0JBQzdDcEUsY0FBY2tFLE1BQU1FLDBCQUEwQjtnQkFDaEQ7Z0JBRUFGLE1BQU1FLDBCQUEwQixHQUFHaEUsZUFBZThELE1BQU04RCxpQkFBaUIsRUFBRS9GO1lBQzdFO1lBRUFpQyxNQUFNOEQsaUJBQWlCLEdBQUc7Z0JBQ3hCOUQsTUFBTUUsMEJBQTBCLEdBQUc7Z0JBRW5DRixNQUFNa0QsUUFBUSxDQUFDO29CQUNiNUMsYUFBYTtnQkFDZixHQUFHO29CQUNELDJEQUEyRDtvQkFDM0QsK0VBQStFO29CQUMvRU4sTUFBTThCLGtCQUFrQixDQUFDLENBQUM7Z0JBQzVCO1lBQ0Y7WUFFQSxPQUFPOUI7UUFDVDtRQUVBRixLQUFLaUUsd0JBQXdCLEdBQUcsU0FBU0EseUJBQXlCQyxTQUFTLEVBQUViLFNBQVM7WUFDcEZjLG9CQUFvQkQsV0FBV2I7WUFDL0J2RCxjQUFjb0U7WUFDZCxPQUFPO1FBQ1Q7UUFFQSxJQUFJRSxTQUFTcEUsS0FBS3FFLFNBQVM7UUFFM0JELE9BQU9FLFFBQVEsR0FBRyxTQUFTQSxTQUFTQyxLQUFLO1lBQ3ZDLElBQUl2RyxhQUFhdUcsTUFBTXZHLFVBQVUsRUFDN0IyQyxZQUFZNEQsTUFBTTVELFNBQVM7WUFFL0IsSUFBSTNDLGVBQWV1RSxXQUFXO2dCQUM1QnZFLGFBQWF1RixLQUFLQyxHQUFHLENBQUMsR0FBR3hGO1lBQzNCO1lBRUEsSUFBSTJDLGNBQWM0QixXQUFXO2dCQUMzQjVCLFlBQVk0QyxLQUFLQyxHQUFHLENBQUMsR0FBRzdDO1lBQzFCO1lBRUEsSUFBSSxDQUFDeUMsUUFBUSxDQUFDLFNBQVVDLFNBQVM7Z0JBQy9CLElBQUlyRixlQUFldUUsV0FBVztvQkFDNUJ2RSxhQUFhcUYsVUFBVXJGLFVBQVU7Z0JBQ25DO2dCQUVBLElBQUkyQyxjQUFjNEIsV0FBVztvQkFDM0I1QixZQUFZMEMsVUFBVTFDLFNBQVM7Z0JBQ2pDO2dCQUVBLElBQUkwQyxVQUFVckYsVUFBVSxLQUFLQSxjQUFjcUYsVUFBVTFDLFNBQVMsS0FBS0EsV0FBVztvQkFDNUUsT0FBTztnQkFDVDtnQkFFQSxPQUFPO29CQUNMRiwyQkFBMkI0QyxVQUFVckYsVUFBVSxHQUFHQSxhQUFhLFlBQVk7b0JBQzNFQSxZQUFZQTtvQkFDWjJDLFdBQVdBO29CQUNYRSwwQkFBMEI7b0JBQzFCQyx5QkFBeUJ1QyxVQUFVMUMsU0FBUyxHQUFHQSxZQUFZLFlBQVk7Z0JBQ3pFO1lBQ0YsR0FBRyxJQUFJLENBQUNnRCwwQkFBMEI7UUFDcEM7UUFFQVMsT0FBT0ksWUFBWSxHQUFHLFNBQVNBLGFBQWFDLEtBQUs7WUFDL0MsSUFBSUMsY0FBY0QsTUFBTUUsS0FBSyxFQUN6QkEsUUFBUUQsZ0JBQWdCLEtBQUssSUFBSSxTQUFTQSxhQUMxQ3RHLGNBQWNxRyxNQUFNckcsV0FBVyxFQUMvQkUsV0FBV21HLE1BQU1uRyxRQUFRO1lBQzdCLElBQUlzRyxlQUFlLElBQUksQ0FBQzNFLEtBQUssRUFDekI0RSxjQUFjRCxhQUFhQyxXQUFXLEVBQ3RDM0gsU0FBUzBILGFBQWExSCxNQUFNLEVBQzVCNEgsV0FBV0YsYUFBYUUsUUFBUSxFQUNoQzdILFFBQVEySCxhQUFhM0gsS0FBSztZQUM5QixJQUFJOEgsY0FBYyxJQUFJLENBQUN6RSxLQUFLLEVBQ3hCdEMsYUFBYStHLFlBQVkvRyxVQUFVLEVBQ25DMkMsWUFBWW9FLFlBQVlwRSxTQUFTO1lBQ3JDLElBQUlxRSxnQkFBZ0JwSTtZQUVwQixJQUFJd0IsZ0JBQWdCbUUsV0FBVztnQkFDN0JuRSxjQUFjbUYsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQ3JGLGFBQWF5RyxjQUFjO1lBQ2hFO1lBRUEsSUFBSXZHLGFBQWFpRSxXQUFXO2dCQUMxQmpFLFdBQVdpRixLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDbkYsVUFBVXdHLFdBQVc7WUFDdkQ7WUFFQSxJQUFJRyx1QkFBdUI3Rix3QkFBd0IsSUFBSSxDQUFDYSxLQUFLLEVBQUUsSUFBSSxDQUFDRSxjQUFjO1lBQ2xGLElBQUkrRSxzQkFBc0I3Rix1QkFBdUIsSUFBSSxDQUFDWSxLQUFLLEVBQUUsSUFBSSxDQUFDRSxjQUFjLEdBQUcsNEVBQTRFO1lBQy9KLGdDQUFnQztZQUNoQyx1RUFBdUU7WUFFdkUsSUFBSWdGLDBCQUEwQkQsc0JBQXNCakksUUFBUStILGdCQUFnQjtZQUM1RSxJQUFJSSx3QkFBd0JILHVCQUF1Qi9ILFNBQVM4SCxnQkFBZ0I7WUFDNUUsSUFBSSxDQUFDVixRQUFRLENBQUM7Z0JBQ1p0RyxZQUFZSSxnQkFBZ0JtRSxZQUFZakQsK0JBQStCLElBQUksQ0FBQ1csS0FBSyxFQUFFN0IsYUFBYXVHLE9BQU8zRyxZQUFZLElBQUksQ0FBQ21DLGNBQWMsRUFBRWlGLHlCQUF5QnBIO2dCQUNqSzJDLFdBQVdyQyxhQUFhaUUsWUFBWWhELDRCQUE0QixJQUFJLENBQUNVLEtBQUssRUFBRTNCLFVBQVVxRyxPQUFPaEUsV0FBVyxJQUFJLENBQUNSLGNBQWMsRUFBRWdGLDJCQUEyQnhFO1lBQzFKO1FBQ0Y7UUFFQXlELE9BQU9pQixpQkFBaUIsR0FBRyxTQUFTQTtZQUNsQyxJQUFJQyxlQUFlLElBQUksQ0FBQ3JGLEtBQUssRUFDekJTLG9CQUFvQjRFLGFBQWE1RSxpQkFBaUIsRUFDbERFLG1CQUFtQjBFLGFBQWExRSxnQkFBZ0I7WUFFcEQsSUFBSSxJQUFJLENBQUNQLFNBQVMsSUFBSSxNQUFNO2dCQUMxQixJQUFJeUQsV0FBVyxJQUFJLENBQUN6RCxTQUFTO2dCQUU3QixJQUFJLE9BQU9LLHNCQUFzQixVQUFVO29CQUN6Q29ELFNBQVM5RixVQUFVLEdBQUcwQztnQkFDeEI7Z0JBRUEsSUFBSSxPQUFPRSxxQkFBcUIsVUFBVTtvQkFDeENrRCxTQUFTbkQsU0FBUyxHQUFHQztnQkFDdkI7WUFDRjtZQUVBLElBQUksQ0FBQzJFLG1CQUFtQjtRQUMxQjtRQUVBbkIsT0FBT29CLGtCQUFrQixHQUFHLFNBQVNBO1lBQ25DLElBQUkzSCxZQUFZLElBQUksQ0FBQ29DLEtBQUssQ0FBQ3BDLFNBQVM7WUFDcEMsSUFBSTRILGVBQWUsSUFBSSxDQUFDbkYsS0FBSyxFQUN6QnRDLGFBQWF5SCxhQUFhekgsVUFBVSxFQUNwQzJDLFlBQVk4RSxhQUFhOUUsU0FBUyxFQUNsQ0UsMkJBQTJCNEUsYUFBYTVFLHdCQUF3QjtZQUVwRSxJQUFJQSw0QkFBNEIsSUFBSSxDQUFDUixTQUFTLElBQUksTUFBTTtnQkFDdEQsd0ZBQXdGO2dCQUN4Rix3SEFBd0g7Z0JBQ3hILG1GQUFtRjtnQkFDbkYsSUFBSXlELFdBQVcsSUFBSSxDQUFDekQsU0FBUztnQkFFN0IsSUFBSXhDLGNBQWMsT0FBTztvQkFDdkIsT0FBUUg7d0JBQ04sS0FBSzs0QkFDSG9HLFNBQVM5RixVQUFVLEdBQUcsQ0FBQ0E7NEJBQ3ZCO3dCQUVGLEtBQUs7NEJBQ0g4RixTQUFTOUYsVUFBVSxHQUFHQTs0QkFDdEI7d0JBRUY7NEJBQ0UsSUFBSVQsY0FBY3VHLFNBQVN2RyxXQUFXLEVBQ2xDNEYsY0FBY1csU0FBU1gsV0FBVzs0QkFDdENXLFNBQVM5RixVQUFVLEdBQUdtRixjQUFjNUYsY0FBY1M7NEJBQ2xEO29CQUNKO2dCQUNGLE9BQU87b0JBQ0w4RixTQUFTOUYsVUFBVSxHQUFHdUYsS0FBS0MsR0FBRyxDQUFDLEdBQUd4RjtnQkFDcEM7Z0JBRUE4RixTQUFTbkQsU0FBUyxHQUFHNEMsS0FBS0MsR0FBRyxDQUFDLEdBQUc3QztZQUNuQztZQUVBLElBQUksQ0FBQzRFLG1CQUFtQjtRQUMxQjtRQUVBbkIsT0FBT3NCLG9CQUFvQixHQUFHLFNBQVNBO1lBQ3JDLElBQUksSUFBSSxDQUFDdEYsMEJBQTBCLEtBQUssTUFBTTtnQkFDNUNwRSxjQUFjLElBQUksQ0FBQ29FLDBCQUEwQjtZQUMvQztRQUNGO1FBRUFnRSxPQUFPdUIsTUFBTSxHQUFHLFNBQVNBO1lBQ3ZCLElBQUlDLGVBQWUsSUFBSSxDQUFDM0YsS0FBSyxFQUN6QjRGLFdBQVdELGFBQWFDLFFBQVEsRUFDaENDLFlBQVlGLGFBQWFFLFNBQVMsRUFDbENqQixjQUFjZSxhQUFhZixXQUFXLEVBQ3RDaEgsWUFBWStILGFBQWEvSCxTQUFTLEVBQ2xDWCxTQUFTMEksYUFBYTFJLE1BQU0sRUFDNUI2SSxXQUFXSCxhQUFhRyxRQUFRLEVBQ2hDQyxtQkFBbUJKLGFBQWFJLGdCQUFnQixFQUNoREMsZUFBZUwsYUFBYUssWUFBWSxFQUN4Q0MsV0FBV04sYUFBYU0sUUFBUSxFQUNoQ0MsdUJBQXVCUCxhQUFhUSxPQUFPLEVBQzNDQSxVQUFVRCx5QkFBeUIsS0FBSyxJQUFJakksaUJBQWlCaUksc0JBQzdERSxtQkFBbUJULGFBQWFTLGdCQUFnQixFQUNoREMsZUFBZVYsYUFBYVUsWUFBWSxFQUN4Q3hCLFdBQVdjLGFBQWFkLFFBQVEsRUFDaEM5SCxRQUFRNEksYUFBYTVJLEtBQUssRUFDMUJ1SixpQkFBaUJYLGFBQWFXLGNBQWMsRUFDNUN0SixRQUFRMkksYUFBYTNJLEtBQUs7WUFDOUIsSUFBSXVELGNBQWMsSUFBSSxDQUFDRixLQUFLLENBQUNFLFdBQVc7WUFFeEMsSUFBSWdHLHdCQUF3QixJQUFJLENBQUNDLDJCQUEyQixJQUN4REMsbUJBQW1CRixxQkFBcUIsQ0FBQyxFQUFFLEVBQzNDRyxrQkFBa0JILHFCQUFxQixDQUFDLEVBQUU7WUFFOUMsSUFBSUksd0JBQXdCLElBQUksQ0FBQ0MseUJBQXlCLElBQ3REQyxnQkFBZ0JGLHFCQUFxQixDQUFDLEVBQUUsRUFDeENHLGVBQWVILHFCQUFxQixDQUFDLEVBQUU7WUFFM0MsSUFBSUksUUFBUSxFQUFFO1lBRWQsSUFBSW5DLGNBQWMsS0FBS0MsVUFBVTtnQkFDL0IsSUFBSyxJQUFJbUMsWUFBWUgsZUFBZUcsYUFBYUYsY0FBY0UsWUFBYTtvQkFDMUUsSUFBSyxJQUFJQyxlQUFlUixrQkFBa0JRLGdCQUFnQlAsaUJBQWlCTyxlQUFnQjt3QkFDekZGLE1BQU1HLElBQUksZUFBQzFMLG9EQUFhQSxDQUFDb0ssVUFBVTs0QkFDakN6SCxhQUFhOEk7NEJBQ2I3SSxNQUFNNkg7NEJBQ04xRixhQUFhK0YsaUJBQWlCL0YsY0FBYytCOzRCQUM1Q04sS0FBS21FLFFBQVE7Z0NBQ1hoSSxhQUFhOEk7Z0NBQ2I3SSxNQUFNNkg7Z0NBQ041SCxVQUFVMkk7NEJBQ1o7NEJBQ0EzSSxVQUFVMkk7NEJBQ1ZqSyxPQUFPLElBQUksQ0FBQzJFLGFBQWEsQ0FBQ3NGLFdBQVdDO3dCQUN2QztvQkFDRjtnQkFDRjtZQUNGLEVBQUUsaURBQWlEO1lBQ25ELG9FQUFvRTtZQUdwRSxJQUFJakMsdUJBQXVCN0Ysd0JBQXdCLElBQUksQ0FBQ2EsS0FBSyxFQUFFLElBQUksQ0FBQ0UsY0FBYztZQUNsRixJQUFJK0Usc0JBQXNCN0YsdUJBQXVCLElBQUksQ0FBQ1ksS0FBSyxFQUFFLElBQUksQ0FBQ0UsY0FBYztZQUNoRixxQkFBTzFFLG9EQUFhQSxDQUFDNEssb0JBQW9CQyxnQkFBZ0IsT0FBTztnQkFDOURSLFdBQVdBO2dCQUNYcEUsVUFBVSxJQUFJLENBQUNtQixTQUFTO2dCQUN4QmdCLEtBQUssSUFBSSxDQUFDRCxlQUFlO2dCQUN6QjVHLE9BQU8zQiw4RUFBUUEsQ0FBQztvQkFDZGdILFVBQVU7b0JBQ1ZuRixRQUFRQTtvQkFDUkQsT0FBT0E7b0JBQ1BFLFVBQVU7b0JBQ1ZpSyx5QkFBeUI7b0JBQ3pCQyxZQUFZO29CQUNaeEosV0FBV0E7Z0JBQ2IsR0FBR2I7WUFDTCxpQkFBR3ZCLG9EQUFhQSxDQUFDdUssb0JBQW9CQyxnQkFBZ0IsT0FBTztnQkFDMURKLFVBQVVtQjtnQkFDVm5ELEtBQUtrQztnQkFDTC9JLE9BQU87b0JBQ0xFLFFBQVErSDtvQkFDUnFDLGVBQWU5RyxjQUFjLFNBQVMrQjtvQkFDdEN0RixPQUFPaUk7Z0JBQ1Q7WUFDRjtRQUNGO1FBRUFkLE9BQU9tQixtQkFBbUIsR0FBRyxTQUFTQTtZQUNwQyxJQUFJZ0MsZUFBZSxJQUFJLENBQUN0SCxLQUFLLEVBQ3pCNEUsY0FBYzBDLGFBQWExQyxXQUFXLEVBQ3RDckQsa0JBQWtCK0YsYUFBYS9GLGVBQWUsRUFDOUNFLFdBQVc2RixhQUFhN0YsUUFBUSxFQUNoQ29ELFdBQVd5QyxhQUFhekMsUUFBUTtZQUVwQyxJQUFJLE9BQU90RCxvQkFBb0IsWUFBWTtnQkFDekMsSUFBSXFELGNBQWMsS0FBS0MsV0FBVyxHQUFHO29CQUNuQyxJQUFJMEMseUJBQXlCLElBQUksQ0FBQ2YsMkJBQTJCLElBQ3pEZ0IsNEJBQTRCRCxzQkFBc0IsQ0FBQyxFQUFFLEVBQ3JERSwyQkFBMkJGLHNCQUFzQixDQUFDLEVBQUUsRUFDcERHLDJCQUEyQkgsc0JBQXNCLENBQUMsRUFBRSxFQUNwREksMEJBQTBCSixzQkFBc0IsQ0FBQyxFQUFFO29CQUV2RCxJQUFJSyx5QkFBeUIsSUFBSSxDQUFDaEIseUJBQXlCLElBQ3ZEaUIseUJBQXlCRCxzQkFBc0IsQ0FBQyxFQUFFLEVBQ2xERSx3QkFBd0JGLHNCQUFzQixDQUFDLEVBQUUsRUFDakRHLHdCQUF3Qkgsc0JBQXNCLENBQUMsRUFBRSxFQUNqREksdUJBQXVCSixzQkFBc0IsQ0FBQyxFQUFFO29CQUVwRCxJQUFJLENBQUM5RyxvQkFBb0IsQ0FBQzBHLDJCQUEyQkMsMEJBQTBCSSx3QkFBd0JDLHVCQUF1QkosMEJBQTBCQyx5QkFBeUJJLHVCQUF1QkM7Z0JBQzFNO1lBQ0Y7WUFFQSxJQUFJLE9BQU92RyxhQUFhLFlBQVk7Z0JBQ2xDLElBQUl3RyxlQUFlLElBQUksQ0FBQzVILEtBQUssRUFDekI2SCw2QkFBNkJELGFBQWF6SCx5QkFBeUIsRUFDbkUySCxjQUFjRixhQUFhbEssVUFBVSxFQUNyQ3FLLGFBQWFILGFBQWF2SCxTQUFTLEVBQ25DMkgsNEJBQTRCSixhQUFhckgsd0JBQXdCLEVBQ2pFMEgsMkJBQTJCTCxhQUFhcEgsdUJBQXVCO2dCQUVuRSxJQUFJLENBQUNXLGFBQWEsQ0FBQzJHLGFBQWFDLFlBQVlGLDRCQUE0QkksMEJBQTBCRDtZQUNwRztRQUNGLEVBQUUsdURBQXVEOztRQU16RGxFLE9BQU9xQywyQkFBMkIsR0FBRyxTQUFTQTtZQUM1QyxJQUFJK0IsZUFBZSxJQUFJLENBQUN2SSxLQUFLLEVBQ3pCNEUsY0FBYzJELGFBQWEzRCxXQUFXLEVBQ3RDNEQsc0JBQXNCRCxhQUFhQyxtQkFBbUIsRUFDdERDLHVCQUF1QkYsYUFBYUUsb0JBQW9CLEVBQ3hEQyxnQkFBZ0JILGFBQWFHLGFBQWEsRUFDMUM3RCxXQUFXMEQsYUFBYTFELFFBQVE7WUFDcEMsSUFBSThELGVBQWUsSUFBSSxDQUFDdEksS0FBSyxFQUN6QkcsNEJBQTRCbUksYUFBYW5JLHlCQUF5QixFQUNsRUQsY0FBY29JLGFBQWFwSSxXQUFXLEVBQ3RDeEMsYUFBYTRLLGFBQWE1SyxVQUFVO1lBQ3hDLElBQUk2Syx3QkFBd0JKLHVCQUF1QkMsd0JBQXdCQyxpQkFBaUI7WUFFNUYsSUFBSTlELGdCQUFnQixLQUFLQyxhQUFhLEdBQUc7Z0JBQ3ZDLE9BQU87b0JBQUM7b0JBQUc7b0JBQUc7b0JBQUc7aUJBQUU7WUFDckI7WUFFQSxJQUFJZ0UsYUFBYTdKLDZCQUE2QixJQUFJLENBQUNnQixLQUFLLEVBQUVqQyxZQUFZLElBQUksQ0FBQ21DLGNBQWM7WUFDekYsSUFBSTRJLFlBQVk3SixnQ0FBZ0MsSUFBSSxDQUFDZSxLQUFLLEVBQUU2SSxZQUFZOUssWUFBWSxJQUFJLENBQUNtQyxjQUFjLEdBQUcsa0VBQWtFO1lBQzVLLGlFQUFpRTtZQUVqRSxJQUFJNkksbUJBQW1CLENBQUN4SSxlQUFlQyw4QkFBOEIsYUFBYThDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHcUYseUJBQXlCO1lBQ3ZILElBQUlJLGtCQUFrQixDQUFDekksZUFBZUMsOEJBQThCLFlBQVk4QyxLQUFLQyxHQUFHLENBQUMsR0FBR3FGLHlCQUF5QjtZQUNySCxPQUFPO2dCQUFDdEYsS0FBS0MsR0FBRyxDQUFDLEdBQUdzRixhQUFhRTtnQkFBbUJ6RixLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDb0IsY0FBYyxHQUFHa0UsWUFBWUU7Z0JBQW1CSDtnQkFBWUM7YUFBVTtRQUNqSjtRQUVBM0UsT0FBT3lDLHlCQUF5QixHQUFHLFNBQVNBO1lBQzFDLElBQUlxQyxlQUFlLElBQUksQ0FBQ2pKLEtBQUssRUFDekI0RSxjQUFjcUUsYUFBYXJFLFdBQVcsRUFDdEM4RCxnQkFBZ0JPLGFBQWFQLGFBQWEsRUFDMUNRLG1CQUFtQkQsYUFBYUMsZ0JBQWdCLEVBQ2hEQyxvQkFBb0JGLGFBQWFFLGlCQUFpQixFQUNsRHRFLFdBQVdvRSxhQUFhcEUsUUFBUTtZQUNwQyxJQUFJdUUsZUFBZSxJQUFJLENBQUMvSSxLQUFLLEVBQ3pCRSxjQUFjNkksYUFBYTdJLFdBQVcsRUFDdENNLDBCQUEwQnVJLGFBQWF2SSx1QkFBdUIsRUFDOURILFlBQVkwSSxhQUFhMUksU0FBUztZQUN0QyxJQUFJa0ksd0JBQXdCTSxvQkFBb0JDLHFCQUFxQlQsaUJBQWlCO1lBRXRGLElBQUk5RCxnQkFBZ0IsS0FBS0MsYUFBYSxHQUFHO2dCQUN2QyxPQUFPO29CQUFDO29CQUFHO29CQUFHO29CQUFHO2lCQUFFO1lBQ3JCO1lBRUEsSUFBSWdFLGFBQWFwSiwwQkFBMEIsSUFBSSxDQUFDTyxLQUFLLEVBQUVVLFdBQVcsSUFBSSxDQUFDUixjQUFjO1lBQ3JGLElBQUk0SSxZQUFZcEosNkJBQTZCLElBQUksQ0FBQ00sS0FBSyxFQUFFNkksWUFBWW5JLFdBQVcsSUFBSSxDQUFDUixjQUFjLEdBQUcsa0VBQWtFO1lBQ3hLLGlFQUFpRTtZQUVqRSxJQUFJNkksbUJBQW1CLENBQUN4SSxlQUFlTSw0QkFBNEIsYUFBYXlDLEtBQUtDLEdBQUcsQ0FBQyxHQUFHcUYseUJBQXlCO1lBQ3JILElBQUlJLGtCQUFrQixDQUFDekksZUFBZU0sNEJBQTRCLFlBQVl5QyxLQUFLQyxHQUFHLENBQUMsR0FBR3FGLHlCQUF5QjtZQUNuSCxPQUFPO2dCQUFDdEYsS0FBS0MsR0FBRyxDQUFDLEdBQUdzRixhQUFhRTtnQkFBbUJ6RixLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDcUIsV0FBVyxHQUFHaUUsWUFBWUU7Z0JBQW1CSDtnQkFBWUM7YUFBVTtRQUM5STtRQUVBLE9BQU8vSTtJQUNULEVBQUV0RSxnREFBYUEsR0FBR3FELE9BQU91SyxZQUFZLEdBQUc7UUFDdEN6TCxXQUFXO1FBQ1hxSSxVQUFVM0Q7UUFDVmdFLGdCQUFnQjtJQUNsQixHQUFHeEg7QUFDTDtBQUVBLElBQUlvRixzQkFBc0IsU0FBU0Esb0JBQW9Cb0YsS0FBSyxFQUFFQyxLQUFLO0lBQ2pFLElBQUkzRCxXQUFXMEQsTUFBTTFELFFBQVEsRUFDekJoSSxZQUFZMEwsTUFBTTFMLFNBQVMsRUFDM0JYLFNBQVNxTSxNQUFNck0sTUFBTSxFQUNyQitJLGVBQWVzRCxNQUFNdEQsWUFBWSxFQUNqQ0ssZUFBZWlELE1BQU1qRCxZQUFZLEVBQ2pDb0MsdUJBQXVCYSxNQUFNYixvQkFBb0IsRUFDakRDLGdCQUFnQlksTUFBTVosYUFBYSxFQUNuQ1Msb0JBQW9CRyxNQUFNSCxpQkFBaUIsRUFDM0NuTSxRQUFRc00sTUFBTXRNLEtBQUs7SUFDdkIsSUFBSXNELFdBQVdpSixNQUFNakosUUFBUTtJQUU3QixJQUFJN0IsSUFBeUIsRUFBYztRQUN6QyxJQUFJLE9BQU9pSyxrQkFBa0IsVUFBVTtZQUNyQyxJQUFJcEssNEJBQTRCLENBQUNBLHlCQUF5QmtMLEdBQUcsQ0FBQ2xKLFdBQVc7Z0JBQ3ZFaEMseUJBQXlCbUwsR0FBRyxDQUFDbko7Z0JBQzdCb0osUUFBUUMsSUFBSSxDQUFDLGlEQUFpRDtZQUNoRTtRQUNGO1FBRUEsSUFBSSxPQUFPbEIseUJBQXlCLFlBQVksT0FBT1Usc0JBQXNCLFVBQVU7WUFDckYsSUFBSTVLLHVDQUF1QyxDQUFDQSxvQ0FBb0NpTCxHQUFHLENBQUNsSixXQUFXO2dCQUM3Ri9CLG9DQUFvQ2tMLEdBQUcsQ0FBQ25KO2dCQUN4Q29KLFFBQVFDLElBQUksQ0FBQyxnRkFBZ0Y7WUFDL0Y7UUFDRjtRQUVBLElBQUkzRCxnQkFBZ0IsUUFBUUssZ0JBQWdCLE1BQU07WUFDaEQsSUFBSTdILHNCQUFzQixDQUFDQSxtQkFBbUJnTCxHQUFHLENBQUNsSixXQUFXO2dCQUMzRDlCLG1CQUFtQmlMLEdBQUcsQ0FBQ25KO2dCQUN2Qm9KLFFBQVFDLElBQUksQ0FBQyxtRUFBbUU7WUFDbEY7UUFDRjtRQUVBLElBQUkvRCxZQUFZLE1BQU07WUFDcEIsTUFBTWdFLE1BQU0sb0RBQW9ELHdDQUF5QyxPQUFRaEUsQ0FBQUEsYUFBYSxPQUFPLFNBQVMsT0FBT0EsUUFBTyxJQUFLLGtCQUFrQjtRQUNyTDtRQUVBLE9BQVFoSTtZQUNOLEtBQUs7WUFDTCxLQUFLO2dCQUVIO1lBRUY7Z0JBQ0UsTUFBTWdNLE1BQU0scURBQXFELDRDQUE2QyxPQUFPaE0sWUFBWSxrQkFBa0I7UUFDdko7UUFFQSxJQUFJLE9BQU9aLFVBQVUsVUFBVTtZQUM3QixNQUFNNE0sTUFBTSxpREFBaUQsNENBQTZDLE9BQVE1TSxDQUFBQSxVQUFVLE9BQU8sU0FBUyxPQUFPQSxLQUFJLElBQUssa0JBQWtCO1FBQ2hMO1FBRUEsSUFBSSxPQUFPQyxXQUFXLFVBQVU7WUFDOUIsTUFBTTJNLE1BQU0sa0RBQWtELDZDQUE4QyxPQUFRM00sQ0FBQUEsV0FBVyxPQUFPLFNBQVMsT0FBT0EsTUFBSyxJQUFLLGtCQUFrQjtRQUNwTDtJQUNGO0FBQ0Y7QUFFQSxJQUFJNE0sOEJBQThCO0FBRWxDLElBQUkxSywwQkFBMEIsU0FBU0Esd0JBQXdCakIsSUFBSSxFQUFFVyxLQUFLO0lBQ3hFLElBQUlnRyxXQUFXM0csS0FBSzJHLFFBQVE7SUFDNUIsSUFBSWlGLGlCQUFpQmpMLE1BQU1pTCxjQUFjLEVBQ3JDQyxxQkFBcUJsTCxNQUFNa0wsa0JBQWtCLEVBQzdDQyx1QkFBdUJuTCxNQUFNbUwsb0JBQW9CO0lBQ3JELElBQUlDLDBCQUEwQixHQUFHLHdGQUF3RjtJQUN6SCxtREFBbUQ7SUFFbkQsSUFBSUQsd0JBQXdCbkYsVUFBVTtRQUNwQ21GLHVCQUF1Qm5GLFdBQVc7SUFDcEM7SUFFQSxJQUFJbUYsd0JBQXdCLEdBQUc7UUFDN0IsSUFBSUUsZUFBZUosY0FBYyxDQUFDRSxxQkFBcUI7UUFDdkRDLDBCQUEwQkMsYUFBYUMsTUFBTSxHQUFHRCxhQUFheE4sSUFBSTtJQUNuRTtJQUVBLElBQUkwTixxQkFBcUJ2RixXQUFXbUYsdUJBQXVCO0lBQzNELElBQUlLLDZCQUE2QkQscUJBQXFCTDtJQUN0RCxPQUFPRSwwQkFBMEJJO0FBQ25DO0FBRUEsSUFBSWpMLHlCQUF5QixTQUFTQSx1QkFBdUJrRixLQUFLLEVBQUVFLEtBQUs7SUFDdkUsSUFBSUksY0FBY04sTUFBTU0sV0FBVztJQUNuQyxJQUFJMEYsb0JBQW9COUYsTUFBTThGLGlCQUFpQixFQUMzQ0MsdUJBQXVCL0YsTUFBTStGLG9CQUFvQixFQUNqREMsMEJBQTBCaEcsTUFBTWdHLHVCQUF1QjtJQUMzRCxJQUFJUCwwQkFBMEIsR0FBRyx3RkFBd0Y7SUFDekgsbURBQW1EO0lBRW5ELElBQUlPLDJCQUEyQjVGLGFBQWE7UUFDMUM0RiwwQkFBMEI1RixjQUFjO0lBQzFDO0lBRUEsSUFBSTRGLDJCQUEyQixHQUFHO1FBQ2hDLElBQUlOLGVBQWVJLGlCQUFpQixDQUFDRSx3QkFBd0I7UUFDN0RQLDBCQUEwQkMsYUFBYUMsTUFBTSxHQUFHRCxhQUFheE4sSUFBSTtJQUNuRTtJQUVBLElBQUkwTixxQkFBcUJ4RixjQUFjNEYsMEJBQTBCO0lBQ2pFLElBQUlILDZCQUE2QkQscUJBQXFCRztJQUN0RCxPQUFPTiwwQkFBMEJJO0FBQ25DO0FBRUEsSUFBSUksa0JBQWtCLFNBQVNBLGdCQUFnQkMsUUFBUSxFQUFFMUssS0FBSyxFQUFFMkssS0FBSyxFQUFFQyxhQUFhO0lBQ2xGLElBQUlDLGlCQUFpQkMsVUFBVUM7SUFFL0IsSUFBSUwsYUFBYSxVQUFVO1FBQ3pCRyxrQkFBa0JELGNBQWNOLGlCQUFpQjtRQUNqRFEsV0FBVzlLLE1BQU00QixXQUFXO1FBQzVCbUosb0JBQW9CSCxjQUFjSix1QkFBdUI7SUFDM0QsT0FBTztRQUNMSyxrQkFBa0JELGNBQWNkLGNBQWM7UUFDOUNnQixXQUFXOUssTUFBTTZCLFNBQVM7UUFDMUJrSixvQkFBb0JILGNBQWNaLG9CQUFvQjtJQUN4RDtJQUVBLElBQUlXLFFBQVFJLG1CQUFtQjtRQUM3QixJQUFJWixTQUFTO1FBRWIsSUFBSVkscUJBQXFCLEdBQUc7WUFDMUIsSUFBSWIsZUFBZVcsZUFBZSxDQUFDRSxrQkFBa0I7WUFDckRaLFNBQVNELGFBQWFDLE1BQU0sR0FBR0QsYUFBYXhOLElBQUk7UUFDbEQ7UUFFQSxJQUFLLElBQUlzTyxJQUFJRCxvQkFBb0IsR0FBR0MsS0FBS0wsT0FBT0ssSUFBSztZQUNuRCxJQUFJdE8sT0FBT29PLFNBQVNFO1lBQ3BCSCxlQUFlLENBQUNHLEVBQUUsR0FBRztnQkFDbkJiLFFBQVFBO2dCQUNSek4sTUFBTUE7WUFDUjtZQUNBeU4sVUFBVXpOO1FBQ1o7UUFFQSxJQUFJZ08sYUFBYSxVQUFVO1lBQ3pCRSxjQUFjSix1QkFBdUIsR0FBR0c7UUFDMUMsT0FBTztZQUNMQyxjQUFjWixvQkFBb0IsR0FBR1c7UUFDdkM7SUFDRjtJQUVBLE9BQU9FLGVBQWUsQ0FBQ0YsTUFBTTtBQUMvQjtBQUVBLElBQUlNLGtCQUFrQixTQUFTQSxnQkFBZ0JQLFFBQVEsRUFBRTFLLEtBQUssRUFBRTRLLGFBQWEsRUFBRVQsTUFBTTtJQUNuRixJQUFJVSxpQkFBaUJFO0lBRXJCLElBQUlMLGFBQWEsVUFBVTtRQUN6Qkcsa0JBQWtCRCxjQUFjTixpQkFBaUI7UUFDakRTLG9CQUFvQkgsY0FBY0osdUJBQXVCO0lBQzNELE9BQU87UUFDTEssa0JBQWtCRCxjQUFjZCxjQUFjO1FBQzlDaUIsb0JBQW9CSCxjQUFjWixvQkFBb0I7SUFDeEQ7SUFFQSxJQUFJa0IseUJBQXlCSCxvQkFBb0IsSUFBSUYsZUFBZSxDQUFDRSxrQkFBa0IsQ0FBQ1osTUFBTSxHQUFHO0lBRWpHLElBQUllLDBCQUEwQmYsUUFBUTtRQUNwQyw2RkFBNkY7UUFDN0YsT0FBT2dCLDRCQUE0QlQsVUFBVTFLLE9BQU80SyxlQUFlRyxtQkFBbUIsR0FBR1o7SUFDM0YsT0FBTztRQUNMLHVHQUF1RztRQUN2Ryx3R0FBd0c7UUFDeEcsd0RBQXdEO1FBQ3hELE9BQU9pQixpQ0FBaUNWLFVBQVUxSyxPQUFPNEssZUFBZXRILEtBQUtDLEdBQUcsQ0FBQyxHQUFHd0gsb0JBQW9CWjtJQUMxRztBQUNGO0FBRUEsSUFBSWdCLDhCQUE4QixTQUFTQSw0QkFBNEJULFFBQVEsRUFBRTFLLEtBQUssRUFBRTRLLGFBQWEsRUFBRVMsSUFBSSxFQUFFQyxHQUFHLEVBQUVuQixNQUFNO0lBQ3RILE1BQU9tQixPQUFPRCxLQUFNO1FBQ2xCLElBQUlFLFNBQVNELE1BQU1oSSxLQUFLa0ksS0FBSyxDQUFDLENBQUNILE9BQU9DLEdBQUUsSUFBSztRQUM3QyxJQUFJRyxnQkFBZ0JoQixnQkFBZ0JDLFVBQVUxSyxPQUFPdUwsUUFBUVgsZUFBZVQsTUFBTTtRQUVsRixJQUFJc0Isa0JBQWtCdEIsUUFBUTtZQUM1QixPQUFPb0I7UUFDVCxPQUFPLElBQUlFLGdCQUFnQnRCLFFBQVE7WUFDakNtQixNQUFNQyxTQUFTO1FBQ2pCLE9BQU8sSUFBSUUsZ0JBQWdCdEIsUUFBUTtZQUNqQ2tCLE9BQU9FLFNBQVM7UUFDbEI7SUFDRjtJQUVBLElBQUlELE1BQU0sR0FBRztRQUNYLE9BQU9BLE1BQU07SUFDZixPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFFQSxJQUFJRixtQ0FBbUMsU0FBU0EsaUNBQWlDVixRQUFRLEVBQUUxSyxLQUFLLEVBQUU0SyxhQUFhLEVBQUVELEtBQUssRUFBRVIsTUFBTTtJQUM1SCxJQUFJdUIsWUFBWWhCLGFBQWEsV0FBVzFLLE1BQU00RSxXQUFXLEdBQUc1RSxNQUFNNkUsUUFBUTtJQUMxRSxJQUFJOEcsV0FBVztJQUVmLE1BQU9oQixRQUFRZSxhQUFhakIsZ0JBQWdCQyxVQUFVMUssT0FBTzJLLE9BQU9DLGVBQWVULE1BQU0sR0FBR0EsT0FBUTtRQUNsR1EsU0FBU2dCO1FBQ1RBLFlBQVk7SUFDZDtJQUVBLE9BQU9SLDRCQUE0QlQsVUFBVTFLLE9BQU80SyxlQUFldEgsS0FBS0UsR0FBRyxDQUFDbUgsT0FBT2UsWUFBWSxJQUFJcEksS0FBS2tJLEtBQUssQ0FBQ2IsUUFBUSxJQUFJUjtBQUM1SDtBQUVBLElBQUl5QixnQ0FBZ0MsU0FBU0EsOEJBQThCbEIsUUFBUSxFQUFFMUssS0FBSyxFQUFFMkssS0FBSyxFQUFFakcsS0FBSyxFQUFFbUgsWUFBWSxFQUFFakIsYUFBYSxFQUFFN0YsYUFBYTtJQUNsSixJQUFJckksT0FBT2dPLGFBQWEsV0FBVzFLLE1BQU1oRCxLQUFLLEdBQUdnRCxNQUFNL0MsTUFBTTtJQUM3RCxJQUFJaU4sZUFBZU8sZ0JBQWdCQyxVQUFVMUssT0FBTzJLLE9BQU9DLGdCQUFnQiwyREFBMkQ7SUFDdEksdUVBQXVFO0lBRXZFLElBQUlrQixxQkFBcUJwQixhQUFhLFdBQVd0TCx1QkFBdUJZLE9BQU80SyxpQkFBaUJ6TCx3QkFBd0JhLE9BQU80SztJQUMvSCxJQUFJbUIsWUFBWXpJLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUNzSSxxQkFBcUJwUCxNQUFNd04sYUFBYUMsTUFBTTtJQUNuRixJQUFJNkIsWUFBWTFJLEtBQUtDLEdBQUcsQ0FBQyxHQUFHMkcsYUFBYUMsTUFBTSxHQUFHek4sT0FBT3FJLGdCQUFnQm1GLGFBQWF4TixJQUFJO0lBRTFGLElBQUlnSSxVQUFVLFNBQVM7UUFDckIsSUFBSW1ILGdCQUFnQkcsWUFBWXRQLFFBQVFtUCxnQkFBZ0JFLFlBQVlyUCxNQUFNO1lBQ3hFZ0ksUUFBUTtRQUNWLE9BQU87WUFDTEEsUUFBUTtRQUNWO0lBQ0Y7SUFFQSxPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPcUg7UUFFVCxLQUFLO1lBQ0gsT0FBT0M7UUFFVCxLQUFLO1lBQ0gsT0FBTzFJLEtBQUsySSxLQUFLLENBQUNELFlBQVksQ0FBQ0QsWUFBWUMsU0FBUSxJQUFLO1FBRTFELEtBQUs7UUFDTDtZQUNFLElBQUlILGdCQUFnQkcsYUFBYUgsZ0JBQWdCRSxXQUFXO2dCQUMxRCxPQUFPRjtZQUNULE9BQU8sSUFBSUcsWUFBWUQsV0FBVztnQkFDaEMsa0ZBQWtGO2dCQUNsRixzRUFBc0U7Z0JBQ3RFLE9BQU9DO1lBQ1QsT0FBTyxJQUFJSCxlQUFlRyxXQUFXO2dCQUNuQyxPQUFPQTtZQUNULE9BQU87Z0JBQ0wsT0FBT0Q7WUFDVDtJQUVKO0FBQ0Y7QUFFQSxJQUFJRyxtQkFBbUIsV0FBVyxHQUFFdE4sb0JBQW9CO0lBQ3RERyxpQkFBaUIsU0FBU0EsZ0JBQWdCaUIsS0FBSyxFQUFFMkssS0FBSyxFQUFFQyxhQUFhO1FBQ25FLE9BQU9ILGdCQUFnQixVQUFVekssT0FBTzJLLE9BQU9DLGVBQWVULE1BQU07SUFDdEU7SUFDQW5MLDhCQUE4QixTQUFTQSw2QkFBNkJnQixLQUFLLEVBQUVqQyxVQUFVLEVBQUU2TSxhQUFhO1FBQ2xHLE9BQU9LLGdCQUFnQixVQUFVakwsT0FBTzRLLGVBQWU3TTtJQUN6RDtJQUNBa0IsaUNBQWlDLFNBQVNBLGdDQUFnQ2UsS0FBSyxFQUFFNkksVUFBVSxFQUFFOUssVUFBVSxFQUFFNk0sYUFBYTtRQUNwSCxJQUFJaEcsY0FBYzVFLE1BQU00RSxXQUFXLEVBQy9CNUgsUUFBUWdELE1BQU1oRCxLQUFLO1FBQ3ZCLElBQUlrTixlQUFlTyxnQkFBZ0IsVUFBVXpLLE9BQU82SSxZQUFZK0I7UUFDaEUsSUFBSW1CLFlBQVloTyxhQUFhZjtRQUM3QixJQUFJbU4sU0FBU0QsYUFBYUMsTUFBTSxHQUFHRCxhQUFheE4sSUFBSTtRQUNwRCxJQUFJb00sWUFBWUQ7UUFFaEIsTUFBT0MsWUFBWWxFLGNBQWMsS0FBS3VGLFNBQVM0QixVQUFXO1lBQ3hEakQ7WUFDQXFCLFVBQVVNLGdCQUFnQixVQUFVekssT0FBTzhJLFdBQVc4QixlQUFlbE8sSUFBSTtRQUMzRTtRQUVBLE9BQU9vTTtJQUNUO0lBQ0E1SixnQkFBZ0IsU0FBU0EsZUFBZWMsS0FBSyxFQUFFMkssS0FBSyxFQUFFQyxhQUFhO1FBQ2pFLE9BQU9BLGNBQWNOLGlCQUFpQixDQUFDSyxNQUFNLENBQUNqTyxJQUFJO0lBQ3BEO0lBQ0F5Qyx5QkFBeUJBO0lBQ3pCQyx3QkFBd0JBO0lBQ3hCQyxnQ0FBZ0MsU0FBU0EsK0JBQStCVyxLQUFLLEVBQUUySyxLQUFLLEVBQUVqRyxLQUFLLEVBQUVtSCxZQUFZLEVBQUVqQixhQUFhLEVBQUU3RixhQUFhO1FBQ3JJLE9BQU82Ryw4QkFBOEIsVUFBVTVMLE9BQU8ySyxPQUFPakcsT0FBT21ILGNBQWNqQixlQUFlN0Y7SUFDbkc7SUFDQXpGLDZCQUE2QixTQUFTQSw0QkFBNEJVLEtBQUssRUFBRTJLLEtBQUssRUFBRWpHLEtBQUssRUFBRW1ILFlBQVksRUFBRWpCLGFBQWEsRUFBRTdGLGFBQWE7UUFDL0gsT0FBTzZHLDhCQUE4QixPQUFPNUwsT0FBTzJLLE9BQU9qRyxPQUFPbUgsY0FBY2pCLGVBQWU3RjtJQUNoRztJQUNBdkYsY0FBYyxTQUFTQSxhQUFhUSxLQUFLLEVBQUUySyxLQUFLLEVBQUVDLGFBQWE7UUFDN0QsT0FBT0gsZ0JBQWdCLE9BQU96SyxPQUFPMkssT0FBT0MsZUFBZVQsTUFBTTtJQUNuRTtJQUNBNUssY0FBYyxTQUFTQSxhQUFhUyxLQUFLLEVBQUUySyxLQUFLLEVBQUVDLGFBQWE7UUFDN0QsT0FBT0EsY0FBY2QsY0FBYyxDQUFDYSxNQUFNLENBQUNqTyxJQUFJO0lBQ2pEO0lBQ0ErQywyQkFBMkIsU0FBU0EsMEJBQTBCTyxLQUFLLEVBQUVVLFNBQVMsRUFBRWtLLGFBQWE7UUFDM0YsT0FBT0ssZ0JBQWdCLE9BQU9qTCxPQUFPNEssZUFBZWxLO0lBQ3REO0lBQ0FoQiw4QkFBOEIsU0FBU0EsNkJBQTZCTSxLQUFLLEVBQUU2SSxVQUFVLEVBQUVuSSxTQUFTLEVBQUVrSyxhQUFhO1FBQzdHLElBQUkvRixXQUFXN0UsTUFBTTZFLFFBQVEsRUFDekI1SCxTQUFTK0MsTUFBTS9DLE1BQU07UUFDekIsSUFBSWlOLGVBQWVPLGdCQUFnQixPQUFPekssT0FBTzZJLFlBQVkrQjtRQUM3RCxJQUFJbUIsWUFBWXJMLFlBQVl6RDtRQUM1QixJQUFJa04sU0FBU0QsYUFBYUMsTUFBTSxHQUFHRCxhQUFheE4sSUFBSTtRQUNwRCxJQUFJb00sWUFBWUQ7UUFFaEIsTUFBT0MsWUFBWWpFLFdBQVcsS0FBS3NGLFNBQVM0QixVQUFXO1lBQ3JEakQ7WUFDQXFCLFVBQVVNLGdCQUFnQixPQUFPekssT0FBTzhJLFdBQVc4QixlQUFlbE8sSUFBSTtRQUN4RTtRQUVBLE9BQU9vTTtJQUNUO0lBQ0FuSixtQkFBbUIsU0FBU0Esa0JBQWtCSyxLQUFLLEVBQUVNLFFBQVE7UUFDM0QsSUFBSWdKLFFBQVF0SixPQUNSdUssdUJBQXVCakIsTUFBTWlCLG9CQUFvQixFQUNqRFIscUJBQXFCVCxNQUFNUyxrQkFBa0I7UUFDakQsSUFBSWEsZ0JBQWdCO1lBQ2xCTixtQkFBbUIsQ0FBQztZQUNwQkMsc0JBQXNCQSx3QkFBd0JWO1lBQzlDRSxvQkFBb0JBLHNCQUFzQkY7WUFDMUNXLHlCQUF5QixDQUFDO1lBQzFCUixzQkFBc0IsQ0FBQztZQUN2QkYsZ0JBQWdCLENBQUM7UUFDbkI7UUFFQXhKLFNBQVM2TCxxQkFBcUIsR0FBRyxTQUFVaE8sV0FBVyxFQUFFaU8saUJBQWlCO1lBQ3ZFLElBQUlBLHNCQUFzQixLQUFLLEdBQUc7Z0JBQ2hDQSxvQkFBb0I7WUFDdEI7WUFFQTlMLFNBQVMrTCxpQkFBaUIsQ0FBQztnQkFDekJsTyxhQUFhQTtnQkFDYmlPLG1CQUFtQkE7WUFDckI7UUFDRjtRQUVBOUwsU0FBU2dNLGtCQUFrQixHQUFHLFNBQVVqTyxRQUFRLEVBQUUrTixpQkFBaUI7WUFDakUsSUFBSUEsc0JBQXNCLEtBQUssR0FBRztnQkFDaENBLG9CQUFvQjtZQUN0QjtZQUVBOUwsU0FBUytMLGlCQUFpQixDQUFDO2dCQUN6QmhPLFVBQVVBO2dCQUNWK04sbUJBQW1CQTtZQUNyQjtRQUNGO1FBRUE5TCxTQUFTK0wsaUJBQWlCLEdBQUcsU0FBVTlDLEtBQUs7WUFDMUMsSUFBSXBMLGNBQWNvTCxNQUFNcEwsV0FBVyxFQUMvQkUsV0FBV2tMLE1BQU1sTCxRQUFRLEVBQ3pCa08sd0JBQXdCaEQsTUFBTTZDLGlCQUFpQixFQUMvQ0Esb0JBQW9CRywwQkFBMEIsS0FBSyxJQUFJLE9BQU9BO1lBRWxFLElBQUksT0FBT3BPLGdCQUFnQixVQUFVO2dCQUNuQ3lNLGNBQWNKLHVCQUF1QixHQUFHbEgsS0FBS0UsR0FBRyxDQUFDb0gsY0FBY0osdUJBQXVCLEVBQUVyTSxjQUFjO1lBQ3hHO1lBRUEsSUFBSSxPQUFPRSxhQUFhLFVBQVU7Z0JBQ2hDdU0sY0FBY1osb0JBQW9CLEdBQUcxRyxLQUFLRSxHQUFHLENBQUNvSCxjQUFjWixvQkFBb0IsRUFBRTNMLFdBQVc7WUFDL0YsRUFBRSxrRkFBa0Y7WUFDcEYsbUVBQW1FO1lBQ25FLHdDQUF3QztZQUN4QyxpRkFBaUY7WUFHakZpQyxTQUFTeUIsa0JBQWtCLENBQUMsQ0FBQztZQUU3QixJQUFJcUssbUJBQW1CO2dCQUNyQjlMLFNBQVNrTSxXQUFXO1lBQ3RCO1FBQ0Y7UUFFQSxPQUFPNUI7SUFDVDtJQUNBaEwsdUNBQXVDO0lBQ3ZDQyxlQUFlLFNBQVNBLGNBQWM0TSxLQUFLO1FBQ3pDLElBQUk3SyxjQUFjNkssTUFBTTdLLFdBQVcsRUFDL0JDLFlBQVk0SyxNQUFNNUssU0FBUztRQUUvQixJQUFJcEQsSUFBeUIsRUFBYztZQUN6QyxJQUFJLE9BQU9tRCxnQkFBZ0IsWUFBWTtnQkFDckMsTUFBTWdJLE1BQU0sdURBQXVELGlDQUFrQyxPQUFRaEksQ0FBQUEsZ0JBQWdCLE9BQU8sU0FBUyxPQUFPQSxXQUFVLElBQUssa0JBQWtCO1lBQ3ZMLE9BQU8sSUFBSSxPQUFPQyxjQUFjLFlBQVk7Z0JBQzFDLE1BQU0rSCxNQUFNLHFEQUFxRCxpQ0FBa0MsT0FBUS9ILENBQUFBLGNBQWMsT0FBTyxTQUFTLE9BQU9BLFNBQVEsSUFBSyxrQkFBa0I7WUFDakw7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxJQUFJNkssbUNBQW1DO0FBRXZDLElBQUlDLG1CQUFtQixTQUFTMU8sZUFBZTBNLEtBQUssRUFBRXZNLElBQUk7SUFDeEQsT0FBT3VNO0FBQ1QsR0FBRyxpRkFBaUY7QUFDcEYsZ0VBQWdFO0FBR2hFLElBQUlpQyx1QkFBdUI7QUFDM0IsSUFBSUMsdUJBQXVCO0FBRTNCLElBQUlwTyxJQUF5QixFQUFjO0lBQ3pDLElBQUksS0FBMkQsRUFBYSxFQUczRTtBQUNIO0FBRUEsU0FBU3FPLG9CQUFvQjVPLElBQUk7SUFDL0IsSUFBSVk7SUFFSixJQUFJaU8sZ0JBQWdCN08sS0FBSzZPLGFBQWEsRUFDbENDLHdCQUF3QjlPLEtBQUs4TyxxQkFBcUIsRUFDbERDLGNBQWMvTyxLQUFLK08sV0FBVyxFQUM5QnJCLGdDQUFnQzFOLEtBQUswTiw2QkFBNkIsRUFDbEVzQix5QkFBeUJoUCxLQUFLZ1Asc0JBQXNCLEVBQ3BEQyw0QkFBNEJqUCxLQUFLaVAseUJBQXlCLEVBQzFEeE4sb0JBQW9CekIsS0FBS3lCLGlCQUFpQixFQUMxQ0Msd0NBQXdDMUIsS0FBSzBCLHFDQUFxQyxFQUNsRkMsZ0JBQWdCM0IsS0FBSzJCLGFBQWE7SUFDdEMsT0FBT2YsU0FBUyxXQUFXLEdBQUUsU0FBVWdCLGNBQWM7UUFDbkR4RSxvRkFBY0EsQ0FBQzhSLE1BQU10TjtRQUVyQix3REFBd0Q7UUFDeEQsbURBQW1EO1FBQ25ELGtEQUFrRDtRQUNsRCxTQUFTc04sS0FBS3BOLEtBQUs7WUFDakIsSUFBSUM7WUFFSkEsUUFBUUgsZUFBZXRELElBQUksQ0FBQyxJQUFJLEVBQUV3RCxVQUFVLElBQUk7WUFDaERDLE1BQU1DLGNBQWMsR0FBR1Asa0JBQWtCTSxNQUFNRCxLQUFLLEVBQUUzRSw0RkFBc0JBLENBQUM0RTtZQUM3RUEsTUFBTUcsU0FBUyxHQUFHLEtBQUs7WUFDdkJILE1BQU1FLDBCQUEwQixHQUFHO1lBQ25DRixNQUFNSSxLQUFLLEdBQUc7Z0JBQ1pDLFVBQVVqRiw0RkFBc0JBLENBQUM0RTtnQkFDakNNLGFBQWE7Z0JBQ2I4TSxpQkFBaUI7Z0JBQ2pCeEIsY0FBYyxPQUFPNUwsTUFBTUQsS0FBSyxDQUFDc04sbUJBQW1CLEtBQUssV0FBV3JOLE1BQU1ELEtBQUssQ0FBQ3NOLG1CQUFtQixHQUFHO2dCQUN0RzFNLDBCQUEwQjtZQUM1QjtZQUNBWCxNQUFNYSxvQkFBb0IsR0FBRyxLQUFLO1lBQ2xDYixNQUFNYSxvQkFBb0IsR0FBR3ZGLHVEQUFVQSxDQUFDLFNBQVVnUyxrQkFBa0IsRUFBRUMsaUJBQWlCLEVBQUVDLGlCQUFpQixFQUFFQyxnQkFBZ0I7Z0JBQzFILE9BQU96TixNQUFNRCxLQUFLLENBQUN1QixlQUFlLENBQUM7b0JBQ2pDZ00sb0JBQW9CQTtvQkFDcEJDLG1CQUFtQkE7b0JBQ25CQyxtQkFBbUJBO29CQUNuQkMsa0JBQWtCQTtnQkFDcEI7WUFDRjtZQUNBek4sTUFBTXVCLGFBQWEsR0FBRyxLQUFLO1lBQzNCdkIsTUFBTXVCLGFBQWEsR0FBR2pHLHVEQUFVQSxDQUFDLFNBQVU4UixlQUFlLEVBQUV4QixZQUFZLEVBQUVqTCx3QkFBd0I7Z0JBQ2hHLE9BQU9YLE1BQU1ELEtBQUssQ0FBQ3lCLFFBQVEsQ0FBQztvQkFDMUI0TCxpQkFBaUJBO29CQUNqQnhCLGNBQWNBO29CQUNkakwsMEJBQTBCQTtnQkFDNUI7WUFDRjtZQUNBWCxNQUFNeUIsYUFBYSxHQUFHLEtBQUs7WUFFM0J6QixNQUFNeUIsYUFBYSxHQUFHLFNBQVVpSixLQUFLO2dCQUNuQyxJQUFJaEosY0FBYzFCLE1BQU1ELEtBQUssRUFDekJwQyxZQUFZK0QsWUFBWS9ELFNBQVMsRUFDakNrTixXQUFXbkosWUFBWW1KLFFBQVEsRUFDL0I2QyxTQUFTaE0sWUFBWWdNLE1BQU07Z0JBRS9CLElBQUk3TCxpQkFBaUI3QixNQUFNOEIsa0JBQWtCLENBQUNuQyx5Q0FBeUNrTCxVQUFVbEwseUNBQXlDK04sUUFBUS9OLHlDQUF5Q2hDO2dCQUUzTCxJQUFJYjtnQkFFSixJQUFJK0UsZUFBZUcsY0FBYyxDQUFDMEksUUFBUTtvQkFDeEM1TixRQUFRK0UsY0FBYyxDQUFDNkksTUFBTTtnQkFDL0IsT0FBTztvQkFDTCxJQUFJekksVUFBVTZLLGNBQWM5TSxNQUFNRCxLQUFLLEVBQUUySyxPQUFPMUssTUFBTUMsY0FBYztvQkFFcEUsSUFBSXhELE9BQU91USxZQUFZaE4sTUFBTUQsS0FBSyxFQUFFMkssT0FBTzFLLE1BQU1DLGNBQWMsR0FBRyx3Q0FBd0M7b0JBRTFHLElBQUkwTixlQUFlaFEsY0FBYyxnQkFBZ0IrUCxXQUFXO29CQUM1RCxJQUFJeEwsUUFBUXZFLGNBQWM7b0JBQzFCLElBQUlpUSxtQkFBbUJELGVBQWUxTCxVQUFVO29CQUNoREosY0FBYyxDQUFDNkksTUFBTSxHQUFHNU4sUUFBUTt3QkFDOUJxRixVQUFVO3dCQUNWQyxNQUFNRixRQUFRRyxZQUFZdUw7d0JBQzFCdEwsT0FBT0osUUFBUTBMLG1CQUFtQnZMO3dCQUNsQ0UsS0FBSyxDQUFDb0wsZUFBZTFMLFVBQVU7d0JBQy9CakYsUUFBUSxDQUFDMlEsZUFBZWxSLE9BQU87d0JBQy9CTSxPQUFPNFEsZUFBZWxSLE9BQU87b0JBQy9CO2dCQUNGO2dCQUVBLE9BQU9LO1lBQ1Q7WUFFQWtELE1BQU04QixrQkFBa0IsR0FBRyxLQUFLO1lBQ2hDOUIsTUFBTThCLGtCQUFrQixHQUFHeEcsdURBQVVBLENBQUMsU0FBVWtILENBQUMsRUFBRUMsRUFBRSxFQUFFQyxHQUFHO2dCQUN4RCxPQUFPLENBQUM7WUFDVjtZQUVBMUMsTUFBTTZOLG1CQUFtQixHQUFHLFNBQVVqTCxLQUFLO2dCQUN6QyxJQUFJQyx1QkFBdUJELE1BQU1FLGFBQWEsRUFDMUN6RixjQUFjd0YscUJBQXFCeEYsV0FBVyxFQUM5Q1MsYUFBYStFLHFCQUFxQi9FLFVBQVUsRUFDNUNtRixjQUFjSixxQkFBcUJJLFdBQVc7Z0JBRWxEakQsTUFBTWtELFFBQVEsQ0FBQyxTQUFVQyxTQUFTO29CQUNoQyxJQUFJQSxVQUFVeUksWUFBWSxLQUFLOU4sWUFBWTt3QkFDekMsb0RBQW9EO3dCQUNwRCx5REFBeUQ7d0JBQ3pELGlEQUFpRDt3QkFDakQsT0FBTztvQkFDVDtvQkFFQSxJQUFJSCxZQUFZcUMsTUFBTUQsS0FBSyxDQUFDcEMsU0FBUztvQkFDckMsSUFBSWlPLGVBQWU5TjtvQkFFbkIsSUFBSUgsY0FBYyxPQUFPO3dCQUN2Qix3RkFBd0Y7d0JBQ3hGLHdIQUF3SDt3QkFDeEgsNEdBQTRHO3dCQUM1RywrR0FBK0c7d0JBQy9HLE9BQVFIOzRCQUNOLEtBQUs7Z0NBQ0hvTyxlQUFlLENBQUM5TjtnQ0FDaEI7NEJBRUYsS0FBSztnQ0FDSDhOLGVBQWUzSSxjQUFjNUYsY0FBY1M7Z0NBQzNDO3dCQUNKO29CQUNGLEVBQUUsNkZBQTZGO29CQUcvRjhOLGVBQWV2SSxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDcUksY0FBYzNJLGNBQWM1RjtvQkFDaEUsT0FBTzt3QkFDTGlELGFBQWE7d0JBQ2I4TSxpQkFBaUJqSyxVQUFVeUksWUFBWSxHQUFHQSxlQUFlLFlBQVk7d0JBQ3JFQSxjQUFjQTt3QkFDZGpMLDBCQUEwQjtvQkFDNUI7Z0JBQ0YsR0FBR1gsTUFBTXlELDBCQUEwQjtZQUNyQztZQUVBekQsTUFBTThOLGlCQUFpQixHQUFHLFNBQVVsTCxLQUFLO2dCQUN2QyxJQUFJbUwsd0JBQXdCbkwsTUFBTUUsYUFBYSxFQUMzQ0MsZUFBZWdMLHNCQUFzQmhMLFlBQVksRUFDakRDLGVBQWUrSyxzQkFBc0IvSyxZQUFZLEVBQ2pEdkMsWUFBWXNOLHNCQUFzQnROLFNBQVM7Z0JBRS9DVCxNQUFNa0QsUUFBUSxDQUFDLFNBQVVDLFNBQVM7b0JBQ2hDLElBQUlBLFVBQVV5SSxZQUFZLEtBQUtuTCxXQUFXO3dCQUN4QyxvREFBb0Q7d0JBQ3BELHlEQUF5RDt3QkFDekQsaURBQWlEO3dCQUNqRCxPQUFPO29CQUNULEVBQUUsNkZBQTZGO29CQUcvRixJQUFJbUwsZUFBZXZJLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUM5QyxXQUFXdUMsZUFBZUQ7b0JBQ2xFLE9BQU87d0JBQ0x6QyxhQUFhO3dCQUNiOE0saUJBQWlCakssVUFBVXlJLFlBQVksR0FBR0EsZUFBZSxZQUFZO3dCQUNyRUEsY0FBY0E7d0JBQ2RqTCwwQkFBMEI7b0JBQzVCO2dCQUNGLEdBQUdYLE1BQU15RCwwQkFBMEI7WUFDckM7WUFFQXpELE1BQU0wRCxlQUFlLEdBQUcsU0FBVUMsR0FBRztnQkFDbkMsSUFBSUMsV0FBVzVELE1BQU1ELEtBQUssQ0FBQzZELFFBQVE7Z0JBQ25DNUQsTUFBTUcsU0FBUyxHQUFHd0Q7Z0JBRWxCLElBQUksT0FBT0MsYUFBYSxZQUFZO29CQUNsQ0EsU0FBU0Q7Z0JBQ1gsT0FBTyxJQUFJQyxZQUFZLFFBQVEsT0FBT0EsYUFBYSxZQUFZQSxTQUFTNUIsY0FBYyxDQUFDLFlBQVk7b0JBQ2pHNEIsU0FBU0MsT0FBTyxHQUFHRjtnQkFDckI7WUFDRjtZQUVBM0QsTUFBTXlELDBCQUEwQixHQUFHO2dCQUNqQyxJQUFJekQsTUFBTUUsMEJBQTBCLEtBQUssTUFBTTtvQkFDN0NwRSxjQUFja0UsTUFBTUUsMEJBQTBCO2dCQUNoRDtnQkFFQUYsTUFBTUUsMEJBQTBCLEdBQUdoRSxlQUFlOEQsTUFBTThELGlCQUFpQixFQUFFMkk7WUFDN0U7WUFFQXpNLE1BQU04RCxpQkFBaUIsR0FBRztnQkFDeEI5RCxNQUFNRSwwQkFBMEIsR0FBRztnQkFFbkNGLE1BQU1rRCxRQUFRLENBQUM7b0JBQ2I1QyxhQUFhO2dCQUNmLEdBQUc7b0JBQ0QsMkRBQTJEO29CQUMzRCwrRUFBK0U7b0JBQy9FTixNQUFNOEIsa0JBQWtCLENBQUMsQ0FBQyxHQUFHO2dCQUMvQjtZQUNGO1lBRUEsT0FBTzlCO1FBQ1Q7UUFFQW1OLEtBQUtwSix3QkFBd0IsR0FBRyxTQUFTQSx5QkFBeUJDLFNBQVMsRUFBRWIsU0FBUztZQUNwRjZLLHNCQUFzQmhLLFdBQVdiO1lBQ2pDdkQsY0FBY29FO1lBQ2QsT0FBTztRQUNUO1FBRUEsSUFBSUUsU0FBU2lKLEtBQUtoSixTQUFTO1FBRTNCRCxPQUFPRSxRQUFRLEdBQUcsU0FBU0EsU0FBU3dILFlBQVk7WUFDOUNBLGVBQWV2SSxLQUFLQyxHQUFHLENBQUMsR0FBR3NJO1lBQzNCLElBQUksQ0FBQzFJLFFBQVEsQ0FBQyxTQUFVQyxTQUFTO2dCQUMvQixJQUFJQSxVQUFVeUksWUFBWSxLQUFLQSxjQUFjO29CQUMzQyxPQUFPO2dCQUNUO2dCQUVBLE9BQU87b0JBQ0x3QixpQkFBaUJqSyxVQUFVeUksWUFBWSxHQUFHQSxlQUFlLFlBQVk7b0JBQ3JFQSxjQUFjQTtvQkFDZGpMLDBCQUEwQjtnQkFDNUI7WUFDRixHQUFHLElBQUksQ0FBQzhDLDBCQUEwQjtRQUNwQztRQUVBUyxPQUFPSSxZQUFZLEdBQUcsU0FBU0EsYUFBYW9HLEtBQUssRUFBRWpHLEtBQUs7WUFDdEQsSUFBSUEsVUFBVSxLQUFLLEdBQUc7Z0JBQ3BCQSxRQUFRO1lBQ1Y7WUFFQSxJQUFJQyxlQUFlLElBQUksQ0FBQzNFLEtBQUssRUFDekIwTCxZQUFZL0csYUFBYStHLFNBQVMsRUFDbENpQyxTQUFTaEosYUFBYWdKLE1BQU07WUFDaEMsSUFBSTlCLGVBQWUsSUFBSSxDQUFDeEwsS0FBSyxDQUFDd0wsWUFBWTtZQUMxQ2xCLFFBQVFySCxLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDbUgsT0FBT2UsWUFBWSxLQUFLLDBHQUEwRztZQUMvSix1RUFBdUU7WUFDdkUsdUZBQXVGO1lBRXZGLElBQUkzRyxnQkFBZ0I7WUFFcEIsSUFBSSxJQUFJLENBQUMzRSxTQUFTLEVBQUU7Z0JBQ2xCLElBQUl5RCxXQUFXLElBQUksQ0FBQ3pELFNBQVM7Z0JBRTdCLElBQUl1TixXQUFXLFlBQVk7b0JBQ3pCNUksZ0JBQWdCbEIsU0FBU1gsV0FBVyxHQUFHVyxTQUFTdkcsV0FBVyxHQUFHWCxxQkFBcUI7Z0JBQ3JGLE9BQU87b0JBQ0xvSSxnQkFBZ0JsQixTQUFTWixZQUFZLEdBQUdZLFNBQVNiLFlBQVksR0FBR3JHLHFCQUFxQjtnQkFDdkY7WUFDRjtZQUVBLElBQUksQ0FBQzBILFFBQVEsQ0FBQ3VILDhCQUE4QixJQUFJLENBQUM1TCxLQUFLLEVBQUUySyxPQUFPakcsT0FBT21ILGNBQWMsSUFBSSxDQUFDM0wsY0FBYyxFQUFFNkU7UUFDM0c7UUFFQVosT0FBT2lCLGlCQUFpQixHQUFHLFNBQVNBO1lBQ2xDLElBQUlDLGVBQWUsSUFBSSxDQUFDckYsS0FBSyxFQUN6QnBDLFlBQVl5SCxhQUFhekgsU0FBUyxFQUNsQzBQLHNCQUFzQmpJLGFBQWFpSSxtQkFBbUIsRUFDdERLLFNBQVN0SSxhQUFhc0ksTUFBTTtZQUVoQyxJQUFJLE9BQU9MLHdCQUF3QixZQUFZLElBQUksQ0FBQ2xOLFNBQVMsSUFBSSxNQUFNO2dCQUNyRSxJQUFJeUQsV0FBVyxJQUFJLENBQUN6RCxTQUFTLEVBQUUsd0NBQXdDO2dCQUV2RSxJQUFJeEMsY0FBYyxnQkFBZ0IrUCxXQUFXLGNBQWM7b0JBQ3pEOUosU0FBUzlGLFVBQVUsR0FBR3VQO2dCQUN4QixPQUFPO29CQUNMekosU0FBU25ELFNBQVMsR0FBRzRNO2dCQUN2QjtZQUNGO1lBRUEsSUFBSSxDQUFDaEksbUJBQW1CO1FBQzFCO1FBRUFuQixPQUFPb0Isa0JBQWtCLEdBQUcsU0FBU0E7WUFDbkMsSUFBSUksZUFBZSxJQUFJLENBQUMzRixLQUFLLEVBQ3pCcEMsWUFBWStILGFBQWEvSCxTQUFTLEVBQ2xDK1AsU0FBU2hJLGFBQWFnSSxNQUFNO1lBQ2hDLElBQUk3SSxjQUFjLElBQUksQ0FBQ3pFLEtBQUssRUFDeEJ3TCxlQUFlL0csWUFBWStHLFlBQVksRUFDdkNqTCwyQkFBMkJrRSxZQUFZbEUsd0JBQXdCO1lBRW5FLElBQUlBLDRCQUE0QixJQUFJLENBQUNSLFNBQVMsSUFBSSxNQUFNO2dCQUN0RCxJQUFJeUQsV0FBVyxJQUFJLENBQUN6RCxTQUFTLEVBQUUsd0NBQXdDO2dCQUV2RSxJQUFJeEMsY0FBYyxnQkFBZ0IrUCxXQUFXLGNBQWM7b0JBQ3pELElBQUkvUCxjQUFjLE9BQU87d0JBQ3ZCLHdGQUF3Rjt3QkFDeEYsd0hBQXdIO3dCQUN4SCxtRkFBbUY7d0JBQ25GLE9BQVFIOzRCQUNOLEtBQUs7Z0NBQ0hvRyxTQUFTOUYsVUFBVSxHQUFHLENBQUM4TjtnQ0FDdkI7NEJBRUYsS0FBSztnQ0FDSGhJLFNBQVM5RixVQUFVLEdBQUc4TjtnQ0FDdEI7NEJBRUY7Z0NBQ0UsSUFBSXZPLGNBQWN1RyxTQUFTdkcsV0FBVyxFQUNsQzRGLGNBQWNXLFNBQVNYLFdBQVc7Z0NBQ3RDVyxTQUFTOUYsVUFBVSxHQUFHbUYsY0FBYzVGLGNBQWN1TztnQ0FDbEQ7d0JBQ0o7b0JBQ0YsT0FBTzt3QkFDTGhJLFNBQVM5RixVQUFVLEdBQUc4TjtvQkFDeEI7Z0JBQ0YsT0FBTztvQkFDTGhJLFNBQVNuRCxTQUFTLEdBQUdtTDtnQkFDdkI7WUFDRjtZQUVBLElBQUksQ0FBQ3ZHLG1CQUFtQjtRQUMxQjtRQUVBbkIsT0FBT3NCLG9CQUFvQixHQUFHLFNBQVNBO1lBQ3JDLElBQUksSUFBSSxDQUFDdEYsMEJBQTBCLEtBQUssTUFBTTtnQkFDNUNwRSxjQUFjLElBQUksQ0FBQ29FLDBCQUEwQjtZQUMvQztRQUNGO1FBRUFnRSxPQUFPdUIsTUFBTSxHQUFHLFNBQVNBO1lBQ3ZCLElBQUk0QixlQUFlLElBQUksQ0FBQ3RILEtBQUssRUFDekI0RixXQUFXMEIsYUFBYTFCLFFBQVEsRUFDaENDLFlBQVl5QixhQUFhekIsU0FBUyxFQUNsQ2pJLFlBQVkwSixhQUFhMUosU0FBUyxFQUNsQ1gsU0FBU3FLLGFBQWFySyxNQUFNLEVBQzVCNkksV0FBV3dCLGFBQWF4QixRQUFRLEVBQ2hDQyxtQkFBbUJ1QixhQUFhdkIsZ0JBQWdCLEVBQ2hEQyxlQUFlc0IsYUFBYXRCLFlBQVksRUFDeEMwRixZQUFZcEUsYUFBYW9FLFNBQVMsRUFDbEN6RixXQUFXcUIsYUFBYXJCLFFBQVEsRUFDaENpSSx1QkFBdUI1RyxhQUFhbkIsT0FBTyxFQUMzQ0EsVUFBVStILHlCQUF5QixLQUFLLElBQUl2QixtQkFBbUJ1QixzQkFDL0RQLFNBQVNyRyxhQUFhcUcsTUFBTSxFQUM1QnZILG1CQUFtQmtCLGFBQWFsQixnQkFBZ0IsRUFDaERDLGVBQWVpQixhQUFhakIsWUFBWSxFQUN4Q3RKLFFBQVF1SyxhQUFhdkssS0FBSyxFQUMxQnVKLGlCQUFpQmdCLGFBQWFoQixjQUFjLEVBQzVDdEosUUFBUXNLLGFBQWF0SyxLQUFLO1lBQzlCLElBQUl1RCxjQUFjLElBQUksQ0FBQ0YsS0FBSyxDQUFDRSxXQUFXLEVBQUUsd0NBQXdDO1lBRWxGLElBQUlxTixlQUFlaFEsY0FBYyxnQkFBZ0IrUCxXQUFXO1lBQzVELElBQUlsTSxXQUFXbU0sZUFBZSxJQUFJLENBQUNFLG1CQUFtQixHQUFHLElBQUksQ0FBQ0MsaUJBQWlCO1lBRS9FLElBQUlJLHdCQUF3QixJQUFJLENBQUNDLGlCQUFpQixJQUM5Q3ZGLGFBQWFzRixxQkFBcUIsQ0FBQyxFQUFFLEVBQ3JDckYsWUFBWXFGLHFCQUFxQixDQUFDLEVBQUU7WUFFeEMsSUFBSXBILFFBQVEsRUFBRTtZQUVkLElBQUkyRSxZQUFZLEdBQUc7Z0JBQ2pCLElBQUssSUFBSTJDLFNBQVN4RixZQUFZd0YsVUFBVXZGLFdBQVd1RixTQUFVO29CQUMzRHRILE1BQU1HLElBQUksZUFBQzFMLG9EQUFhQSxDQUFDb0ssVUFBVTt3QkFDakN4SCxNQUFNNkg7d0JBQ05qRSxLQUFLbUUsUUFBUWtJLFFBQVFwSTt3QkFDckIwRSxPQUFPMEQ7d0JBQ1A5TixhQUFhK0YsaUJBQWlCL0YsY0FBYytCO3dCQUM1Q3ZGLE9BQU8sSUFBSSxDQUFDMkUsYUFBYSxDQUFDMk07b0JBQzVCO2dCQUNGO1lBQ0YsRUFBRSxpREFBaUQ7WUFDbkQsb0VBQW9FO1lBR3BFLElBQUl2QyxxQkFBcUJrQixzQkFBc0IsSUFBSSxDQUFDaE4sS0FBSyxFQUFFLElBQUksQ0FBQ0UsY0FBYztZQUM5RSxxQkFBTzFFLG9EQUFhQSxDQUFDNEssb0JBQW9CQyxnQkFBZ0IsT0FBTztnQkFDOURSLFdBQVdBO2dCQUNYcEUsVUFBVUE7Z0JBQ1ZtQyxLQUFLLElBQUksQ0FBQ0QsZUFBZTtnQkFDekI1RyxPQUFPM0IsOEVBQVFBLENBQUM7b0JBQ2RnSCxVQUFVO29CQUNWbkYsUUFBUUE7b0JBQ1JELE9BQU9BO29CQUNQRSxVQUFVO29CQUNWaUsseUJBQXlCO29CQUN6QkMsWUFBWTtvQkFDWnhKLFdBQVdBO2dCQUNiLEdBQUdiO1lBQ0wsaUJBQUd2QixvREFBYUEsQ0FBQ3VLLG9CQUFvQkMsZ0JBQWdCLE9BQU87Z0JBQzFESixVQUFVbUI7Z0JBQ1ZuRCxLQUFLa0M7Z0JBQ0wvSSxPQUFPO29CQUNMRSxRQUFRMlEsZUFBZSxTQUFTOUI7b0JBQ2hDekUsZUFBZTlHLGNBQWMsU0FBUytCO29CQUN0Q3RGLE9BQU80USxlQUFlOUIscUJBQXFCO2dCQUM3QztZQUNGO1FBQ0Y7UUFFQTNILE9BQU9tQixtQkFBbUIsR0FBRyxTQUFTQTtZQUNwQyxJQUFJLE9BQU8sSUFBSSxDQUFDdEYsS0FBSyxDQUFDdUIsZUFBZSxLQUFLLFlBQVk7Z0JBQ3BELElBQUltSyxZQUFZLElBQUksQ0FBQzFMLEtBQUssQ0FBQzBMLFNBQVM7Z0JBRXBDLElBQUlBLFlBQVksR0FBRztvQkFDakIsSUFBSTRDLHlCQUF5QixJQUFJLENBQUNGLGlCQUFpQixJQUMvQ0csc0JBQXNCRCxzQkFBc0IsQ0FBQyxFQUFFLEVBQy9DRSxxQkFBcUJGLHNCQUFzQixDQUFDLEVBQUUsRUFDOUNHLHFCQUFxQkgsc0JBQXNCLENBQUMsRUFBRSxFQUM5Q0ksb0JBQW9CSixzQkFBc0IsQ0FBQyxFQUFFO29CQUVqRCxJQUFJLENBQUN4TixvQkFBb0IsQ0FBQ3lOLHFCQUFxQkMsb0JBQW9CQyxvQkFBb0JDO2dCQUN6RjtZQUNGO1lBRUEsSUFBSSxPQUFPLElBQUksQ0FBQzFPLEtBQUssQ0FBQ3lCLFFBQVEsS0FBSyxZQUFZO2dCQUM3QyxJQUFJK0QsZUFBZSxJQUFJLENBQUNuRixLQUFLLEVBQ3pCc08sbUJBQW1CbkosYUFBYTZILGVBQWUsRUFDL0N1QixnQkFBZ0JwSixhQUFhcUcsWUFBWSxFQUN6Q3hELDRCQUE0QjdDLGFBQWE1RSx3QkFBd0I7Z0JBRXJFLElBQUksQ0FBQ1ksYUFBYSxDQUFDbU4sa0JBQWtCQyxlQUFldkc7WUFDdEQ7UUFDRixFQUFFLHVEQUF1RDs7UUFNekRsRSxPQUFPaUssaUJBQWlCLEdBQUcsU0FBU0E7WUFDbEMsSUFBSTdGLGVBQWUsSUFBSSxDQUFDdkksS0FBSyxFQUN6QjBMLFlBQVluRCxhQUFhbUQsU0FBUyxFQUNsQ2hELGdCQUFnQkgsYUFBYUcsYUFBYTtZQUM5QyxJQUFJVCxlQUFlLElBQUksQ0FBQzVILEtBQUssRUFDekJFLGNBQWMwSCxhQUFhMUgsV0FBVyxFQUN0QzhNLGtCQUFrQnBGLGFBQWFvRixlQUFlLEVBQzlDeEIsZUFBZTVELGFBQWE0RCxZQUFZO1lBRTVDLElBQUlILGNBQWMsR0FBRztnQkFDbkIsT0FBTztvQkFBQztvQkFBRztvQkFBRztvQkFBRztpQkFBRTtZQUNyQjtZQUVBLElBQUk3QyxhQUFhcUUsdUJBQXVCLElBQUksQ0FBQ2xOLEtBQUssRUFBRTZMLGNBQWMsSUFBSSxDQUFDM0wsY0FBYztZQUNyRixJQUFJNEksWUFBWXFFLDBCQUEwQixJQUFJLENBQUNuTixLQUFLLEVBQUU2SSxZQUFZZ0QsY0FBYyxJQUFJLENBQUMzTCxjQUFjLEdBQUcsa0VBQWtFO1lBQ3hLLGlFQUFpRTtZQUVqRSxJQUFJNkksbUJBQW1CLENBQUN4SSxlQUFlOE0sb0JBQW9CLGFBQWEvSixLQUFLQyxHQUFHLENBQUMsR0FBR21GLGlCQUFpQjtZQUNyRyxJQUFJTSxrQkFBa0IsQ0FBQ3pJLGVBQWU4TSxvQkFBb0IsWUFBWS9KLEtBQUtDLEdBQUcsQ0FBQyxHQUFHbUYsaUJBQWlCO1lBQ25HLE9BQU87Z0JBQUNwRixLQUFLQyxHQUFHLENBQUMsR0FBR3NGLGFBQWFFO2dCQUFtQnpGLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUNrSSxZQUFZLEdBQUc1QyxZQUFZRTtnQkFBbUJIO2dCQUFZQzthQUFVO1FBQy9JO1FBRUEsT0FBT3NFO0lBQ1QsRUFBRTNSLGdEQUFhQSxHQUFHcUQsT0FBT3VLLFlBQVksR0FBRztRQUN0Q3pMLFdBQVc7UUFDWHFJLFVBQVUzRDtRQUNWcUwsUUFBUTtRQUNSakYsZUFBZTtRQUNmcEMsZ0JBQWdCO0lBQ2xCLEdBQUd4SDtBQUNMLEVBQUUsdUZBQXVGO0FBQ3pGLHVGQUF1RjtBQUN2RixvRUFBb0U7QUFDcEUsaUZBQWlGO0FBQ2pGLCtEQUErRDtBQUUvRCxJQUFJbVAsd0JBQXdCLFNBQVMvSixvQkFBb0JyRixLQUFLLEVBQUV5RixLQUFLO0lBQ25FLElBQUlzQixXQUFXL0csTUFBTStHLFFBQVEsRUFDekJoSSxZQUFZaUIsTUFBTWpCLFNBQVMsRUFDM0JYLFNBQVM0QixNQUFNNUIsTUFBTSxFQUNyQjBRLFNBQVM5TyxNQUFNOE8sTUFBTSxFQUNyQjNILGVBQWVuSCxNQUFNbUgsWUFBWSxFQUNqQ0ssZUFBZXhILE1BQU13SCxZQUFZLEVBQ2pDckosUUFBUTZCLE1BQU03QixLQUFLO0lBQ3ZCLElBQUlzRCxXQUFXZ0UsTUFBTWhFLFFBQVE7SUFFN0IsSUFBSTdCLElBQXlCLEVBQWM7UUFDekMsSUFBSXVILGdCQUFnQixRQUFRSyxnQkFBZ0IsTUFBTTtZQUNoRCxJQUFJd0csd0JBQXdCLENBQUNBLHFCQUFxQnJELEdBQUcsQ0FBQ2xKLFdBQVc7Z0JBQy9EdU0scUJBQXFCcEQsR0FBRyxDQUFDbko7Z0JBQ3pCb0osUUFBUUMsSUFBSSxDQUFDLG1FQUFtRTtZQUNsRjtRQUNGLEVBQUUsd0NBQXdDO1FBRzFDLElBQUlpRSxlQUFlaFEsY0FBYyxnQkFBZ0IrUCxXQUFXO1FBRTVELE9BQVEvUDtZQUNOLEtBQUs7WUFDTCxLQUFLO2dCQUNILElBQUlnUCx3QkFBd0IsQ0FBQ0EscUJBQXFCcEQsR0FBRyxDQUFDbEosV0FBVztvQkFDL0RzTSxxQkFBcUJuRCxHQUFHLENBQUNuSjtvQkFDekJvSixRQUFRQyxJQUFJLENBQUMsbUVBQW1FO2dCQUNsRjtnQkFFQTtZQUVGLEtBQUs7WUFDTCxLQUFLO2dCQUVIO1lBRUY7Z0JBQ0UsTUFBTUMsTUFBTSxxREFBcUQsNENBQTZDLE9BQU9oTSxZQUFZLGtCQUFrQjtRQUN2SjtRQUVBLE9BQVErUDtZQUNOLEtBQUs7WUFDTCxLQUFLO2dCQUVIO1lBRUY7Z0JBQ0UsTUFBTS9ELE1BQU0sa0RBQWtELHdEQUF5RCxPQUFPK0QsU0FBUyxrQkFBa0I7UUFDN0o7UUFFQSxJQUFJL0gsWUFBWSxNQUFNO1lBQ3BCLE1BQU1nRSxNQUFNLG9EQUFvRCx3Q0FBeUMsT0FBUWhFLENBQUFBLGFBQWEsT0FBTyxTQUFTLE9BQU9BLFFBQU8sSUFBSyxrQkFBa0I7UUFDckw7UUFFQSxJQUFJZ0ksZ0JBQWdCLE9BQU81USxVQUFVLFVBQVU7WUFDN0MsTUFBTTRNLE1BQU0saURBQWlELHVEQUF3RCxPQUFRNU0sQ0FBQUEsVUFBVSxPQUFPLFNBQVMsT0FBT0EsS0FBSSxJQUFLLGtCQUFrQjtRQUMzTCxPQUFPLElBQUksQ0FBQzRRLGdCQUFnQixPQUFPM1EsV0FBVyxVQUFVO1lBQ3RELE1BQU0yTSxNQUFNLGtEQUFrRCxzREFBdUQsT0FBUTNNLENBQUFBLFdBQVcsT0FBTyxTQUFTLE9BQU9BLE1BQUssSUFBSyxrQkFBa0I7UUFDN0w7SUFDRjtBQUNGO0FBRUEsSUFBSTRSLGdDQUFnQztBQUVwQyxJQUFJQyxvQkFBb0IsU0FBU3JFLGdCQUFnQnpLLEtBQUssRUFBRTJLLEtBQUssRUFBRUMsYUFBYTtJQUMxRSxJQUFJMU0sT0FBTzhCLE9BQ1A4SyxXQUFXNU0sS0FBSzRNLFFBQVE7SUFDNUIsSUFBSUQsa0JBQWtCRCxjQUFjQyxlQUFlLEVBQy9DRSxvQkFBb0JILGNBQWNHLGlCQUFpQjtJQUV2RCxJQUFJSixRQUFRSSxtQkFBbUI7UUFDN0IsSUFBSVosU0FBUztRQUViLElBQUlZLHFCQUFxQixHQUFHO1lBQzFCLElBQUliLGVBQWVXLGVBQWUsQ0FBQ0Usa0JBQWtCO1lBQ3JEWixTQUFTRCxhQUFhQyxNQUFNLEdBQUdELGFBQWF4TixJQUFJO1FBQ2xEO1FBRUEsSUFBSyxJQUFJc08sSUFBSUQsb0JBQW9CLEdBQUdDLEtBQUtMLE9BQU9LLElBQUs7WUFDbkQsSUFBSXRPLE9BQU9vTyxTQUFTRTtZQUNwQkgsZUFBZSxDQUFDRyxFQUFFLEdBQUc7Z0JBQ25CYixRQUFRQTtnQkFDUnpOLE1BQU1BO1lBQ1I7WUFDQXlOLFVBQVV6TjtRQUNaO1FBRUFrTyxjQUFjRyxpQkFBaUIsR0FBR0o7SUFDcEM7SUFFQSxPQUFPRSxlQUFlLENBQUNGLE1BQU07QUFDL0I7QUFFQSxJQUFJb0Usb0JBQW9CLFNBQVM5RCxnQkFBZ0JqTCxLQUFLLEVBQUU0SyxhQUFhLEVBQUVULE1BQU07SUFDM0UsSUFBSVUsa0JBQWtCRCxjQUFjQyxlQUFlLEVBQy9DRSxvQkFBb0JILGNBQWNHLGlCQUFpQjtJQUN2RCxJQUFJRyx5QkFBeUJILG9CQUFvQixJQUFJRixlQUFlLENBQUNFLGtCQUFrQixDQUFDWixNQUFNLEdBQUc7SUFFakcsSUFBSWUsMEJBQTBCZixRQUFRO1FBQ3BDLDZGQUE2RjtRQUM3RixPQUFPNkUsOEJBQThCaFAsT0FBTzRLLGVBQWVHLG1CQUFtQixHQUFHWjtJQUNuRixPQUFPO1FBQ0wsdUdBQXVHO1FBQ3ZHLHdHQUF3RztRQUN4Ryx3REFBd0Q7UUFDeEQsT0FBTzhFLG1DQUFtQ2pQLE9BQU80SyxlQUFldEgsS0FBS0MsR0FBRyxDQUFDLEdBQUd3SCxvQkFBb0JaO0lBQ2xHO0FBQ0Y7QUFFQSxJQUFJNkUsZ0NBQWdDLFNBQVM3RCw0QkFBNEJuTCxLQUFLLEVBQUU0SyxhQUFhLEVBQUVTLElBQUksRUFBRUMsR0FBRyxFQUFFbkIsTUFBTTtJQUM5RyxNQUFPbUIsT0FBT0QsS0FBTTtRQUNsQixJQUFJRSxTQUFTRCxNQUFNaEksS0FBS2tJLEtBQUssQ0FBQyxDQUFDSCxPQUFPQyxHQUFFLElBQUs7UUFDN0MsSUFBSUcsZ0JBQWdCcUQsa0JBQWtCOU8sT0FBT3VMLFFBQVFYLGVBQWVULE1BQU07UUFFMUUsSUFBSXNCLGtCQUFrQnRCLFFBQVE7WUFDNUIsT0FBT29CO1FBQ1QsT0FBTyxJQUFJRSxnQkFBZ0J0QixRQUFRO1lBQ2pDbUIsTUFBTUMsU0FBUztRQUNqQixPQUFPLElBQUlFLGdCQUFnQnRCLFFBQVE7WUFDakNrQixPQUFPRSxTQUFTO1FBQ2xCO0lBQ0Y7SUFFQSxJQUFJRCxNQUFNLEdBQUc7UUFDWCxPQUFPQSxNQUFNO0lBQ2YsT0FBTztRQUNMLE9BQU87SUFDVDtBQUNGO0FBRUEsSUFBSTJELHFDQUFxQyxTQUFTN0QsaUNBQWlDcEwsS0FBSyxFQUFFNEssYUFBYSxFQUFFRCxLQUFLLEVBQUVSLE1BQU07SUFDcEgsSUFBSXVCLFlBQVkxTCxNQUFNMEwsU0FBUztJQUMvQixJQUFJQyxXQUFXO0lBRWYsTUFBT2hCLFFBQVFlLGFBQWFvRCxrQkFBa0I5TyxPQUFPMkssT0FBT0MsZUFBZVQsTUFBTSxHQUFHQSxPQUFRO1FBQzFGUSxTQUFTZ0I7UUFDVEEsWUFBWTtJQUNkO0lBRUEsT0FBT3FELDhCQUE4QmhQLE9BQU80SyxlQUFldEgsS0FBS0UsR0FBRyxDQUFDbUgsT0FBT2UsWUFBWSxJQUFJcEksS0FBS2tJLEtBQUssQ0FBQ2IsUUFBUSxJQUFJUjtBQUNwSDtBQUVBLElBQUk2Qyx3QkFBd0IsU0FBU0Esc0JBQXNCbk8sS0FBSyxFQUFFeUYsS0FBSztJQUNyRSxJQUFJb0gsWUFBWTdNLE1BQU02TSxTQUFTO0lBQy9CLElBQUliLGtCQUFrQnZHLE1BQU11RyxlQUFlLEVBQ3ZDcUUsb0JBQW9CNUssTUFBTTRLLGlCQUFpQixFQUMzQ25FLG9CQUFvQnpHLE1BQU15RyxpQkFBaUI7SUFDL0MsSUFBSW9FLDJCQUEyQixHQUFHLHdGQUF3RjtJQUMxSCxtREFBbUQ7SUFFbkQsSUFBSXBFLHFCQUFxQlcsV0FBVztRQUNsQ1gsb0JBQW9CVyxZQUFZO0lBQ2xDO0lBRUEsSUFBSVgscUJBQXFCLEdBQUc7UUFDMUIsSUFBSWIsZUFBZVcsZUFBZSxDQUFDRSxrQkFBa0I7UUFDckRvRSwyQkFBMkJqRixhQUFhQyxNQUFNLEdBQUdELGFBQWF4TixJQUFJO0lBQ3BFO0lBRUEsSUFBSTBOLHFCQUFxQnNCLFlBQVlYLG9CQUFvQjtJQUN6RCxJQUFJViw2QkFBNkJELHFCQUFxQjhFO0lBQ3RELE9BQU9DLDJCQUEyQjlFO0FBQ3BDO0FBRUEsSUFBSStFLG1CQUFtQixXQUFXLEdBQUV0QyxvQkFBb0I7SUFDdERDLGVBQWUsU0FBU0EsY0FBYy9NLEtBQUssRUFBRTJLLEtBQUssRUFBRUMsYUFBYTtRQUMvRCxPQUFPa0Usa0JBQWtCOU8sT0FBTzJLLE9BQU9DLGVBQWVULE1BQU07SUFDOUQ7SUFDQThDLGFBQWEsU0FBU0EsWUFBWWpOLEtBQUssRUFBRTJLLEtBQUssRUFBRUMsYUFBYTtRQUMzRCxPQUFPQSxjQUFjQyxlQUFlLENBQUNGLE1BQU0sQ0FBQ2pPLElBQUk7SUFDbEQ7SUFDQXNRLHVCQUF1QkE7SUFDdkJwQiwrQkFBK0IsU0FBU0EsOEJBQThCNUwsS0FBSyxFQUFFMkssS0FBSyxFQUFFakcsS0FBSyxFQUFFbUgsWUFBWSxFQUFFakIsYUFBYSxFQUFFN0YsYUFBYTtRQUNuSSxJQUFJbkgsWUFBWW9DLE1BQU1wQyxTQUFTLEVBQzNCWCxTQUFTK0MsTUFBTS9DLE1BQU0sRUFDckIwUSxTQUFTM04sTUFBTTJOLE1BQU0sRUFDckIzUSxRQUFRZ0QsTUFBTWhELEtBQUssRUFBRSx3Q0FBd0M7UUFFakUsSUFBSTRRLGVBQWVoUSxjQUFjLGdCQUFnQitQLFdBQVc7UUFDNUQsSUFBSWpSLE9BQU9rUixlQUFlNVEsUUFBUUM7UUFDbEMsSUFBSWlOLGVBQWU0RSxrQkFBa0I5TyxPQUFPMkssT0FBT0MsZ0JBQWdCLDJEQUEyRDtRQUM5SCx1RUFBdUU7UUFFdkUsSUFBSWtCLHFCQUFxQmtCLHNCQUFzQmhOLE9BQU80SztRQUN0RCxJQUFJbUIsWUFBWXpJLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUNzSSxxQkFBcUJwUCxNQUFNd04sYUFBYUMsTUFBTTtRQUNuRixJQUFJNkIsWUFBWTFJLEtBQUtDLEdBQUcsQ0FBQyxHQUFHMkcsYUFBYUMsTUFBTSxHQUFHek4sT0FBT3dOLGFBQWF4TixJQUFJLEdBQUdxSTtRQUU3RSxJQUFJTCxVQUFVLFNBQVM7WUFDckIsSUFBSW1ILGdCQUFnQkcsWUFBWXRQLFFBQVFtUCxnQkFBZ0JFLFlBQVlyUCxNQUFNO2dCQUN4RWdJLFFBQVE7WUFDVixPQUFPO2dCQUNMQSxRQUFRO1lBQ1Y7UUFDRjtRQUVBLE9BQVFBO1lBQ04sS0FBSztnQkFDSCxPQUFPcUg7WUFFVCxLQUFLO2dCQUNILE9BQU9DO1lBRVQsS0FBSztnQkFDSCxPQUFPMUksS0FBSzJJLEtBQUssQ0FBQ0QsWUFBWSxDQUFDRCxZQUFZQyxTQUFRLElBQUs7WUFFMUQsS0FBSztZQUNMO2dCQUNFLElBQUlILGdCQUFnQkcsYUFBYUgsZ0JBQWdCRSxXQUFXO29CQUMxRCxPQUFPRjtnQkFDVCxPQUFPLElBQUlBLGVBQWVHLFdBQVc7b0JBQ25DLE9BQU9BO2dCQUNULE9BQU87b0JBQ0wsT0FBT0Q7Z0JBQ1Q7UUFFSjtJQUNGO0lBQ0FtQix3QkFBd0IsU0FBU0EsdUJBQXVCbE4sS0FBSyxFQUFFbUssTUFBTSxFQUFFUyxhQUFhO1FBQ2xGLE9BQU9tRSxrQkFBa0IvTyxPQUFPNEssZUFBZVQ7SUFDakQ7SUFDQWdELDJCQUEyQixTQUFTQSwwQkFBMEJuTixLQUFLLEVBQUU2SSxVQUFVLEVBQUVnRCxZQUFZLEVBQUVqQixhQUFhO1FBQzFHLElBQUloTixZQUFZb0MsTUFBTXBDLFNBQVMsRUFDM0JYLFNBQVMrQyxNQUFNL0MsTUFBTSxFQUNyQnlPLFlBQVkxTCxNQUFNMEwsU0FBUyxFQUMzQmlDLFNBQVMzTixNQUFNMk4sTUFBTSxFQUNyQjNRLFFBQVFnRCxNQUFNaEQsS0FBSyxFQUFFLHdDQUF3QztRQUVqRSxJQUFJNFEsZUFBZWhRLGNBQWMsZ0JBQWdCK1AsV0FBVztRQUM1RCxJQUFJalIsT0FBT2tSLGVBQWU1USxRQUFRQztRQUNsQyxJQUFJaU4sZUFBZTRFLGtCQUFrQjlPLE9BQU82SSxZQUFZK0I7UUFDeEQsSUFBSW1CLFlBQVlGLGVBQWVuUDtRQUMvQixJQUFJeU4sU0FBU0QsYUFBYUMsTUFBTSxHQUFHRCxhQUFheE4sSUFBSTtRQUNwRCxJQUFJb00sWUFBWUQ7UUFFaEIsTUFBT0MsWUFBWTRDLFlBQVksS0FBS3ZCLFNBQVM0QixVQUFXO1lBQ3REakQ7WUFDQXFCLFVBQVUyRSxrQkFBa0I5TyxPQUFPOEksV0FBVzhCLGVBQWVsTyxJQUFJO1FBQ25FO1FBRUEsT0FBT29NO0lBQ1Q7SUFDQW5KLG1CQUFtQixTQUFTQSxrQkFBa0JLLEtBQUssRUFBRU0sUUFBUTtRQUMzRCxJQUFJa0UsUUFBUXhFLE9BQ1JrUCxvQkFBb0IxSyxNQUFNMEssaUJBQWlCO1FBQy9DLElBQUl0RSxnQkFBZ0I7WUFDbEJDLGlCQUFpQixDQUFDO1lBQ2xCcUUsbUJBQW1CQSxxQkFBcUJMO1lBQ3hDOUQsbUJBQW1CLENBQUM7UUFDdEI7UUFFQXpLLFNBQVMrTyxlQUFlLEdBQUcsU0FBVTFFLEtBQUssRUFBRXlCLGlCQUFpQjtZQUMzRCxJQUFJQSxzQkFBc0IsS0FBSyxHQUFHO2dCQUNoQ0Esb0JBQW9CO1lBQ3RCO1lBRUF4QixjQUFjRyxpQkFBaUIsR0FBR3pILEtBQUtFLEdBQUcsQ0FBQ29ILGNBQWNHLGlCQUFpQixFQUFFSixRQUFRLElBQUksa0ZBQWtGO1lBQzFLLG1FQUFtRTtZQUNuRSx3Q0FBd0M7WUFDeEMsaUZBQWlGO1lBRWpGckssU0FBU3lCLGtCQUFrQixDQUFDLENBQUM7WUFFN0IsSUFBSXFLLG1CQUFtQjtnQkFDckI5TCxTQUFTa00sV0FBVztZQUN0QjtRQUNGO1FBRUEsT0FBTzVCO0lBQ1Q7SUFDQWhMLHVDQUF1QztJQUN2Q0MsZUFBZSxTQUFTQSxjQUFjeUosS0FBSztRQUN6QyxJQUFJd0IsV0FBV3hCLE1BQU13QixRQUFRO1FBRTdCLElBQUlyTSxJQUF5QixFQUFjO1lBQ3pDLElBQUksT0FBT3FNLGFBQWEsWUFBWTtnQkFDbEMsTUFBTWxCLE1BQU0sb0RBQW9ELGlDQUFrQyxPQUFRa0IsQ0FBQUEsYUFBYSxPQUFPLFNBQVMsT0FBT0EsUUFBTyxJQUFLLGtCQUFrQjtZQUM5SztRQUNGO0lBQ0Y7QUFDRjtBQUVBLElBQUl3RSxnQkFBZ0IsV0FBVyxHQUFFMVEsb0JBQW9CO0lBQ25ERyxpQkFBaUIsU0FBU0EsZ0JBQWdCYixJQUFJLEVBQUV5TSxLQUFLO1FBQ25ELElBQUkvSSxjQUFjMUQsS0FBSzBELFdBQVc7UUFDbEMsT0FBTytJLFFBQVEvSTtJQUNqQjtJQUNBMUMsZ0JBQWdCLFNBQVNBLGVBQWVMLEtBQUssRUFBRThMLEtBQUs7UUFDbEQsSUFBSS9JLGNBQWMvQyxNQUFNK0MsV0FBVztRQUNuQyxPQUFPQTtJQUNUO0lBQ0FwQyxjQUFjLFNBQVNBLGFBQWE4RSxLQUFLLEVBQUVxRyxLQUFLO1FBQzlDLElBQUk5SSxZQUFZeUMsTUFBTXpDLFNBQVM7UUFDL0IsT0FBTzhJLFFBQVE5STtJQUNqQjtJQUNBdEMsY0FBYyxTQUFTQSxhQUFhaUYsS0FBSyxFQUFFbUcsS0FBSztRQUM5QyxJQUFJOUksWUFBWTJDLE1BQU0zQyxTQUFTO1FBQy9CLE9BQU9BO0lBQ1Q7SUFDQTFDLHlCQUF5QixTQUFTQSx3QkFBd0JtSyxLQUFLO1FBQzdELElBQUl6RSxXQUFXeUUsTUFBTXpFLFFBQVEsRUFDekJoRCxZQUFZeUgsTUFBTXpILFNBQVM7UUFDL0IsT0FBT0EsWUFBWWdEO0lBQ3JCO0lBQ0F6Rix3QkFBd0IsU0FBU0EsdUJBQXVCbUssS0FBSztRQUMzRCxJQUFJM0UsY0FBYzJFLE1BQU0zRSxXQUFXLEVBQy9CaEQsY0FBYzJILE1BQU0zSCxXQUFXO1FBQ25DLE9BQU9BLGNBQWNnRDtJQUN2QjtJQUNBdkYsZ0NBQWdDLFNBQVNBLCtCQUErQm9OLEtBQUssRUFBRXRPLFdBQVcsRUFBRXVHLEtBQUssRUFBRTNHLFVBQVUsRUFBRTZNLGFBQWEsRUFBRTdGLGFBQWE7UUFDekksSUFBSUgsY0FBYzZILE1BQU03SCxXQUFXLEVBQy9CaEQsY0FBYzZLLE1BQU03SyxXQUFXLEVBQy9CNUUsUUFBUXlQLE1BQU16UCxLQUFLO1FBQ3ZCLElBQUl1UyxtQkFBbUJqTSxLQUFLQyxHQUFHLENBQUMsR0FBR3FCLGNBQWNoRCxjQUFjNUU7UUFDL0QsSUFBSStPLFlBQVl6SSxLQUFLRSxHQUFHLENBQUMrTCxrQkFBa0JwUixjQUFjeUQ7UUFDekQsSUFBSW9LLFlBQVkxSSxLQUFLQyxHQUFHLENBQUMsR0FBR3BGLGNBQWN5RCxjQUFjNUUsUUFBUStILGdCQUFnQm5EO1FBRWhGLElBQUk4QyxVQUFVLFNBQVM7WUFDckIsSUFBSTNHLGNBQWNpTyxZQUFZaFAsU0FBU2UsY0FBY2dPLFlBQVkvTyxPQUFPO2dCQUN0RTBILFFBQVE7WUFDVixPQUFPO2dCQUNMQSxRQUFRO1lBQ1Y7UUFDRjtRQUVBLE9BQVFBO1lBQ04sS0FBSztnQkFDSCxPQUFPcUg7WUFFVCxLQUFLO2dCQUNILE9BQU9DO1lBRVQsS0FBSztnQkFDSCwrREFBK0Q7Z0JBQy9ELDBEQUEwRDtnQkFDMUQsSUFBSXdELGVBQWVsTSxLQUFLMkksS0FBSyxDQUFDRCxZQUFZLENBQUNELFlBQVlDLFNBQVEsSUFBSztnQkFFcEUsSUFBSXdELGVBQWVsTSxLQUFLbU0sSUFBSSxDQUFDelMsUUFBUSxJQUFJO29CQUN2QyxPQUFPLEdBQUcscUJBQXFCO2dCQUNqQyxPQUFPLElBQUl3UyxlQUFlRCxtQkFBbUJqTSxLQUFLa0ksS0FBSyxDQUFDeE8sUUFBUSxJQUFJO29CQUNsRSxPQUFPdVMsa0JBQWtCLGVBQWU7Z0JBQzFDLE9BQU87b0JBQ0wsT0FBT0M7Z0JBQ1Q7WUFFRixLQUFLO1lBQ0w7Z0JBQ0UsSUFBSXpSLGNBQWNpTyxhQUFhak8sY0FBY2dPLFdBQVc7b0JBQ3RELE9BQU9oTztnQkFDVCxPQUFPLElBQUlpTyxZQUFZRCxXQUFXO29CQUNoQyxrRkFBa0Y7b0JBQ2xGLHNFQUFzRTtvQkFDdEUsT0FBT0M7Z0JBQ1QsT0FBTyxJQUFJak8sYUFBYWlPLFdBQVc7b0JBQ2pDLE9BQU9BO2dCQUNULE9BQU87b0JBQ0wsT0FBT0Q7Z0JBQ1Q7UUFFSjtJQUNGO0lBQ0F6TSw2QkFBNkIsU0FBU0EsNEJBQTRCb1EsS0FBSyxFQUFFclIsUUFBUSxFQUFFcUcsS0FBSyxFQUFFaEUsU0FBUyxFQUFFa0ssYUFBYSxFQUFFN0YsYUFBYTtRQUMvSCxJQUFJbEQsWUFBWTZOLE1BQU03TixTQUFTLEVBQzNCNUUsU0FBU3lTLE1BQU16UyxNQUFNLEVBQ3JCNEgsV0FBVzZLLE1BQU03SyxRQUFRO1FBQzdCLElBQUk4SyxnQkFBZ0JyTSxLQUFLQyxHQUFHLENBQUMsR0FBR3NCLFdBQVdoRCxZQUFZNUU7UUFDdkQsSUFBSThPLFlBQVl6SSxLQUFLRSxHQUFHLENBQUNtTSxlQUFldFIsV0FBV3dEO1FBQ25ELElBQUltSyxZQUFZMUksS0FBS0MsR0FBRyxDQUFDLEdBQUdsRixXQUFXd0QsWUFBWTVFLFNBQVM4SCxnQkFBZ0JsRDtRQUU1RSxJQUFJNkMsVUFBVSxTQUFTO1lBQ3JCLElBQUloRSxhQUFhc0wsWUFBWS9PLFVBQVV5RCxhQUFhcUwsWUFBWTlPLFFBQVE7Z0JBQ3RFeUgsUUFBUTtZQUNWLE9BQU87Z0JBQ0xBLFFBQVE7WUFDVjtRQUNGO1FBRUEsT0FBUUE7WUFDTixLQUFLO2dCQUNILE9BQU9xSDtZQUVULEtBQUs7Z0JBQ0gsT0FBT0M7WUFFVCxLQUFLO2dCQUNILCtEQUErRDtnQkFDL0QsMERBQTBEO2dCQUMxRCxJQUFJd0QsZUFBZWxNLEtBQUsySSxLQUFLLENBQUNELFlBQVksQ0FBQ0QsWUFBWUMsU0FBUSxJQUFLO2dCQUVwRSxJQUFJd0QsZUFBZWxNLEtBQUttTSxJQUFJLENBQUN4UyxTQUFTLElBQUk7b0JBQ3hDLE9BQU8sR0FBRyxxQkFBcUI7Z0JBQ2pDLE9BQU8sSUFBSXVTLGVBQWVHLGdCQUFnQnJNLEtBQUtrSSxLQUFLLENBQUN2TyxTQUFTLElBQUk7b0JBQ2hFLE9BQU8wUyxlQUFlLGVBQWU7Z0JBQ3ZDLE9BQU87b0JBQ0wsT0FBT0g7Z0JBQ1Q7WUFFRixLQUFLO1lBQ0w7Z0JBQ0UsSUFBSTlPLGFBQWFzTCxhQUFhdEwsYUFBYXFMLFdBQVc7b0JBQ3BELE9BQU9yTDtnQkFDVCxPQUFPLElBQUlzTCxZQUFZRCxXQUFXO29CQUNoQyxrRkFBa0Y7b0JBQ2xGLHNFQUFzRTtvQkFDdEUsT0FBT0M7Z0JBQ1QsT0FBTyxJQUFJdEwsWUFBWXNMLFdBQVc7b0JBQ2hDLE9BQU9BO2dCQUNULE9BQU87b0JBQ0wsT0FBT0Q7Z0JBQ1Q7UUFFSjtJQUNGO0lBQ0EvTSw4QkFBOEIsU0FBU0EsNkJBQTZCNFEsS0FBSyxFQUFFN1IsVUFBVTtRQUNuRixJQUFJNkQsY0FBY2dPLE1BQU1oTyxXQUFXLEVBQy9CZ0QsY0FBY2dMLE1BQU1oTCxXQUFXO1FBQ25DLE9BQU90QixLQUFLQyxHQUFHLENBQUMsR0FBR0QsS0FBS0UsR0FBRyxDQUFDb0IsY0FBYyxHQUFHdEIsS0FBS2tJLEtBQUssQ0FBQ3pOLGFBQWE2RDtJQUN2RTtJQUNBM0MsaUNBQWlDLFNBQVNBLGdDQUFnQzRRLE1BQU0sRUFBRWhILFVBQVUsRUFBRTlLLFVBQVU7UUFDdEcsSUFBSTZELGNBQWNpTyxPQUFPak8sV0FBVyxFQUNoQ2dELGNBQWNpTCxPQUFPakwsV0FBVyxFQUNoQzVILFFBQVE2UyxPQUFPN1MsS0FBSztRQUN4QixJQUFJcUYsT0FBT3dHLGFBQWFqSDtRQUN4QixJQUFJa08sb0JBQW9CeE0sS0FBS21NLElBQUksQ0FBQyxDQUFDelMsUUFBUWUsYUFBYXNFLElBQUcsSUFBS1Q7UUFDaEUsT0FBTzBCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRCxLQUFLRSxHQUFHLENBQUNvQixjQUFjLEdBQUdpRSxhQUFhaUgsb0JBQW9CLEVBQUUsd0NBQXdDOztJQUUxSDtJQUNBclEsMkJBQTJCLFNBQVNBLDBCQUEwQnNRLE1BQU0sRUFBRXJQLFNBQVM7UUFDN0UsSUFBSW1CLFlBQVlrTyxPQUFPbE8sU0FBUyxFQUM1QmdELFdBQVdrTCxPQUFPbEwsUUFBUTtRQUM5QixPQUFPdkIsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQ3FCLFdBQVcsR0FBR3ZCLEtBQUtrSSxLQUFLLENBQUM5SyxZQUFZbUI7SUFDbkU7SUFDQW5DLDhCQUE4QixTQUFTQSw2QkFBNkJzUSxNQUFNLEVBQUVuSCxVQUFVLEVBQUVuSSxTQUFTO1FBQy9GLElBQUltQixZQUFZbU8sT0FBT25PLFNBQVMsRUFDNUJnRCxXQUFXbUwsT0FBT25MLFFBQVEsRUFDMUI1SCxTQUFTK1MsT0FBTy9TLE1BQU07UUFDMUIsSUFBSXVGLE1BQU1xRyxhQUFhaEg7UUFDdkIsSUFBSW9PLGlCQUFpQjNNLEtBQUttTSxJQUFJLENBQUMsQ0FBQ3hTLFNBQVN5RCxZQUFZOEIsR0FBRSxJQUFLWDtRQUM1RCxPQUFPeUIsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQ3FCLFdBQVcsR0FBR2dFLGFBQWFvSCxpQkFBaUIsRUFBRSx3Q0FBd0M7O0lBRXBIO0lBQ0F0USxtQkFBbUIsU0FBU0Esa0JBQWtCSyxLQUFLLEdBQ25EO0lBQ0FKLHVDQUF1QztJQUN2Q0MsZUFBZSxTQUFTQSxjQUFjcVEsTUFBTTtRQUMxQyxJQUFJdE8sY0FBY3NPLE9BQU90TyxXQUFXLEVBQ2hDQyxZQUFZcU8sT0FBT3JPLFNBQVM7UUFFaEMsSUFBSXBELElBQXlCLEVBQWM7WUFDekMsSUFBSSxPQUFPbUQsZ0JBQWdCLFVBQVU7Z0JBQ25DLE1BQU1nSSxNQUFNLHVEQUF1RCwrQkFBZ0MsT0FBUWhJLENBQUFBLGdCQUFnQixPQUFPLFNBQVMsT0FBT0EsV0FBVSxJQUFLLGtCQUFrQjtZQUNyTDtZQUVBLElBQUksT0FBT0MsY0FBYyxVQUFVO2dCQUNqQyxNQUFNK0gsTUFBTSxxREFBcUQsK0JBQWdDLE9BQVEvSCxDQUFBQSxjQUFjLE9BQU8sU0FBUyxPQUFPQSxTQUFRLElBQUssa0JBQWtCO1lBQy9LO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsSUFBSXNPLGdCQUFnQixXQUFXLEdBQUVyRCxvQkFBb0I7SUFDbkRDLGVBQWUsU0FBU0EsY0FBYzdPLElBQUksRUFBRXlNLEtBQUs7UUFDL0MsSUFBSUcsV0FBVzVNLEtBQUs0TSxRQUFRO1FBQzVCLE9BQU9ILFFBQVFHO0lBQ2pCO0lBQ0FtQyxhQUFhLFNBQVNBLFlBQVlwTyxLQUFLLEVBQUU4TCxLQUFLO1FBQzVDLElBQUlHLFdBQVdqTSxNQUFNaU0sUUFBUTtRQUM3QixPQUFPQTtJQUNUO0lBQ0FrQyx1QkFBdUIsU0FBU0Esc0JBQXNCMUksS0FBSztRQUN6RCxJQUFJb0gsWUFBWXBILE1BQU1vSCxTQUFTLEVBQzNCWixXQUFXeEcsTUFBTXdHLFFBQVE7UUFDN0IsT0FBT0EsV0FBV1k7SUFDcEI7SUFDQUUsK0JBQStCLFNBQVNBLDhCQUE4QnBILEtBQUssRUFBRW1HLEtBQUssRUFBRWpHLEtBQUssRUFBRW1ILFlBQVksRUFBRWpCLGFBQWEsRUFBRTdGLGFBQWE7UUFDbkksSUFBSW5ILFlBQVk0RyxNQUFNNUcsU0FBUyxFQUMzQlgsU0FBU3VILE1BQU12SCxNQUFNLEVBQ3JCeU8sWUFBWWxILE1BQU1rSCxTQUFTLEVBQzNCWixXQUFXdEcsTUFBTXNHLFFBQVEsRUFDekI2QyxTQUFTbkosTUFBTW1KLE1BQU0sRUFDckIzUSxRQUFRd0gsTUFBTXhILEtBQUs7UUFDdkIsd0NBQXdDO1FBQ3hDLElBQUk0USxlQUFlaFEsY0FBYyxnQkFBZ0IrUCxXQUFXO1FBQzVELElBQUlqUixPQUFPa1IsZUFBZTVRLFFBQVFDO1FBQ2xDLElBQUltVCxpQkFBaUI5TSxLQUFLQyxHQUFHLENBQUMsR0FBR21JLFlBQVlaLFdBQVdwTztRQUN4RCxJQUFJcVAsWUFBWXpJLEtBQUtFLEdBQUcsQ0FBQzRNLGdCQUFnQnpGLFFBQVFHO1FBQ2pELElBQUlrQixZQUFZMUksS0FBS0MsR0FBRyxDQUFDLEdBQUdvSCxRQUFRRyxXQUFXcE8sT0FBT29PLFdBQVcvRjtRQUVqRSxJQUFJTCxVQUFVLFNBQVM7WUFDckIsSUFBSW1ILGdCQUFnQkcsWUFBWXRQLFFBQVFtUCxnQkFBZ0JFLFlBQVlyUCxNQUFNO2dCQUN4RWdJLFFBQVE7WUFDVixPQUFPO2dCQUNMQSxRQUFRO1lBQ1Y7UUFDRjtRQUVBLE9BQVFBO1lBQ04sS0FBSztnQkFDSCxPQUFPcUg7WUFFVCxLQUFLO2dCQUNILE9BQU9DO1lBRVQsS0FBSztnQkFDSDtvQkFDRSwrREFBK0Q7b0JBQy9ELDBEQUEwRDtvQkFDMUQsSUFBSXdELGVBQWVsTSxLQUFLMkksS0FBSyxDQUFDRCxZQUFZLENBQUNELFlBQVlDLFNBQVEsSUFBSztvQkFFcEUsSUFBSXdELGVBQWVsTSxLQUFLbU0sSUFBSSxDQUFDL1MsT0FBTyxJQUFJO3dCQUN0QyxPQUFPLEdBQUcscUJBQXFCO29CQUNqQyxPQUFPLElBQUk4UyxlQUFlWSxpQkFBaUI5TSxLQUFLa0ksS0FBSyxDQUFDOU8sT0FBTyxJQUFJO3dCQUMvRCxPQUFPMFQsZ0JBQWdCLGVBQWU7b0JBQ3hDLE9BQU87d0JBQ0wsT0FBT1o7b0JBQ1Q7Z0JBQ0Y7WUFFRixLQUFLO1lBQ0w7Z0JBQ0UsSUFBSTNELGdCQUFnQkcsYUFBYUgsZ0JBQWdCRSxXQUFXO29CQUMxRCxPQUFPRjtnQkFDVCxPQUFPLElBQUlBLGVBQWVHLFdBQVc7b0JBQ25DLE9BQU9BO2dCQUNULE9BQU87b0JBQ0wsT0FBT0Q7Z0JBQ1Q7UUFFSjtJQUNGO0lBQ0FtQix3QkFBd0IsU0FBU0EsdUJBQXVCNUQsS0FBSyxFQUFFYSxNQUFNO1FBQ25FLElBQUl1QixZQUFZcEMsTUFBTW9DLFNBQVMsRUFDM0JaLFdBQVd4QixNQUFNd0IsUUFBUTtRQUM3QixPQUFPeEgsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQ2tJLFlBQVksR0FBR3BJLEtBQUtrSSxLQUFLLENBQUNyQixTQUFTVztJQUNqRTtJQUNBcUMsMkJBQTJCLFNBQVNBLDBCQUEwQjVELEtBQUssRUFBRVYsVUFBVSxFQUFFZ0QsWUFBWTtRQUMzRixJQUFJak8sWUFBWTJMLE1BQU0zTCxTQUFTLEVBQzNCWCxTQUFTc00sTUFBTXRNLE1BQU0sRUFDckJ5TyxZQUFZbkMsTUFBTW1DLFNBQVMsRUFDM0JaLFdBQVd2QixNQUFNdUIsUUFBUSxFQUN6QjZDLFNBQVNwRSxNQUFNb0UsTUFBTSxFQUNyQjNRLFFBQVF1TSxNQUFNdk0sS0FBSztRQUN2Qix3Q0FBd0M7UUFDeEMsSUFBSTRRLGVBQWVoUSxjQUFjLGdCQUFnQitQLFdBQVc7UUFDNUQsSUFBSXhELFNBQVN0QixhQUFhaUM7UUFDMUIsSUFBSXBPLE9BQU9rUixlQUFlNVEsUUFBUUM7UUFDbEMsSUFBSW9ULGtCQUFrQi9NLEtBQUttTSxJQUFJLENBQUMsQ0FBQy9TLE9BQU9tUCxlQUFlMUIsTUFBSyxJQUFLVztRQUNqRSxPQUFPeEgsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQ2tJLFlBQVksR0FBRzdDLGFBQWF3SCxrQkFBa0IsRUFBRSx3Q0FBd0M7O0lBRXRIO0lBQ0ExUSxtQkFBbUIsU0FBU0Esa0JBQWtCSyxLQUFLLEdBQ25EO0lBQ0FKLHVDQUF1QztJQUN2Q0MsZUFBZSxTQUFTQSxjQUFjNE0sS0FBSztRQUN6QyxJQUFJM0IsV0FBVzJCLE1BQU0zQixRQUFRO1FBRTdCLElBQUlyTSxJQUF5QixFQUFjO1lBQ3pDLElBQUksT0FBT3FNLGFBQWEsVUFBVTtnQkFDaEMsTUFBTWxCLE1BQU0sb0RBQW9ELCtCQUFnQyxPQUFRa0IsQ0FBQUEsYUFBYSxPQUFPLFNBQVMsT0FBT0EsUUFBTyxJQUFLLGtCQUFrQjtZQUM1SztRQUNGO0lBQ0Y7QUFDRjtBQUVBLDJCQUEyQjtBQUMzQiw2R0FBNkc7QUFDN0csU0FBU3dGLGVBQWVDLElBQUksRUFBRUMsSUFBSTtJQUNoQyxJQUFLLElBQUlDLGFBQWFGLEtBQU07UUFDMUIsSUFBSSxDQUFFRSxDQUFBQSxhQUFhRCxJQUFHLEdBQUk7WUFDeEIsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFLLElBQUlFLGNBQWNGLEtBQU07UUFDM0IsSUFBSUQsSUFBSSxDQUFDRyxXQUFXLEtBQUtGLElBQUksQ0FBQ0UsV0FBVyxFQUFFO1lBQ3pDLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztBQUNUO0FBRUEsSUFBSUMsWUFBWTtJQUFDO0NBQVEsRUFDckJDLGFBQWE7SUFBQztDQUFRO0FBQzFCLDRFQUE0RTtBQUM1RSx3REFBd0Q7QUFFeEQsU0FBU0MsU0FBU0MsU0FBUyxFQUFFN00sU0FBUztJQUNwQyxJQUFJOE0sWUFBWUQsVUFBVS9ULEtBQUssRUFDM0JpVSxXQUFXdFYsbUdBQTZCQSxDQUFDb1YsV0FBV0g7SUFFeEQsSUFBSU0sWUFBWWhOLFVBQVVsSCxLQUFLLEVBQzNCbVUsV0FBV3hWLG1HQUE2QkEsQ0FBQ3VJLFdBQVcyTTtJQUV4RCxPQUFPLENBQUNOLGVBQWVTLFdBQVdFLGNBQWMsQ0FBQ1gsZUFBZVUsVUFBVUU7QUFDNUU7QUFFQSw0RUFBNEU7QUFDNUUsMEVBQTBFO0FBRTFFLFNBQVNDLHNCQUFzQmxOLFNBQVMsRUFBRW1OLFNBQVM7SUFDakQsT0FBTyxDQUFDUCxTQUFTLElBQUksQ0FBQzdRLEtBQUssRUFBRWlFLGNBQWNxTSxlQUFlLElBQUksQ0FBQ2pRLEtBQUssRUFBRStRO0FBQ3hFO0FBRTZHLENBQzdHLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Bob3RvZWRpdGluZ2dhbWUvLi9ub2RlX21vZHVsZXMvcmVhY3Qtd2luZG93L2Rpc3QvaW5kZXguZXNtLmpzP2U4NjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkJztcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBtZW1vaXplT25lIGZyb20gJ21lbW9pemUtb25lJztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSc7XG5cbi8vIEFuaW1hdGlvbiBmcmFtZSBiYXNlZCBpbXBsZW1lbnRhdGlvbiBvZiBzZXRUaW1lb3V0LlxuLy8gSW5zcGlyZWQgYnkgSm9lIExhbWJlcnQsIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2pvZWxhbWJlcnQvMTAwMjExNiNmaWxlLXJlcXVlc3R0aW1lb3V0LWpzXG52YXIgaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG52YXIgbm93ID0gaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbn0gOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcbmZ1bmN0aW9uIGNhbmNlbFRpbWVvdXQodGltZW91dElEKSB7XG4gIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRpbWVvdXRJRC5pZCk7XG59XG5mdW5jdGlvbiByZXF1ZXN0VGltZW91dChjYWxsYmFjaywgZGVsYXkpIHtcbiAgdmFyIHN0YXJ0ID0gbm93KCk7XG5cbiAgZnVuY3Rpb24gdGljaygpIHtcbiAgICBpZiAobm93KCkgLSBzdGFydCA+PSBkZWxheSkge1xuICAgICAgY2FsbGJhY2suY2FsbChudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElELmlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0aW1lb3V0SUQgPSB7XG4gICAgaWQ6IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKVxuICB9O1xuICByZXR1cm4gdGltZW91dElEO1xufVxuXG52YXIgc2l6ZSA9IC0xOyAvLyBUaGlzIHV0aWxpdHkgY29waWVkIGZyb20gXCJkb20taGVscGVyc1wiIHBhY2thZ2UuXG5cbmZ1bmN0aW9uIGdldFNjcm9sbGJhclNpemUocmVjYWxjdWxhdGUpIHtcbiAgaWYgKHJlY2FsY3VsYXRlID09PSB2b2lkIDApIHtcbiAgICByZWNhbGN1bGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHNpemUgPT09IC0xIHx8IHJlY2FsY3VsYXRlKSB7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBzdHlsZSA9IGRpdi5zdHlsZTtcbiAgICBzdHlsZS53aWR0aCA9ICc1MHB4JztcbiAgICBzdHlsZS5oZWlnaHQgPSAnNTBweCc7XG4gICAgc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgc2l6ZSA9IGRpdi5vZmZzZXRXaWR0aCAtIGRpdi5jbGllbnRXaWR0aDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gIH1cblxuICByZXR1cm4gc2l6ZTtcbn1cbnZhciBjYWNoZWRSVExSZXN1bHQgPSBudWxsOyAvLyBUUklDS1kgQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzY3JvbGxMZWZ0IHNob3VsZCBiZSBuZWdhdGl2ZSBmb3IgUlRMIGFsaWduZWQgZWxlbWVudHMuXG4vLyBDaHJvbWUgZG9lcyBub3Qgc2VlbSB0byBhZGhlcmU7IGl0cyBzY3JvbGxMZWZ0IHZhbHVlcyBhcmUgcG9zaXRpdmUgKG1lYXN1cmVkIHJlbGF0aXZlIHRvIHRoZSBsZWZ0KS5cbi8vIFNhZmFyaSdzIGVsYXN0aWMgYm91bmNlIG1ha2VzIGRldGVjdGluZyB0aGlzIGV2ZW4gbW9yZSBjb21wbGljYXRlZCB3cnQgcG90ZW50aWFsIGZhbHNlIHBvc2l0aXZlcy5cbi8vIFRoZSBzYWZlc3Qgd2F5IHRvIGNoZWNrIHRoaXMgaXMgdG8gaW50ZW50aW9uYWxseSBzZXQgYSBuZWdhdGl2ZSBvZmZzZXQsXG4vLyBhbmQgdGhlbiB2ZXJpZnkgdGhhdCB0aGUgc3Vic2VxdWVudCBcInNjcm9sbFwiIGV2ZW50IG1hdGNoZXMgdGhlIG5lZ2F0aXZlIG9mZnNldC5cbi8vIElmIGl0IGRvZXMgbm90IG1hdGNoLCB0aGVuIHdlIGNhbiBhc3N1bWUgYSBub24tc3RhbmRhcmQgUlRMIHNjcm9sbCBpbXBsZW1lbnRhdGlvbi5cblxuZnVuY3Rpb24gZ2V0UlRMT2Zmc2V0VHlwZShyZWNhbGN1bGF0ZSkge1xuICBpZiAocmVjYWxjdWxhdGUgPT09IHZvaWQgMCkge1xuICAgIHJlY2FsY3VsYXRlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoY2FjaGVkUlRMUmVzdWx0ID09PSBudWxsIHx8IHJlY2FsY3VsYXRlKSB7XG4gICAgdmFyIG91dGVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIG91dGVyU3R5bGUgPSBvdXRlckRpdi5zdHlsZTtcbiAgICBvdXRlclN0eWxlLndpZHRoID0gJzUwcHgnO1xuICAgIG91dGVyU3R5bGUuaGVpZ2h0ID0gJzUwcHgnO1xuICAgIG91dGVyU3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICBvdXRlclN0eWxlLmRpcmVjdGlvbiA9ICdydGwnO1xuICAgIHZhciBpbm5lckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBpbm5lclN0eWxlID0gaW5uZXJEaXYuc3R5bGU7XG4gICAgaW5uZXJTdHlsZS53aWR0aCA9ICcxMDBweCc7XG4gICAgaW5uZXJTdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xuICAgIG91dGVyRGl2LmFwcGVuZENoaWxkKGlubmVyRGl2KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyRGl2KTtcblxuICAgIGlmIChvdXRlckRpdi5zY3JvbGxMZWZ0ID4gMCkge1xuICAgICAgY2FjaGVkUlRMUmVzdWx0ID0gJ3Bvc2l0aXZlLWRlc2NlbmRpbmcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRlckRpdi5zY3JvbGxMZWZ0ID0gMTtcblxuICAgICAgaWYgKG91dGVyRGl2LnNjcm9sbExlZnQgPT09IDApIHtcbiAgICAgICAgY2FjaGVkUlRMUmVzdWx0ID0gJ25lZ2F0aXZlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlZFJUTFJlc3VsdCA9ICdwb3NpdGl2ZS1hc2NlbmRpbmcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3V0ZXJEaXYpO1xuICAgIHJldHVybiBjYWNoZWRSVExSZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gY2FjaGVkUlRMUmVzdWx0O1xufVxuXG52YXIgSVNfU0NST0xMSU5HX0RFQk9VTkNFX0lOVEVSVkFMID0gMTUwO1xuXG52YXIgZGVmYXVsdEl0ZW1LZXkgPSBmdW5jdGlvbiBkZWZhdWx0SXRlbUtleShfcmVmKSB7XG4gIHZhciBjb2x1bW5JbmRleCA9IF9yZWYuY29sdW1uSW5kZXgsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgcm93SW5kZXggPSBfcmVmLnJvd0luZGV4O1xuICByZXR1cm4gcm93SW5kZXggKyBcIjpcIiArIGNvbHVtbkluZGV4O1xufTsgLy8gSW4gREVWIG1vZGUsIHRoaXMgU2V0IGhlbHBzIHVzIG9ubHkgbG9nIGEgd2FybmluZyBvbmNlIHBlciBjb21wb25lbnQgaW5zdGFuY2UuXG4vLyBUaGlzIGF2b2lkcyBzcGFtbWluZyB0aGUgY29uc29sZSBldmVyeSB0aW1lIGEgcmVuZGVyIGhhcHBlbnMuXG5cblxudmFyIGRldldhcm5pbmdzT3ZlcnNjYW5Db3VudCA9IG51bGw7XG52YXIgZGV2V2FybmluZ3NPdmVyc2NhblJvd3NDb2x1bW5zQ291bnQgPSBudWxsO1xudmFyIGRldldhcm5pbmdzVGFnTmFtZSA9IG51bGw7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LldlYWtTZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGV2V2FybmluZ3NPdmVyc2NhbkNvdW50ID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG4gICAgZGV2V2FybmluZ3NPdmVyc2NhblJvd3NDb2x1bW5zQ291bnQgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtTZXQoKTtcbiAgICBkZXZXYXJuaW5nc1RhZ05hbWUgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtTZXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVHcmlkQ29tcG9uZW50KF9yZWYyKSB7XG4gIHZhciBfY2xhc3M7XG5cbiAgdmFyIGdldENvbHVtbk9mZnNldCA9IF9yZWYyLmdldENvbHVtbk9mZnNldCxcbiAgICAgIGdldENvbHVtblN0YXJ0SW5kZXhGb3JPZmZzZXQgPSBfcmVmMi5nZXRDb2x1bW5TdGFydEluZGV4Rm9yT2Zmc2V0LFxuICAgICAgZ2V0Q29sdW1uU3RvcEluZGV4Rm9yU3RhcnRJbmRleCA9IF9yZWYyLmdldENvbHVtblN0b3BJbmRleEZvclN0YXJ0SW5kZXgsXG4gICAgICBnZXRDb2x1bW5XaWR0aCA9IF9yZWYyLmdldENvbHVtbldpZHRoLFxuICAgICAgZ2V0RXN0aW1hdGVkVG90YWxIZWlnaHQgPSBfcmVmMi5nZXRFc3RpbWF0ZWRUb3RhbEhlaWdodCxcbiAgICAgIGdldEVzdGltYXRlZFRvdGFsV2lkdGggPSBfcmVmMi5nZXRFc3RpbWF0ZWRUb3RhbFdpZHRoLFxuICAgICAgZ2V0T2Zmc2V0Rm9yQ29sdW1uQW5kQWxpZ25tZW50ID0gX3JlZjIuZ2V0T2Zmc2V0Rm9yQ29sdW1uQW5kQWxpZ25tZW50LFxuICAgICAgZ2V0T2Zmc2V0Rm9yUm93QW5kQWxpZ25tZW50ID0gX3JlZjIuZ2V0T2Zmc2V0Rm9yUm93QW5kQWxpZ25tZW50LFxuICAgICAgZ2V0Um93SGVpZ2h0ID0gX3JlZjIuZ2V0Um93SGVpZ2h0LFxuICAgICAgZ2V0Um93T2Zmc2V0ID0gX3JlZjIuZ2V0Um93T2Zmc2V0LFxuICAgICAgZ2V0Um93U3RhcnRJbmRleEZvck9mZnNldCA9IF9yZWYyLmdldFJvd1N0YXJ0SW5kZXhGb3JPZmZzZXQsXG4gICAgICBnZXRSb3dTdG9wSW5kZXhGb3JTdGFydEluZGV4ID0gX3JlZjIuZ2V0Um93U3RvcEluZGV4Rm9yU3RhcnRJbmRleCxcbiAgICAgIGluaXRJbnN0YW5jZVByb3BzID0gX3JlZjIuaW5pdEluc3RhbmNlUHJvcHMsXG4gICAgICBzaG91bGRSZXNldFN0eWxlQ2FjaGVPbkl0ZW1TaXplQ2hhbmdlID0gX3JlZjIuc2hvdWxkUmVzZXRTdHlsZUNhY2hlT25JdGVtU2l6ZUNoYW5nZSxcbiAgICAgIHZhbGlkYXRlUHJvcHMgPSBfcmVmMi52YWxpZGF0ZVByb3BzO1xuICByZXR1cm4gX2NsYXNzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKEdyaWQsIF9QdXJlQ29tcG9uZW50KTtcblxuICAgIC8vIEFsd2F5cyB1c2UgZXhwbGljaXQgY29uc3RydWN0b3IgZm9yIFJlYWN0IGNvbXBvbmVudHMuXG4gICAgLy8gSXQgcHJvZHVjZXMgbGVzcyBjb2RlIGFmdGVyIHRyYW5zcGlsYXRpb24uICgjMjYpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY29uc3RydWN0b3JcbiAgICBmdW5jdGlvbiBHcmlkKHByb3BzKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX1B1cmVDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgIF90aGlzLl9pbnN0YW5jZVByb3BzID0gaW5pdEluc3RhbmNlUHJvcHMoX3RoaXMucHJvcHMsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIF90aGlzLl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkID0gbnVsbDtcbiAgICAgIF90aGlzLl9vdXRlclJlZiA9IHZvaWQgMDtcbiAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICBpbnN0YW5jZTogX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksXG4gICAgICAgIGlzU2Nyb2xsaW5nOiBmYWxzZSxcbiAgICAgICAgaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbjogJ2ZvcndhcmQnLFxuICAgICAgICBzY3JvbGxMZWZ0OiB0eXBlb2YgX3RoaXMucHJvcHMuaW5pdGlhbFNjcm9sbExlZnQgPT09ICdudW1iZXInID8gX3RoaXMucHJvcHMuaW5pdGlhbFNjcm9sbExlZnQgOiAwLFxuICAgICAgICBzY3JvbGxUb3A6IHR5cGVvZiBfdGhpcy5wcm9wcy5pbml0aWFsU2Nyb2xsVG9wID09PSAnbnVtYmVyJyA/IF90aGlzLnByb3BzLmluaXRpYWxTY3JvbGxUb3AgOiAwLFxuICAgICAgICBzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQ6IGZhbHNlLFxuICAgICAgICB2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbjogJ2ZvcndhcmQnXG4gICAgICB9O1xuICAgICAgX3RoaXMuX2NhbGxPbkl0ZW1zUmVuZGVyZWQgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5fY2FsbE9uSXRlbXNSZW5kZXJlZCA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKG92ZXJzY2FuQ29sdW1uU3RhcnRJbmRleCwgb3ZlcnNjYW5Db2x1bW5TdG9wSW5kZXgsIG92ZXJzY2FuUm93U3RhcnRJbmRleCwgb3ZlcnNjYW5Sb3dTdG9wSW5kZXgsIHZpc2libGVDb2x1bW5TdGFydEluZGV4LCB2aXNpYmxlQ29sdW1uU3RvcEluZGV4LCB2aXNpYmxlUm93U3RhcnRJbmRleCwgdmlzaWJsZVJvd1N0b3BJbmRleCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMub25JdGVtc1JlbmRlcmVkKHtcbiAgICAgICAgICBvdmVyc2NhbkNvbHVtblN0YXJ0SW5kZXg6IG92ZXJzY2FuQ29sdW1uU3RhcnRJbmRleCxcbiAgICAgICAgICBvdmVyc2NhbkNvbHVtblN0b3BJbmRleDogb3ZlcnNjYW5Db2x1bW5TdG9wSW5kZXgsXG4gICAgICAgICAgb3ZlcnNjYW5Sb3dTdGFydEluZGV4OiBvdmVyc2NhblJvd1N0YXJ0SW5kZXgsXG4gICAgICAgICAgb3ZlcnNjYW5Sb3dTdG9wSW5kZXg6IG92ZXJzY2FuUm93U3RvcEluZGV4LFxuICAgICAgICAgIHZpc2libGVDb2x1bW5TdGFydEluZGV4OiB2aXNpYmxlQ29sdW1uU3RhcnRJbmRleCxcbiAgICAgICAgICB2aXNpYmxlQ29sdW1uU3RvcEluZGV4OiB2aXNpYmxlQ29sdW1uU3RvcEluZGV4LFxuICAgICAgICAgIHZpc2libGVSb3dTdGFydEluZGV4OiB2aXNpYmxlUm93U3RhcnRJbmRleCxcbiAgICAgICAgICB2aXNpYmxlUm93U3RvcEluZGV4OiB2aXNpYmxlUm93U3RvcEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5fY2FsbE9uU2Nyb2xsID0gdm9pZCAwO1xuICAgICAgX3RoaXMuX2NhbGxPblNjcm9sbCA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKHNjcm9sbExlZnQsIHNjcm9sbFRvcCwgaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiwgdmVydGljYWxTY3JvbGxEaXJlY3Rpb24sIHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMub25TY3JvbGwoe1xuICAgICAgICAgIGhvcml6b250YWxTY3JvbGxEaXJlY3Rpb246IGhvcml6b250YWxTY3JvbGxEaXJlY3Rpb24sXG4gICAgICAgICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICAgICAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcCxcbiAgICAgICAgICB2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbjogdmVydGljYWxTY3JvbGxEaXJlY3Rpb24sXG4gICAgICAgICAgc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkOiBzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLl9nZXRJdGVtU3R5bGUgPSB2b2lkIDA7XG5cbiAgICAgIF90aGlzLl9nZXRJdGVtU3R5bGUgPSBmdW5jdGlvbiAocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgY29sdW1uV2lkdGggPSBfdGhpcyRwcm9wcy5jb2x1bW5XaWR0aCxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IF90aGlzJHByb3BzLmRpcmVjdGlvbixcbiAgICAgICAgICAgIHJvd0hlaWdodCA9IF90aGlzJHByb3BzLnJvd0hlaWdodDtcblxuICAgICAgICB2YXIgaXRlbVN0eWxlQ2FjaGUgPSBfdGhpcy5fZ2V0SXRlbVN0eWxlQ2FjaGUoc2hvdWxkUmVzZXRTdHlsZUNhY2hlT25JdGVtU2l6ZUNoYW5nZSAmJiBjb2x1bW5XaWR0aCwgc2hvdWxkUmVzZXRTdHlsZUNhY2hlT25JdGVtU2l6ZUNoYW5nZSAmJiBkaXJlY3Rpb24sIHNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2UgJiYgcm93SGVpZ2h0KTtcblxuICAgICAgICB2YXIga2V5ID0gcm93SW5kZXggKyBcIjpcIiArIGNvbHVtbkluZGV4O1xuICAgICAgICB2YXIgc3R5bGU7XG5cbiAgICAgICAgaWYgKGl0ZW1TdHlsZUNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBzdHlsZSA9IGl0ZW1TdHlsZUNhY2hlW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9vZmZzZXQgPSBnZXRDb2x1bW5PZmZzZXQoX3RoaXMucHJvcHMsIGNvbHVtbkluZGV4LCBfdGhpcy5faW5zdGFuY2VQcm9wcyk7XG5cbiAgICAgICAgICB2YXIgaXNSdGwgPSBkaXJlY3Rpb24gPT09ICdydGwnO1xuICAgICAgICAgIGl0ZW1TdHlsZUNhY2hlW2tleV0gPSBzdHlsZSA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgbGVmdDogaXNSdGwgPyB1bmRlZmluZWQgOiBfb2Zmc2V0LFxuICAgICAgICAgICAgcmlnaHQ6IGlzUnRsID8gX29mZnNldCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRvcDogZ2V0Um93T2Zmc2V0KF90aGlzLnByb3BzLCByb3dJbmRleCwgX3RoaXMuX2luc3RhbmNlUHJvcHMpLFxuICAgICAgICAgICAgaGVpZ2h0OiBnZXRSb3dIZWlnaHQoX3RoaXMucHJvcHMsIHJvd0luZGV4LCBfdGhpcy5faW5zdGFuY2VQcm9wcyksXG4gICAgICAgICAgICB3aWR0aDogZ2V0Q29sdW1uV2lkdGgoX3RoaXMucHJvcHMsIGNvbHVtbkluZGV4LCBfdGhpcy5faW5zdGFuY2VQcm9wcylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuX2dldEl0ZW1TdHlsZUNhY2hlID0gdm9pZCAwO1xuICAgICAgX3RoaXMuX2dldEl0ZW1TdHlsZUNhY2hlID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoXywgX18sIF9fXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9KTtcblxuICAgICAgX3RoaXMuX29uU2Nyb2xsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfZXZlbnQkY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICBjbGllbnRIZWlnaHQgPSBfZXZlbnQkY3VycmVudFRhcmdldC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICBjbGllbnRXaWR0aCA9IF9ldmVudCRjdXJyZW50VGFyZ2V0LmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IF9ldmVudCRjdXJyZW50VGFyZ2V0LnNjcm9sbExlZnQsXG4gICAgICAgICAgICBzY3JvbGxUb3AgPSBfZXZlbnQkY3VycmVudFRhcmdldC5zY3JvbGxUb3AsXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSBfZXZlbnQkY3VycmVudFRhcmdldC5zY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICBzY3JvbGxXaWR0aCA9IF9ldmVudCRjdXJyZW50VGFyZ2V0LnNjcm9sbFdpZHRoO1xuXG4gICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgICAgICBpZiAocHJldlN0YXRlLnNjcm9sbExlZnQgPT09IHNjcm9sbExlZnQgJiYgcHJldlN0YXRlLnNjcm9sbFRvcCA9PT0gc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAvLyBTY3JvbGwgcG9zaXRpb24gbWF5IGhhdmUgYmVlbiB1cGRhdGVkIGJ5IGNETS9jRFUsXG4gICAgICAgICAgICAvLyBJbiB3aGljaCBjYXNlIHdlIGRvbid0IG5lZWQgdG8gdHJpZ2dlciBhbm90aGVyIHJlbmRlcixcbiAgICAgICAgICAgIC8vIEFuZCB3ZSBkb24ndCB3YW50IHRvIHVwZGF0ZSBzdGF0ZS5pc1Njcm9sbGluZy5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBfdGhpcy5wcm9wcy5kaXJlY3Rpb247IC8vIFRSSUNLWSBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNjcm9sbExlZnQgc2hvdWxkIGJlIG5lZ2F0aXZlIGZvciBSVEwgYWxpZ25lZCBlbGVtZW50cy5cbiAgICAgICAgICAvLyBUaGlzIGlzIG5vdCB0aGUgY2FzZSBmb3IgYWxsIGJyb3dzZXJzIHRob3VnaCAoZS5nLiBDaHJvbWUgcmVwb3J0cyB2YWx1ZXMgYXMgcG9zaXRpdmUsIG1lYXN1cmVkIHJlbGF0aXZlIHRvIHRoZSBsZWZ0KS5cbiAgICAgICAgICAvLyBJdCdzIGFsc28gZWFzaWVyIGZvciB0aGlzIGNvbXBvbmVudCBpZiB3ZSBjb252ZXJ0IG9mZnNldHMgdG8gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZXkgd291bGQgYmUgaW4gZm9yIGx0ci5cbiAgICAgICAgICAvLyBTbyB0aGUgc2ltcGxlc3Qgc29sdXRpb24gaXMgdG8gZGV0ZXJtaW5lIHdoaWNoIGJyb3dzZXIgYmVoYXZpb3Igd2UncmUgZGVhbGluZyB3aXRoLCBhbmQgY29udmVydCBiYXNlZCBvbiBpdC5cblxuICAgICAgICAgIHZhciBjYWxjdWxhdGVkU2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgc3dpdGNoIChnZXRSVExPZmZzZXRUeXBlKCkpIHtcbiAgICAgICAgICAgICAgY2FzZSAnbmVnYXRpdmUnOlxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRTY3JvbGxMZWZ0ID0gLXNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAncG9zaXRpdmUtZGVzY2VuZGluZyc6XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFNjcm9sbExlZnQgPSBzY3JvbGxXaWR0aCAtIGNsaWVudFdpZHRoIC0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFByZXZlbnQgU2FmYXJpJ3MgZWxhc3RpYyBzY3JvbGxpbmcgZnJvbSBjYXVzaW5nIHZpc3VhbCBzaGFraW5nIHdoZW4gc2Nyb2xsaW5nIHBhc3QgYm91bmRzLlxuXG5cbiAgICAgICAgICBjYWxjdWxhdGVkU2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNhbGN1bGF0ZWRTY3JvbGxMZWZ0LCBzY3JvbGxXaWR0aCAtIGNsaWVudFdpZHRoKSk7XG4gICAgICAgICAgdmFyIGNhbGN1bGF0ZWRTY3JvbGxUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCAtIGNsaWVudEhlaWdodCkpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1Njcm9sbGluZzogdHJ1ZSxcbiAgICAgICAgICAgIGhvcml6b250YWxTY3JvbGxEaXJlY3Rpb246IHByZXZTdGF0ZS5zY3JvbGxMZWZ0IDwgc2Nyb2xsTGVmdCA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCcsXG4gICAgICAgICAgICBzY3JvbGxMZWZ0OiBjYWxjdWxhdGVkU2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbFRvcDogY2FsY3VsYXRlZFNjcm9sbFRvcCxcbiAgICAgICAgICAgIHZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uOiBwcmV2U3RhdGUuc2Nyb2xsVG9wIDwgc2Nyb2xsVG9wID8gJ2ZvcndhcmQnIDogJ2JhY2t3YXJkJyxcbiAgICAgICAgICAgIHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBfdGhpcy5fcmVzZXRJc1Njcm9sbGluZ0RlYm91bmNlZCk7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5fb3V0ZXJSZWZTZXR0ZXIgPSBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBvdXRlclJlZiA9IF90aGlzLnByb3BzLm91dGVyUmVmO1xuICAgICAgICBfdGhpcy5fb3V0ZXJSZWYgPSByZWY7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvdXRlclJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG91dGVyUmVmKHJlZik7XG4gICAgICAgIH0gZWxzZSBpZiAob3V0ZXJSZWYgIT0gbnVsbCAmJiB0eXBlb2Ygb3V0ZXJSZWYgPT09ICdvYmplY3QnICYmIG91dGVyUmVmLmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgICBvdXRlclJlZi5jdXJyZW50ID0gcmVmO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5fcmVzZXRJc1Njcm9sbGluZ0RlYm91bmNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgY2FuY2VsVGltZW91dChfdGhpcy5fcmVzZXRJc1Njcm9sbGluZ1RpbWVvdXRJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5fcmVzZXRJc1Njcm9sbGluZ1RpbWVvdXRJZCA9IHJlcXVlc3RUaW1lb3V0KF90aGlzLl9yZXNldElzU2Nyb2xsaW5nLCBJU19TQ1JPTExJTkdfREVCT1VOQ0VfSU5URVJWQUwpO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaXNTY3JvbGxpbmc6IGZhbHNlXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBDbGVhciBzdHlsZSBjYWNoZSBhZnRlciBzdGF0ZSB1cGRhdGUgaGFzIGJlZW4gY29tbWl0dGVkLlxuICAgICAgICAgIC8vIFRoaXMgd2F5IHdlIGRvbid0IGJyZWFrIHB1cmUgc0NVIGZvciBpdGVtcyB0aGF0IGRvbid0IHVzZSBpc1Njcm9sbGluZyBwYXJhbS5cbiAgICAgICAgICBfdGhpcy5fZ2V0SXRlbVN0eWxlQ2FjaGUoLTEpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBHcmlkLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgdmFsaWRhdGVTaGFyZWRQcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICB2YWxpZGF0ZVByb3BzKG5leHRQcm9wcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIF9wcm90byA9IEdyaWQucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNjcm9sbFRvID0gZnVuY3Rpb24gc2Nyb2xsVG8oX3JlZjMpIHtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gX3JlZjMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICBzY3JvbGxUb3AgPSBfcmVmMy5zY3JvbGxUb3A7XG5cbiAgICAgIGlmIChzY3JvbGxMZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIHNjcm9sbExlZnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2Nyb2xsVG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgc2Nyb2xsVG9wKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICAgIGlmIChzY3JvbGxMZWZ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzY3JvbGxMZWZ0ID0gcHJldlN0YXRlLnNjcm9sbExlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Nyb2xsVG9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzY3JvbGxUb3AgPSBwcmV2U3RhdGUuc2Nyb2xsVG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZTdGF0ZS5zY3JvbGxMZWZ0ID09PSBzY3JvbGxMZWZ0ICYmIHByZXZTdGF0ZS5zY3JvbGxUb3AgPT09IHNjcm9sbFRvcCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uOiBwcmV2U3RhdGUuc2Nyb2xsTGVmdCA8IHNjcm9sbExlZnQgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnLFxuICAgICAgICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3AsXG4gICAgICAgICAgc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkOiB0cnVlLFxuICAgICAgICAgIHZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uOiBwcmV2U3RhdGUuc2Nyb2xsVG9wIDwgc2Nyb2xsVG9wID8gJ2ZvcndhcmQnIDogJ2JhY2t3YXJkJ1xuICAgICAgICB9O1xuICAgICAgfSwgdGhpcy5fcmVzZXRJc1Njcm9sbGluZ0RlYm91bmNlZCk7XG4gICAgfTtcblxuICAgIF9wcm90by5zY3JvbGxUb0l0ZW0gPSBmdW5jdGlvbiBzY3JvbGxUb0l0ZW0oX3JlZjQpIHtcbiAgICAgIHZhciBfcmVmNCRhbGlnbiA9IF9yZWY0LmFsaWduLFxuICAgICAgICAgIGFsaWduID0gX3JlZjQkYWxpZ24gPT09IHZvaWQgMCA/ICdhdXRvJyA6IF9yZWY0JGFsaWduLFxuICAgICAgICAgIGNvbHVtbkluZGV4ID0gX3JlZjQuY29sdW1uSW5kZXgsXG4gICAgICAgICAgcm93SW5kZXggPSBfcmVmNC5yb3dJbmRleDtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNvbHVtbkNvdW50ID0gX3RoaXMkcHJvcHMyLmNvbHVtbkNvdW50LFxuICAgICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzMi5oZWlnaHQsXG4gICAgICAgICAgcm93Q291bnQgPSBfdGhpcyRwcm9wczIucm93Q291bnQsXG4gICAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczIud2lkdGg7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICAgIHNjcm9sbExlZnQgPSBfdGhpcyRzdGF0ZS5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHNjcm9sbFRvcCA9IF90aGlzJHN0YXRlLnNjcm9sbFRvcDtcbiAgICAgIHZhciBzY3JvbGxiYXJTaXplID0gZ2V0U2Nyb2xsYmFyU2l6ZSgpO1xuXG4gICAgICBpZiAoY29sdW1uSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2x1bW5JbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNvbHVtbkluZGV4LCBjb2x1bW5Db3VudCAtIDEpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvd0luZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm93SW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihyb3dJbmRleCwgcm93Q291bnQgLSAxKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlc3RpbWF0ZWRUb3RhbEhlaWdodCA9IGdldEVzdGltYXRlZFRvdGFsSGVpZ2h0KHRoaXMucHJvcHMsIHRoaXMuX2luc3RhbmNlUHJvcHMpO1xuICAgICAgdmFyIGVzdGltYXRlZFRvdGFsV2lkdGggPSBnZXRFc3RpbWF0ZWRUb3RhbFdpZHRoKHRoaXMucHJvcHMsIHRoaXMuX2luc3RhbmNlUHJvcHMpOyAvLyBUaGUgc2Nyb2xsYmFyIHNpemUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgd2hlbiBzY3JvbGxpbmcgYW4gaXRlbSBpbnRvIHZpZXcsXG4gICAgICAvLyB0byBlbnN1cmUgaXQncyBmdWxseSB2aXNpYmxlLlxuICAgICAgLy8gQnV0IHdlIG9ubHkgbmVlZCB0byBhY2NvdW50IGZvciBpdHMgc2l6ZSB3aGVuIGl0J3MgYWN0dWFsbHkgdmlzaWJsZS5cblxuICAgICAgdmFyIGhvcml6b250YWxTY3JvbGxiYXJTaXplID0gZXN0aW1hdGVkVG90YWxXaWR0aCA+IHdpZHRoID8gc2Nyb2xsYmFyU2l6ZSA6IDA7XG4gICAgICB2YXIgdmVydGljYWxTY3JvbGxiYXJTaXplID0gZXN0aW1hdGVkVG90YWxIZWlnaHQgPiBoZWlnaHQgPyBzY3JvbGxiYXJTaXplIDogMDtcbiAgICAgIHRoaXMuc2Nyb2xsVG8oe1xuICAgICAgICBzY3JvbGxMZWZ0OiBjb2x1bW5JbmRleCAhPT0gdW5kZWZpbmVkID8gZ2V0T2Zmc2V0Rm9yQ29sdW1uQW5kQWxpZ25tZW50KHRoaXMucHJvcHMsIGNvbHVtbkluZGV4LCBhbGlnbiwgc2Nyb2xsTGVmdCwgdGhpcy5faW5zdGFuY2VQcm9wcywgdmVydGljYWxTY3JvbGxiYXJTaXplKSA6IHNjcm9sbExlZnQsXG4gICAgICAgIHNjcm9sbFRvcDogcm93SW5kZXggIT09IHVuZGVmaW5lZCA/IGdldE9mZnNldEZvclJvd0FuZEFsaWdubWVudCh0aGlzLnByb3BzLCByb3dJbmRleCwgYWxpZ24sIHNjcm9sbFRvcCwgdGhpcy5faW5zdGFuY2VQcm9wcywgaG9yaXpvbnRhbFNjcm9sbGJhclNpemUpIDogc2Nyb2xsVG9wXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBpbml0aWFsU2Nyb2xsTGVmdCA9IF90aGlzJHByb3BzMy5pbml0aWFsU2Nyb2xsTGVmdCxcbiAgICAgICAgICBpbml0aWFsU2Nyb2xsVG9wID0gX3RoaXMkcHJvcHMzLmluaXRpYWxTY3JvbGxUb3A7XG5cbiAgICAgIGlmICh0aGlzLl9vdXRlclJlZiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvdXRlclJlZiA9IHRoaXMuX291dGVyUmVmO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFNjcm9sbExlZnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb3V0ZXJSZWYuc2Nyb2xsTGVmdCA9IGluaXRpYWxTY3JvbGxMZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsU2Nyb2xsVG9wID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG91dGVyUmVmLnNjcm9sbFRvcCA9IGluaXRpYWxTY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FsbFByb3BzQ2FsbGJhY2tzKCk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5wcm9wcy5kaXJlY3Rpb247XG4gICAgICB2YXIgX3RoaXMkc3RhdGUyID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICBzY3JvbGxMZWZ0ID0gX3RoaXMkc3RhdGUyLnNjcm9sbExlZnQsXG4gICAgICAgICAgc2Nyb2xsVG9wID0gX3RoaXMkc3RhdGUyLnNjcm9sbFRvcCxcbiAgICAgICAgICBzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQgPSBfdGhpcyRzdGF0ZTIuc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkO1xuXG4gICAgICBpZiAoc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkICYmIHRoaXMuX291dGVyUmVmICE9IG51bGwpIHtcbiAgICAgICAgLy8gVFJJQ0tZIEFjY29yZGluZyB0byB0aGUgc3BlYywgc2Nyb2xsTGVmdCBzaG91bGQgYmUgbmVnYXRpdmUgZm9yIFJUTCBhbGlnbmVkIGVsZW1lbnRzLlxuICAgICAgICAvLyBUaGlzIGlzIG5vdCB0aGUgY2FzZSBmb3IgYWxsIGJyb3dzZXJzIHRob3VnaCAoZS5nLiBDaHJvbWUgcmVwb3J0cyB2YWx1ZXMgYXMgcG9zaXRpdmUsIG1lYXN1cmVkIHJlbGF0aXZlIHRvIHRoZSBsZWZ0KS5cbiAgICAgICAgLy8gU28gd2UgbmVlZCB0byBkZXRlcm1pbmUgd2hpY2ggYnJvd3NlciBiZWhhdmlvciB3ZSdyZSBkZWFsaW5nIHdpdGgsIGFuZCBtaW1pYyBpdC5cbiAgICAgICAgdmFyIG91dGVyUmVmID0gdGhpcy5fb3V0ZXJSZWY7XG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgICBzd2l0Y2ggKGdldFJUTE9mZnNldFR5cGUoKSkge1xuICAgICAgICAgICAgY2FzZSAnbmVnYXRpdmUnOlxuICAgICAgICAgICAgICBvdXRlclJlZi5zY3JvbGxMZWZ0ID0gLXNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdwb3NpdGl2ZS1hc2NlbmRpbmcnOlxuICAgICAgICAgICAgICBvdXRlclJlZi5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHZhciBjbGllbnRXaWR0aCA9IG91dGVyUmVmLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgc2Nyb2xsV2lkdGggPSBvdXRlclJlZi5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgICAgb3V0ZXJSZWYuc2Nyb2xsTGVmdCA9IHNjcm9sbFdpZHRoIC0gY2xpZW50V2lkdGggLSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ZXJSZWYuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIHNjcm9sbExlZnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ZXJSZWYuc2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgc2Nyb2xsVG9wKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FsbFByb3BzQ2FsbGJhY2tzKCk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuX3Jlc2V0SXNTY3JvbGxpbmdUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgY2FuY2VsVGltZW91dCh0aGlzLl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHM0LmNoaWxkcmVuLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNC5jbGFzc05hbWUsXG4gICAgICAgICAgY29sdW1uQ291bnQgPSBfdGhpcyRwcm9wczQuY29sdW1uQ291bnQsXG4gICAgICAgICAgZGlyZWN0aW9uID0gX3RoaXMkcHJvcHM0LmRpcmVjdGlvbixcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczQuaGVpZ2h0LFxuICAgICAgICAgIGlubmVyUmVmID0gX3RoaXMkcHJvcHM0LmlubmVyUmVmLFxuICAgICAgICAgIGlubmVyRWxlbWVudFR5cGUgPSBfdGhpcyRwcm9wczQuaW5uZXJFbGVtZW50VHlwZSxcbiAgICAgICAgICBpbm5lclRhZ05hbWUgPSBfdGhpcyRwcm9wczQuaW5uZXJUYWdOYW1lLFxuICAgICAgICAgIGl0ZW1EYXRhID0gX3RoaXMkcHJvcHM0Lml0ZW1EYXRhLFxuICAgICAgICAgIF90aGlzJHByb3BzNCRpdGVtS2V5ID0gX3RoaXMkcHJvcHM0Lml0ZW1LZXksXG4gICAgICAgICAgaXRlbUtleSA9IF90aGlzJHByb3BzNCRpdGVtS2V5ID09PSB2b2lkIDAgPyBkZWZhdWx0SXRlbUtleSA6IF90aGlzJHByb3BzNCRpdGVtS2V5LFxuICAgICAgICAgIG91dGVyRWxlbWVudFR5cGUgPSBfdGhpcyRwcm9wczQub3V0ZXJFbGVtZW50VHlwZSxcbiAgICAgICAgICBvdXRlclRhZ05hbWUgPSBfdGhpcyRwcm9wczQub3V0ZXJUYWdOYW1lLFxuICAgICAgICAgIHJvd0NvdW50ID0gX3RoaXMkcHJvcHM0LnJvd0NvdW50LFxuICAgICAgICAgIHN0eWxlID0gX3RoaXMkcHJvcHM0LnN0eWxlLFxuICAgICAgICAgIHVzZUlzU2Nyb2xsaW5nID0gX3RoaXMkcHJvcHM0LnVzZUlzU2Nyb2xsaW5nLFxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM0LndpZHRoO1xuICAgICAgdmFyIGlzU2Nyb2xsaW5nID0gdGhpcy5zdGF0ZS5pc1Njcm9sbGluZztcblxuICAgICAgdmFyIF90aGlzJF9nZXRIb3Jpem9udGFsUiA9IHRoaXMuX2dldEhvcml6b250YWxSYW5nZVRvUmVuZGVyKCksXG4gICAgICAgICAgY29sdW1uU3RhcnRJbmRleCA9IF90aGlzJF9nZXRIb3Jpem9udGFsUlswXSxcbiAgICAgICAgICBjb2x1bW5TdG9wSW5kZXggPSBfdGhpcyRfZ2V0SG9yaXpvbnRhbFJbMV07XG5cbiAgICAgIHZhciBfdGhpcyRfZ2V0VmVydGljYWxSYW4gPSB0aGlzLl9nZXRWZXJ0aWNhbFJhbmdlVG9SZW5kZXIoKSxcbiAgICAgICAgICByb3dTdGFydEluZGV4ID0gX3RoaXMkX2dldFZlcnRpY2FsUmFuWzBdLFxuICAgICAgICAgIHJvd1N0b3BJbmRleCA9IF90aGlzJF9nZXRWZXJ0aWNhbFJhblsxXTtcblxuICAgICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICAgIGlmIChjb2x1bW5Db3VudCA+IDAgJiYgcm93Q291bnQpIHtcbiAgICAgICAgZm9yICh2YXIgX3Jvd0luZGV4ID0gcm93U3RhcnRJbmRleDsgX3Jvd0luZGV4IDw9IHJvd1N0b3BJbmRleDsgX3Jvd0luZGV4KyspIHtcbiAgICAgICAgICBmb3IgKHZhciBfY29sdW1uSW5kZXggPSBjb2x1bW5TdGFydEluZGV4OyBfY29sdW1uSW5kZXggPD0gY29sdW1uU3RvcEluZGV4OyBfY29sdW1uSW5kZXgrKykge1xuICAgICAgICAgICAgaXRlbXMucHVzaChjcmVhdGVFbGVtZW50KGNoaWxkcmVuLCB7XG4gICAgICAgICAgICAgIGNvbHVtbkluZGV4OiBfY29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgIGRhdGE6IGl0ZW1EYXRhLFxuICAgICAgICAgICAgICBpc1Njcm9sbGluZzogdXNlSXNTY3JvbGxpbmcgPyBpc1Njcm9sbGluZyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAga2V5OiBpdGVtS2V5KHtcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDogX2NvbHVtbkluZGV4LFxuICAgICAgICAgICAgICAgIGRhdGE6IGl0ZW1EYXRhLFxuICAgICAgICAgICAgICAgIHJvd0luZGV4OiBfcm93SW5kZXhcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIHJvd0luZGV4OiBfcm93SW5kZXgsXG4gICAgICAgICAgICAgIHN0eWxlOiB0aGlzLl9nZXRJdGVtU3R5bGUoX3Jvd0luZGV4LCBfY29sdW1uSW5kZXgpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIFJlYWQgdGhpcyB2YWx1ZSBBRlRFUiBpdGVtcyBoYXZlIGJlZW4gY3JlYXRlZCxcbiAgICAgIC8vIFNvIHRoZWlyIGFjdHVhbCBzaXplcyAoaWYgdmFyaWFibGUpIGFyZSB0YWtlbiBpbnRvIGNvbnNpZGVyYXRpb24uXG5cblxuICAgICAgdmFyIGVzdGltYXRlZFRvdGFsSGVpZ2h0ID0gZ2V0RXN0aW1hdGVkVG90YWxIZWlnaHQodGhpcy5wcm9wcywgdGhpcy5faW5zdGFuY2VQcm9wcyk7XG4gICAgICB2YXIgZXN0aW1hdGVkVG90YWxXaWR0aCA9IGdldEVzdGltYXRlZFRvdGFsV2lkdGgodGhpcy5wcm9wcywgdGhpcy5faW5zdGFuY2VQcm9wcyk7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChvdXRlckVsZW1lbnRUeXBlIHx8IG91dGVyVGFnTmFtZSB8fCAnZGl2Jywge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgb25TY3JvbGw6IHRoaXMuX29uU2Nyb2xsLFxuICAgICAgICByZWY6IHRoaXMuX291dGVyUmVmU2V0dGVyLFxuICAgICAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgICAgIFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOiAndG91Y2gnLFxuICAgICAgICAgIHdpbGxDaGFuZ2U6ICd0cmFuc2Zvcm0nLFxuICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgICAgIH0sIHN0eWxlKVxuICAgICAgfSwgY3JlYXRlRWxlbWVudChpbm5lckVsZW1lbnRUeXBlIHx8IGlubmVyVGFnTmFtZSB8fCAnZGl2Jywge1xuICAgICAgICBjaGlsZHJlbjogaXRlbXMsXG4gICAgICAgIHJlZjogaW5uZXJSZWYsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgaGVpZ2h0OiBlc3RpbWF0ZWRUb3RhbEhlaWdodCxcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBpc1Njcm9sbGluZyA/ICdub25lJyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB3aWR0aDogZXN0aW1hdGVkVG90YWxXaWR0aFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIF9wcm90by5fY2FsbFByb3BzQ2FsbGJhY2tzID0gZnVuY3Rpb24gX2NhbGxQcm9wc0NhbGxiYWNrcygpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNvbHVtbkNvdW50ID0gX3RoaXMkcHJvcHM1LmNvbHVtbkNvdW50LFxuICAgICAgICAgIG9uSXRlbXNSZW5kZXJlZCA9IF90aGlzJHByb3BzNS5vbkl0ZW1zUmVuZGVyZWQsXG4gICAgICAgICAgb25TY3JvbGwgPSBfdGhpcyRwcm9wczUub25TY3JvbGwsXG4gICAgICAgICAgcm93Q291bnQgPSBfdGhpcyRwcm9wczUucm93Q291bnQ7XG5cbiAgICAgIGlmICh0eXBlb2Ygb25JdGVtc1JlbmRlcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChjb2x1bW5Db3VudCA+IDAgJiYgcm93Q291bnQgPiAwKSB7XG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRIb3Jpem9udGFsUjIgPSB0aGlzLl9nZXRIb3Jpem9udGFsUmFuZ2VUb1JlbmRlcigpLFxuICAgICAgICAgICAgICBfb3ZlcnNjYW5Db2x1bW5TdGFydEluZGV4ID0gX3RoaXMkX2dldEhvcml6b250YWxSMlswXSxcbiAgICAgICAgICAgICAgX292ZXJzY2FuQ29sdW1uU3RvcEluZGV4ID0gX3RoaXMkX2dldEhvcml6b250YWxSMlsxXSxcbiAgICAgICAgICAgICAgX3Zpc2libGVDb2x1bW5TdGFydEluZGV4ID0gX3RoaXMkX2dldEhvcml6b250YWxSMlsyXSxcbiAgICAgICAgICAgICAgX3Zpc2libGVDb2x1bW5TdG9wSW5kZXggPSBfdGhpcyRfZ2V0SG9yaXpvbnRhbFIyWzNdO1xuXG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRWZXJ0aWNhbFJhbjIgPSB0aGlzLl9nZXRWZXJ0aWNhbFJhbmdlVG9SZW5kZXIoKSxcbiAgICAgICAgICAgICAgX292ZXJzY2FuUm93U3RhcnRJbmRleCA9IF90aGlzJF9nZXRWZXJ0aWNhbFJhbjJbMF0sXG4gICAgICAgICAgICAgIF9vdmVyc2NhblJvd1N0b3BJbmRleCA9IF90aGlzJF9nZXRWZXJ0aWNhbFJhbjJbMV0sXG4gICAgICAgICAgICAgIF92aXNpYmxlUm93U3RhcnRJbmRleCA9IF90aGlzJF9nZXRWZXJ0aWNhbFJhbjJbMl0sXG4gICAgICAgICAgICAgIF92aXNpYmxlUm93U3RvcEluZGV4ID0gX3RoaXMkX2dldFZlcnRpY2FsUmFuMlszXTtcblxuICAgICAgICAgIHRoaXMuX2NhbGxPbkl0ZW1zUmVuZGVyZWQoX292ZXJzY2FuQ29sdW1uU3RhcnRJbmRleCwgX292ZXJzY2FuQ29sdW1uU3RvcEluZGV4LCBfb3ZlcnNjYW5Sb3dTdGFydEluZGV4LCBfb3ZlcnNjYW5Sb3dTdG9wSW5kZXgsIF92aXNpYmxlQ29sdW1uU3RhcnRJbmRleCwgX3Zpc2libGVDb2x1bW5TdG9wSW5kZXgsIF92aXNpYmxlUm93U3RhcnRJbmRleCwgX3Zpc2libGVSb3dTdG9wSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb25TY3JvbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF90aGlzJHN0YXRlMyA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICBfaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiA9IF90aGlzJHN0YXRlMy5ob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uLFxuICAgICAgICAgICAgX3Njcm9sbExlZnQgPSBfdGhpcyRzdGF0ZTMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIF9zY3JvbGxUb3AgPSBfdGhpcyRzdGF0ZTMuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgX3Njcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZCA9IF90aGlzJHN0YXRlMy5zY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQsXG4gICAgICAgICAgICBfdmVydGljYWxTY3JvbGxEaXJlY3Rpb24gPSBfdGhpcyRzdGF0ZTMudmVydGljYWxTY3JvbGxEaXJlY3Rpb247XG5cbiAgICAgICAgdGhpcy5fY2FsbE9uU2Nyb2xsKF9zY3JvbGxMZWZ0LCBfc2Nyb2xsVG9wLCBfaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiwgX3ZlcnRpY2FsU2Nyb2xsRGlyZWN0aW9uLCBfc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkKTtcbiAgICAgIH1cbiAgICB9IC8vIExhemlseSBjcmVhdGUgYW5kIGNhY2hlIGl0ZW0gc3R5bGVzIHdoaWxlIHNjcm9sbGluZyxcbiAgICAvLyBTbyB0aGF0IHB1cmUgY29tcG9uZW50IHNDVSB3aWxsIHByZXZlbnQgcmUtcmVuZGVycy5cbiAgICAvLyBXZSBtYWludGFpbiB0aGlzIGNhY2hlLCBhbmQgcGFzcyBhIHN0eWxlIHByb3AgcmF0aGVyIHRoYW4gaW5kZXgsXG4gICAgLy8gU28gdGhhdCBMaXN0IGNhbiBjbGVhciBjYWNoZWQgc3R5bGVzIGFuZCBmb3JjZSBpdGVtIHJlLXJlbmRlciBpZiBuZWNlc3NhcnkuXG4gICAgO1xuXG4gICAgX3Byb3RvLl9nZXRIb3Jpem9udGFsUmFuZ2VUb1JlbmRlciA9IGZ1bmN0aW9uIF9nZXRIb3Jpem9udGFsUmFuZ2VUb1JlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczYgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNvbHVtbkNvdW50ID0gX3RoaXMkcHJvcHM2LmNvbHVtbkNvdW50LFxuICAgICAgICAgIG92ZXJzY2FuQ29sdW1uQ291bnQgPSBfdGhpcyRwcm9wczYub3ZlcnNjYW5Db2x1bW5Db3VudCxcbiAgICAgICAgICBvdmVyc2NhbkNvbHVtbnNDb3VudCA9IF90aGlzJHByb3BzNi5vdmVyc2NhbkNvbHVtbnNDb3VudCxcbiAgICAgICAgICBvdmVyc2NhbkNvdW50ID0gX3RoaXMkcHJvcHM2Lm92ZXJzY2FuQ291bnQsXG4gICAgICAgICAgcm93Q291bnQgPSBfdGhpcyRwcm9wczYucm93Q291bnQ7XG4gICAgICB2YXIgX3RoaXMkc3RhdGU0ID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICBob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uID0gX3RoaXMkc3RhdGU0Lmhvcml6b250YWxTY3JvbGxEaXJlY3Rpb24sXG4gICAgICAgICAgaXNTY3JvbGxpbmcgPSBfdGhpcyRzdGF0ZTQuaXNTY3JvbGxpbmcsXG4gICAgICAgICAgc2Nyb2xsTGVmdCA9IF90aGlzJHN0YXRlNC5zY3JvbGxMZWZ0O1xuICAgICAgdmFyIG92ZXJzY2FuQ291bnRSZXNvbHZlZCA9IG92ZXJzY2FuQ29sdW1uQ291bnQgfHwgb3ZlcnNjYW5Db2x1bW5zQ291bnQgfHwgb3ZlcnNjYW5Db3VudCB8fCAxO1xuXG4gICAgICBpZiAoY29sdW1uQ291bnQgPT09IDAgfHwgcm93Q291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBnZXRDb2x1bW5TdGFydEluZGV4Rm9yT2Zmc2V0KHRoaXMucHJvcHMsIHNjcm9sbExlZnQsIHRoaXMuX2luc3RhbmNlUHJvcHMpO1xuICAgICAgdmFyIHN0b3BJbmRleCA9IGdldENvbHVtblN0b3BJbmRleEZvclN0YXJ0SW5kZXgodGhpcy5wcm9wcywgc3RhcnRJbmRleCwgc2Nyb2xsTGVmdCwgdGhpcy5faW5zdGFuY2VQcm9wcyk7IC8vIE92ZXJzY2FuIGJ5IG9uZSBpdGVtIGluIGVhY2ggZGlyZWN0aW9uIHNvIHRoYXQgdGFiL2ZvY3VzIHdvcmtzLlxuICAgICAgLy8gSWYgdGhlcmUgaXNuJ3QgYXQgbGVhc3Qgb25lIGV4dHJhIGl0ZW0sIHRhYiBsb29wcyBiYWNrIGFyb3VuZC5cblxuICAgICAgdmFyIG92ZXJzY2FuQmFja3dhcmQgPSAhaXNTY3JvbGxpbmcgfHwgaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyA/IE1hdGgubWF4KDEsIG92ZXJzY2FuQ291bnRSZXNvbHZlZCkgOiAxO1xuICAgICAgdmFyIG92ZXJzY2FuRm9yd2FyZCA9ICFpc1Njcm9sbGluZyB8fCBob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyBNYXRoLm1heCgxLCBvdmVyc2NhbkNvdW50UmVzb2x2ZWQpIDogMTtcbiAgICAgIHJldHVybiBbTWF0aC5tYXgoMCwgc3RhcnRJbmRleCAtIG92ZXJzY2FuQmFja3dhcmQpLCBNYXRoLm1heCgwLCBNYXRoLm1pbihjb2x1bW5Db3VudCAtIDEsIHN0b3BJbmRleCArIG92ZXJzY2FuRm9yd2FyZCkpLCBzdGFydEluZGV4LCBzdG9wSW5kZXhdO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2dldFZlcnRpY2FsUmFuZ2VUb1JlbmRlciA9IGZ1bmN0aW9uIF9nZXRWZXJ0aWNhbFJhbmdlVG9SZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHM3ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb2x1bW5Db3VudCA9IF90aGlzJHByb3BzNy5jb2x1bW5Db3VudCxcbiAgICAgICAgICBvdmVyc2NhbkNvdW50ID0gX3RoaXMkcHJvcHM3Lm92ZXJzY2FuQ291bnQsXG4gICAgICAgICAgb3ZlcnNjYW5Sb3dDb3VudCA9IF90aGlzJHByb3BzNy5vdmVyc2NhblJvd0NvdW50LFxuICAgICAgICAgIG92ZXJzY2FuUm93c0NvdW50ID0gX3RoaXMkcHJvcHM3Lm92ZXJzY2FuUm93c0NvdW50LFxuICAgICAgICAgIHJvd0NvdW50ID0gX3RoaXMkcHJvcHM3LnJvd0NvdW50O1xuICAgICAgdmFyIF90aGlzJHN0YXRlNSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgaXNTY3JvbGxpbmcgPSBfdGhpcyRzdGF0ZTUuaXNTY3JvbGxpbmcsXG4gICAgICAgICAgdmVydGljYWxTY3JvbGxEaXJlY3Rpb24gPSBfdGhpcyRzdGF0ZTUudmVydGljYWxTY3JvbGxEaXJlY3Rpb24sXG4gICAgICAgICAgc2Nyb2xsVG9wID0gX3RoaXMkc3RhdGU1LnNjcm9sbFRvcDtcbiAgICAgIHZhciBvdmVyc2NhbkNvdW50UmVzb2x2ZWQgPSBvdmVyc2NhblJvd0NvdW50IHx8IG92ZXJzY2FuUm93c0NvdW50IHx8IG92ZXJzY2FuQ291bnQgfHwgMTtcblxuICAgICAgaWYgKGNvbHVtbkNvdW50ID09PSAwIHx8IHJvd0NvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydEluZGV4ID0gZ2V0Um93U3RhcnRJbmRleEZvck9mZnNldCh0aGlzLnByb3BzLCBzY3JvbGxUb3AsIHRoaXMuX2luc3RhbmNlUHJvcHMpO1xuICAgICAgdmFyIHN0b3BJbmRleCA9IGdldFJvd1N0b3BJbmRleEZvclN0YXJ0SW5kZXgodGhpcy5wcm9wcywgc3RhcnRJbmRleCwgc2Nyb2xsVG9wLCB0aGlzLl9pbnN0YW5jZVByb3BzKTsgLy8gT3ZlcnNjYW4gYnkgb25lIGl0ZW0gaW4gZWFjaCBkaXJlY3Rpb24gc28gdGhhdCB0YWIvZm9jdXMgd29ya3MuXG4gICAgICAvLyBJZiB0aGVyZSBpc24ndCBhdCBsZWFzdCBvbmUgZXh0cmEgaXRlbSwgdGFiIGxvb3BzIGJhY2sgYXJvdW5kLlxuXG4gICAgICB2YXIgb3ZlcnNjYW5CYWNrd2FyZCA9ICFpc1Njcm9sbGluZyB8fCB2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyA/IE1hdGgubWF4KDEsIG92ZXJzY2FuQ291bnRSZXNvbHZlZCkgOiAxO1xuICAgICAgdmFyIG92ZXJzY2FuRm9yd2FyZCA9ICFpc1Njcm9sbGluZyB8fCB2ZXJ0aWNhbFNjcm9sbERpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gTWF0aC5tYXgoMSwgb3ZlcnNjYW5Db3VudFJlc29sdmVkKSA6IDE7XG4gICAgICByZXR1cm4gW01hdGgubWF4KDAsIHN0YXJ0SW5kZXggLSBvdmVyc2NhbkJhY2t3YXJkKSwgTWF0aC5tYXgoMCwgTWF0aC5taW4ocm93Q291bnQgLSAxLCBzdG9wSW5kZXggKyBvdmVyc2NhbkZvcndhcmQpKSwgc3RhcnRJbmRleCwgc3RvcEluZGV4XTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEdyaWQ7XG4gIH0oUHVyZUNvbXBvbmVudCksIF9jbGFzcy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgZGlyZWN0aW9uOiAnbHRyJyxcbiAgICBpdGVtRGF0YTogdW5kZWZpbmVkLFxuICAgIHVzZUlzU2Nyb2xsaW5nOiBmYWxzZVxuICB9LCBfY2xhc3M7XG59XG5cbnZhciB2YWxpZGF0ZVNoYXJlZFByb3BzID0gZnVuY3Rpb24gdmFsaWRhdGVTaGFyZWRQcm9wcyhfcmVmNSwgX3JlZjYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZjUuY2hpbGRyZW4sXG4gICAgICBkaXJlY3Rpb24gPSBfcmVmNS5kaXJlY3Rpb24sXG4gICAgICBoZWlnaHQgPSBfcmVmNS5oZWlnaHQsXG4gICAgICBpbm5lclRhZ05hbWUgPSBfcmVmNS5pbm5lclRhZ05hbWUsXG4gICAgICBvdXRlclRhZ05hbWUgPSBfcmVmNS5vdXRlclRhZ05hbWUsXG4gICAgICBvdmVyc2NhbkNvbHVtbnNDb3VudCA9IF9yZWY1Lm92ZXJzY2FuQ29sdW1uc0NvdW50LFxuICAgICAgb3ZlcnNjYW5Db3VudCA9IF9yZWY1Lm92ZXJzY2FuQ291bnQsXG4gICAgICBvdmVyc2NhblJvd3NDb3VudCA9IF9yZWY1Lm92ZXJzY2FuUm93c0NvdW50LFxuICAgICAgd2lkdGggPSBfcmVmNS53aWR0aDtcbiAgdmFyIGluc3RhbmNlID0gX3JlZjYuaW5zdGFuY2U7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIG92ZXJzY2FuQ291bnQgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoZGV2V2FybmluZ3NPdmVyc2NhbkNvdW50ICYmICFkZXZXYXJuaW5nc092ZXJzY2FuQ291bnQuaGFzKGluc3RhbmNlKSkge1xuICAgICAgICBkZXZXYXJuaW5nc092ZXJzY2FuQ291bnQuYWRkKGluc3RhbmNlKTtcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgb3ZlcnNjYW5Db3VudCBwcm9wIGhhcyBiZWVuIGRlcHJlY2F0ZWQuICcgKyAnUGxlYXNlIHVzZSB0aGUgb3ZlcnNjYW5Db2x1bW5Db3VudCBhbmQgb3ZlcnNjYW5Sb3dDb3VudCBwcm9wcyBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3ZlcnNjYW5Db2x1bW5zQ291bnQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBvdmVyc2NhblJvd3NDb3VudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChkZXZXYXJuaW5nc092ZXJzY2FuUm93c0NvbHVtbnNDb3VudCAmJiAhZGV2V2FybmluZ3NPdmVyc2NhblJvd3NDb2x1bW5zQ291bnQuaGFzKGluc3RhbmNlKSkge1xuICAgICAgICBkZXZXYXJuaW5nc092ZXJzY2FuUm93c0NvbHVtbnNDb3VudC5hZGQoaW5zdGFuY2UpO1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBvdmVyc2NhbkNvbHVtbnNDb3VudCBhbmQgb3ZlcnNjYW5Sb3dzQ291bnQgcHJvcHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQuICcgKyAnUGxlYXNlIHVzZSB0aGUgb3ZlcnNjYW5Db2x1bW5Db3VudCBhbmQgb3ZlcnNjYW5Sb3dDb3VudCBwcm9wcyBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbm5lclRhZ05hbWUgIT0gbnVsbCB8fCBvdXRlclRhZ05hbWUgIT0gbnVsbCkge1xuICAgICAgaWYgKGRldldhcm5pbmdzVGFnTmFtZSAmJiAhZGV2V2FybmluZ3NUYWdOYW1lLmhhcyhpbnN0YW5jZSkpIHtcbiAgICAgICAgZGV2V2FybmluZ3NUYWdOYW1lLmFkZChpbnN0YW5jZSk7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIGlubmVyVGFnTmFtZSBhbmQgb3V0ZXJUYWdOYW1lIHByb3BzIGhhdmUgYmVlbiBkZXByZWNhdGVkLiAnICsgJ1BsZWFzZSB1c2UgdGhlIGlubmVyRWxlbWVudFR5cGUgYW5kIG91dGVyRWxlbWVudFR5cGUgcHJvcHMgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FuIGludmFsaWQgXCJjaGlsZHJlblwiIHByb3AgaGFzIGJlZW4gc3BlY2lmaWVkLiAnICsgJ1ZhbHVlIHNob3VsZCBiZSBhIFJlYWN0IGNvbXBvbmVudC4gJyArIChcIlxcXCJcIiArIChjaGlsZHJlbiA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBjaGlsZHJlbikgKyBcIlxcXCIgd2FzIHNwZWNpZmllZC5cIikpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlICdsdHInOlxuICAgICAgY2FzZSAncnRsJzpcbiAgICAgICAgLy8gVmFsaWQgdmFsdWVzXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcignQW4gaW52YWxpZCBcImRpcmVjdGlvblwiIHByb3AgaGFzIGJlZW4gc3BlY2lmaWVkLiAnICsgJ1ZhbHVlIHNob3VsZCBiZSBlaXRoZXIgXCJsdHJcIiBvciBcInJ0bFwiLiAnICsgKFwiXFxcIlwiICsgZGlyZWN0aW9uICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FuIGludmFsaWQgXCJ3aWR0aFwiIHByb3AgaGFzIGJlZW4gc3BlY2lmaWVkLiAnICsgJ0dyaWRzIG11c3Qgc3BlY2lmeSBhIG51bWJlciBmb3Igd2lkdGguICcgKyAoXCJcXFwiXCIgKyAod2lkdGggPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2Ygd2lkdGgpICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwiaGVpZ2h0XCIgcHJvcCBoYXMgYmVlbiBzcGVjaWZpZWQuICcgKyAnR3JpZHMgbXVzdCBzcGVjaWZ5IGEgbnVtYmVyIGZvciBoZWlnaHQuICcgKyAoXCJcXFwiXCIgKyAoaGVpZ2h0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGhlaWdodCkgKyBcIlxcXCIgd2FzIHNwZWNpZmllZC5cIikpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIERFRkFVTFRfRVNUSU1BVEVEX0lURU1fU0laRSA9IDUwO1xuXG52YXIgZ2V0RXN0aW1hdGVkVG90YWxIZWlnaHQgPSBmdW5jdGlvbiBnZXRFc3RpbWF0ZWRUb3RhbEhlaWdodChfcmVmLCBfcmVmMikge1xuICB2YXIgcm93Q291bnQgPSBfcmVmLnJvd0NvdW50O1xuICB2YXIgcm93TWV0YWRhdGFNYXAgPSBfcmVmMi5yb3dNZXRhZGF0YU1hcCxcbiAgICAgIGVzdGltYXRlZFJvd0hlaWdodCA9IF9yZWYyLmVzdGltYXRlZFJvd0hlaWdodCxcbiAgICAgIGxhc3RNZWFzdXJlZFJvd0luZGV4ID0gX3JlZjIubGFzdE1lYXN1cmVkUm93SW5kZXg7XG4gIHZhciB0b3RhbFNpemVPZk1lYXN1cmVkUm93cyA9IDA7IC8vIEVkZ2UgY2FzZSBjaGVjayBmb3Igd2hlbiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGRlY3JlYXNlcyB3aGlsZSBhIHNjcm9sbCBpcyBpbiBwcm9ncmVzcy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2J2YXVnaG4vcmVhY3Qtd2luZG93L3B1bGwvMTM4XG5cbiAgaWYgKGxhc3RNZWFzdXJlZFJvd0luZGV4ID49IHJvd0NvdW50KSB7XG4gICAgbGFzdE1lYXN1cmVkUm93SW5kZXggPSByb3dDb3VudCAtIDE7XG4gIH1cblxuICBpZiAobGFzdE1lYXN1cmVkUm93SW5kZXggPj0gMCkge1xuICAgIHZhciBpdGVtTWV0YWRhdGEgPSByb3dNZXRhZGF0YU1hcFtsYXN0TWVhc3VyZWRSb3dJbmRleF07XG4gICAgdG90YWxTaXplT2ZNZWFzdXJlZFJvd3MgPSBpdGVtTWV0YWRhdGEub2Zmc2V0ICsgaXRlbU1ldGFkYXRhLnNpemU7XG4gIH1cblxuICB2YXIgbnVtVW5tZWFzdXJlZEl0ZW1zID0gcm93Q291bnQgLSBsYXN0TWVhc3VyZWRSb3dJbmRleCAtIDE7XG4gIHZhciB0b3RhbFNpemVPZlVubWVhc3VyZWRJdGVtcyA9IG51bVVubWVhc3VyZWRJdGVtcyAqIGVzdGltYXRlZFJvd0hlaWdodDtcbiAgcmV0dXJuIHRvdGFsU2l6ZU9mTWVhc3VyZWRSb3dzICsgdG90YWxTaXplT2ZVbm1lYXN1cmVkSXRlbXM7XG59O1xuXG52YXIgZ2V0RXN0aW1hdGVkVG90YWxXaWR0aCA9IGZ1bmN0aW9uIGdldEVzdGltYXRlZFRvdGFsV2lkdGgoX3JlZjMsIF9yZWY0KSB7XG4gIHZhciBjb2x1bW5Db3VudCA9IF9yZWYzLmNvbHVtbkNvdW50O1xuICB2YXIgY29sdW1uTWV0YWRhdGFNYXAgPSBfcmVmNC5jb2x1bW5NZXRhZGF0YU1hcCxcbiAgICAgIGVzdGltYXRlZENvbHVtbldpZHRoID0gX3JlZjQuZXN0aW1hdGVkQ29sdW1uV2lkdGgsXG4gICAgICBsYXN0TWVhc3VyZWRDb2x1bW5JbmRleCA9IF9yZWY0Lmxhc3RNZWFzdXJlZENvbHVtbkluZGV4O1xuICB2YXIgdG90YWxTaXplT2ZNZWFzdXJlZFJvd3MgPSAwOyAvLyBFZGdlIGNhc2UgY2hlY2sgZm9yIHdoZW4gdGhlIG51bWJlciBvZiBpdGVtcyBkZWNyZWFzZXMgd2hpbGUgYSBzY3JvbGwgaXMgaW4gcHJvZ3Jlc3MuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9idmF1Z2huL3JlYWN0LXdpbmRvdy9wdWxsLzEzOFxuXG4gIGlmIChsYXN0TWVhc3VyZWRDb2x1bW5JbmRleCA+PSBjb2x1bW5Db3VudCkge1xuICAgIGxhc3RNZWFzdXJlZENvbHVtbkluZGV4ID0gY29sdW1uQ291bnQgLSAxO1xuICB9XG5cbiAgaWYgKGxhc3RNZWFzdXJlZENvbHVtbkluZGV4ID49IDApIHtcbiAgICB2YXIgaXRlbU1ldGFkYXRhID0gY29sdW1uTWV0YWRhdGFNYXBbbGFzdE1lYXN1cmVkQ29sdW1uSW5kZXhdO1xuICAgIHRvdGFsU2l6ZU9mTWVhc3VyZWRSb3dzID0gaXRlbU1ldGFkYXRhLm9mZnNldCArIGl0ZW1NZXRhZGF0YS5zaXplO1xuICB9XG5cbiAgdmFyIG51bVVubWVhc3VyZWRJdGVtcyA9IGNvbHVtbkNvdW50IC0gbGFzdE1lYXN1cmVkQ29sdW1uSW5kZXggLSAxO1xuICB2YXIgdG90YWxTaXplT2ZVbm1lYXN1cmVkSXRlbXMgPSBudW1Vbm1lYXN1cmVkSXRlbXMgKiBlc3RpbWF0ZWRDb2x1bW5XaWR0aDtcbiAgcmV0dXJuIHRvdGFsU2l6ZU9mTWVhc3VyZWRSb3dzICsgdG90YWxTaXplT2ZVbm1lYXN1cmVkSXRlbXM7XG59O1xuXG52YXIgZ2V0SXRlbU1ldGFkYXRhID0gZnVuY3Rpb24gZ2V0SXRlbU1ldGFkYXRhKGl0ZW1UeXBlLCBwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpIHtcbiAgdmFyIGl0ZW1NZXRhZGF0YU1hcCwgaXRlbVNpemUsIGxhc3RNZWFzdXJlZEluZGV4O1xuXG4gIGlmIChpdGVtVHlwZSA9PT0gJ2NvbHVtbicpIHtcbiAgICBpdGVtTWV0YWRhdGFNYXAgPSBpbnN0YW5jZVByb3BzLmNvbHVtbk1ldGFkYXRhTWFwO1xuICAgIGl0ZW1TaXplID0gcHJvcHMuY29sdW1uV2lkdGg7XG4gICAgbGFzdE1lYXN1cmVkSW5kZXggPSBpbnN0YW5jZVByb3BzLmxhc3RNZWFzdXJlZENvbHVtbkluZGV4O1xuICB9IGVsc2Uge1xuICAgIGl0ZW1NZXRhZGF0YU1hcCA9IGluc3RhbmNlUHJvcHMucm93TWV0YWRhdGFNYXA7XG4gICAgaXRlbVNpemUgPSBwcm9wcy5yb3dIZWlnaHQ7XG4gICAgbGFzdE1lYXN1cmVkSW5kZXggPSBpbnN0YW5jZVByb3BzLmxhc3RNZWFzdXJlZFJvd0luZGV4O1xuICB9XG5cbiAgaWYgKGluZGV4ID4gbGFzdE1lYXN1cmVkSW5kZXgpIHtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGlmIChsYXN0TWVhc3VyZWRJbmRleCA+PSAwKSB7XG4gICAgICB2YXIgaXRlbU1ldGFkYXRhID0gaXRlbU1ldGFkYXRhTWFwW2xhc3RNZWFzdXJlZEluZGV4XTtcbiAgICAgIG9mZnNldCA9IGl0ZW1NZXRhZGF0YS5vZmZzZXQgKyBpdGVtTWV0YWRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gbGFzdE1lYXN1cmVkSW5kZXggKyAxOyBpIDw9IGluZGV4OyBpKyspIHtcbiAgICAgIHZhciBzaXplID0gaXRlbVNpemUoaSk7XG4gICAgICBpdGVtTWV0YWRhdGFNYXBbaV0gPSB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBzaXplOiBzaXplXG4gICAgICB9O1xuICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1UeXBlID09PSAnY29sdW1uJykge1xuICAgICAgaW5zdGFuY2VQcm9wcy5sYXN0TWVhc3VyZWRDb2x1bW5JbmRleCA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZVByb3BzLmxhc3RNZWFzdXJlZFJvd0luZGV4ID0gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGl0ZW1NZXRhZGF0YU1hcFtpbmRleF07XG59O1xuXG52YXIgZmluZE5lYXJlc3RJdGVtID0gZnVuY3Rpb24gZmluZE5lYXJlc3RJdGVtKGl0ZW1UeXBlLCBwcm9wcywgaW5zdGFuY2VQcm9wcywgb2Zmc2V0KSB7XG4gIHZhciBpdGVtTWV0YWRhdGFNYXAsIGxhc3RNZWFzdXJlZEluZGV4O1xuXG4gIGlmIChpdGVtVHlwZSA9PT0gJ2NvbHVtbicpIHtcbiAgICBpdGVtTWV0YWRhdGFNYXAgPSBpbnN0YW5jZVByb3BzLmNvbHVtbk1ldGFkYXRhTWFwO1xuICAgIGxhc3RNZWFzdXJlZEluZGV4ID0gaW5zdGFuY2VQcm9wcy5sYXN0TWVhc3VyZWRDb2x1bW5JbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpdGVtTWV0YWRhdGFNYXAgPSBpbnN0YW5jZVByb3BzLnJvd01ldGFkYXRhTWFwO1xuICAgIGxhc3RNZWFzdXJlZEluZGV4ID0gaW5zdGFuY2VQcm9wcy5sYXN0TWVhc3VyZWRSb3dJbmRleDtcbiAgfVxuXG4gIHZhciBsYXN0TWVhc3VyZWRJdGVtT2Zmc2V0ID0gbGFzdE1lYXN1cmVkSW5kZXggPiAwID8gaXRlbU1ldGFkYXRhTWFwW2xhc3RNZWFzdXJlZEluZGV4XS5vZmZzZXQgOiAwO1xuXG4gIGlmIChsYXN0TWVhc3VyZWRJdGVtT2Zmc2V0ID49IG9mZnNldCkge1xuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgbWVhc3VyZWQgaXRlbXMgd2l0aGluIHRoaXMgcmFuZ2UganVzdCB1c2UgYSBiaW5hcnkgc2VhcmNoIGFzIGl0J3MgZmFzdGVyLlxuICAgIHJldHVybiBmaW5kTmVhcmVzdEl0ZW1CaW5hcnlTZWFyY2goaXRlbVR5cGUsIHByb3BzLCBpbnN0YW5jZVByb3BzLCBsYXN0TWVhc3VyZWRJbmRleCwgMCwgb2Zmc2V0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB3ZSBoYXZlbid0IHlldCBtZWFzdXJlZCB0aGlzIGhpZ2gsIGZhbGxiYWNrIHRvIGFuIGV4cG9uZW50aWFsIHNlYXJjaCB3aXRoIGFuIGlubmVyIGJpbmFyeSBzZWFyY2guXG4gICAgLy8gVGhlIGV4cG9uZW50aWFsIHNlYXJjaCBhdm9pZHMgcHJlLWNvbXB1dGluZyBzaXplcyBmb3IgdGhlIGZ1bGwgc2V0IG9mIGl0ZW1zIGFzIGEgYmluYXJ5IHNlYXJjaCB3b3VsZC5cbiAgICAvLyBUaGUgb3ZlcmFsbCBjb21wbGV4aXR5IGZvciB0aGlzIGFwcHJvYWNoIGlzIE8obG9nIG4pLlxuICAgIHJldHVybiBmaW5kTmVhcmVzdEl0ZW1FeHBvbmVudGlhbFNlYXJjaChpdGVtVHlwZSwgcHJvcHMsIGluc3RhbmNlUHJvcHMsIE1hdGgubWF4KDAsIGxhc3RNZWFzdXJlZEluZGV4KSwgb2Zmc2V0KTtcbiAgfVxufTtcblxudmFyIGZpbmROZWFyZXN0SXRlbUJpbmFyeVNlYXJjaCA9IGZ1bmN0aW9uIGZpbmROZWFyZXN0SXRlbUJpbmFyeVNlYXJjaChpdGVtVHlwZSwgcHJvcHMsIGluc3RhbmNlUHJvcHMsIGhpZ2gsIGxvdywgb2Zmc2V0KSB7XG4gIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgIHZhciBtaWRkbGUgPSBsb3cgKyBNYXRoLmZsb29yKChoaWdoIC0gbG93KSAvIDIpO1xuICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gZ2V0SXRlbU1ldGFkYXRhKGl0ZW1UeXBlLCBwcm9wcywgbWlkZGxlLCBpbnN0YW5jZVByb3BzKS5vZmZzZXQ7XG5cbiAgICBpZiAoY3VycmVudE9mZnNldCA9PT0gb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudE9mZnNldCA8IG9mZnNldCkge1xuICAgICAgbG93ID0gbWlkZGxlICsgMTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRPZmZzZXQgPiBvZmZzZXQpIHtcbiAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGxvdyAtIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbnZhciBmaW5kTmVhcmVzdEl0ZW1FeHBvbmVudGlhbFNlYXJjaCA9IGZ1bmN0aW9uIGZpbmROZWFyZXN0SXRlbUV4cG9uZW50aWFsU2VhcmNoKGl0ZW1UeXBlLCBwcm9wcywgaW5zdGFuY2VQcm9wcywgaW5kZXgsIG9mZnNldCkge1xuICB2YXIgaXRlbUNvdW50ID0gaXRlbVR5cGUgPT09ICdjb2x1bW4nID8gcHJvcHMuY29sdW1uQ291bnQgOiBwcm9wcy5yb3dDb3VudDtcbiAgdmFyIGludGVydmFsID0gMTtcblxuICB3aGlsZSAoaW5kZXggPCBpdGVtQ291bnQgJiYgZ2V0SXRlbU1ldGFkYXRhKGl0ZW1UeXBlLCBwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpLm9mZnNldCA8IG9mZnNldCkge1xuICAgIGluZGV4ICs9IGludGVydmFsO1xuICAgIGludGVydmFsICo9IDI7XG4gIH1cblxuICByZXR1cm4gZmluZE5lYXJlc3RJdGVtQmluYXJ5U2VhcmNoKGl0ZW1UeXBlLCBwcm9wcywgaW5zdGFuY2VQcm9wcywgTWF0aC5taW4oaW5kZXgsIGl0ZW1Db3VudCAtIDEpLCBNYXRoLmZsb29yKGluZGV4IC8gMiksIG9mZnNldCk7XG59O1xuXG52YXIgZ2V0T2Zmc2V0Rm9ySW5kZXhBbmRBbGlnbm1lbnQgPSBmdW5jdGlvbiBnZXRPZmZzZXRGb3JJbmRleEFuZEFsaWdubWVudChpdGVtVHlwZSwgcHJvcHMsIGluZGV4LCBhbGlnbiwgc2Nyb2xsT2Zmc2V0LCBpbnN0YW5jZVByb3BzLCBzY3JvbGxiYXJTaXplKSB7XG4gIHZhciBzaXplID0gaXRlbVR5cGUgPT09ICdjb2x1bW4nID8gcHJvcHMud2lkdGggOiBwcm9wcy5oZWlnaHQ7XG4gIHZhciBpdGVtTWV0YWRhdGEgPSBnZXRJdGVtTWV0YWRhdGEoaXRlbVR5cGUsIHByb3BzLCBpbmRleCwgaW5zdGFuY2VQcm9wcyk7IC8vIEdldCBlc3RpbWF0ZWQgdG90YWwgc2l6ZSBhZnRlciBJdGVtTWV0YWRhdGEgaXMgY29tcHV0ZWQsXG4gIC8vIFRvIGVuc3VyZSBpdCByZWZsZWN0cyBhY3R1YWwgbWVhc3VyZW1lbnRzIGluc3RlYWQgb2YganVzdCBlc3RpbWF0ZXMuXG5cbiAgdmFyIGVzdGltYXRlZFRvdGFsU2l6ZSA9IGl0ZW1UeXBlID09PSAnY29sdW1uJyA/IGdldEVzdGltYXRlZFRvdGFsV2lkdGgocHJvcHMsIGluc3RhbmNlUHJvcHMpIDogZ2V0RXN0aW1hdGVkVG90YWxIZWlnaHQocHJvcHMsIGluc3RhbmNlUHJvcHMpO1xuICB2YXIgbWF4T2Zmc2V0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZXN0aW1hdGVkVG90YWxTaXplIC0gc2l6ZSwgaXRlbU1ldGFkYXRhLm9mZnNldCkpO1xuICB2YXIgbWluT2Zmc2V0ID0gTWF0aC5tYXgoMCwgaXRlbU1ldGFkYXRhLm9mZnNldCAtIHNpemUgKyBzY3JvbGxiYXJTaXplICsgaXRlbU1ldGFkYXRhLnNpemUpO1xuXG4gIGlmIChhbGlnbiA9PT0gJ3NtYXJ0Jykge1xuICAgIGlmIChzY3JvbGxPZmZzZXQgPj0gbWluT2Zmc2V0IC0gc2l6ZSAmJiBzY3JvbGxPZmZzZXQgPD0gbWF4T2Zmc2V0ICsgc2l6ZSkge1xuICAgICAgYWxpZ24gPSAnYXV0byc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoIChhbGlnbikge1xuICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgIHJldHVybiBtYXhPZmZzZXQ7XG5cbiAgICBjYXNlICdlbmQnOlxuICAgICAgcmV0dXJuIG1pbk9mZnNldDtcblxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChtaW5PZmZzZXQgKyAobWF4T2Zmc2V0IC0gbWluT2Zmc2V0KSAvIDIpO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChzY3JvbGxPZmZzZXQgPj0gbWluT2Zmc2V0ICYmIHNjcm9sbE9mZnNldCA8PSBtYXhPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbE9mZnNldDtcbiAgICAgIH0gZWxzZSBpZiAobWluT2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgIC8vIEJlY2F1c2Ugd2Ugb25seSB0YWtlIGludG8gYWNjb3VudCB0aGUgc2Nyb2xsYmFyIHNpemUgd2hlbiBjYWxjdWxhdGluZyBtaW5PZmZzZXRcbiAgICAgICAgLy8gdGhpcyB2YWx1ZSBjYW4gYmUgbGFyZ2VyIHRoYW4gbWF4T2Zmc2V0IHdoZW4gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgICByZXR1cm4gbWluT2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxPZmZzZXQgPCBtaW5PZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG1pbk9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXhPZmZzZXQ7XG4gICAgICB9XG5cbiAgfVxufTtcblxudmFyIFZhcmlhYmxlU2l6ZUdyaWQgPSAvKiNfX1BVUkVfXyovY3JlYXRlR3JpZENvbXBvbmVudCh7XG4gIGdldENvbHVtbk9mZnNldDogZnVuY3Rpb24gZ2V0Q29sdW1uT2Zmc2V0KHByb3BzLCBpbmRleCwgaW5zdGFuY2VQcm9wcykge1xuICAgIHJldHVybiBnZXRJdGVtTWV0YWRhdGEoJ2NvbHVtbicsIHByb3BzLCBpbmRleCwgaW5zdGFuY2VQcm9wcykub2Zmc2V0O1xuICB9LFxuICBnZXRDb2x1bW5TdGFydEluZGV4Rm9yT2Zmc2V0OiBmdW5jdGlvbiBnZXRDb2x1bW5TdGFydEluZGV4Rm9yT2Zmc2V0KHByb3BzLCBzY3JvbGxMZWZ0LCBpbnN0YW5jZVByb3BzKSB7XG4gICAgcmV0dXJuIGZpbmROZWFyZXN0SXRlbSgnY29sdW1uJywgcHJvcHMsIGluc3RhbmNlUHJvcHMsIHNjcm9sbExlZnQpO1xuICB9LFxuICBnZXRDb2x1bW5TdG9wSW5kZXhGb3JTdGFydEluZGV4OiBmdW5jdGlvbiBnZXRDb2x1bW5TdG9wSW5kZXhGb3JTdGFydEluZGV4KHByb3BzLCBzdGFydEluZGV4LCBzY3JvbGxMZWZ0LCBpbnN0YW5jZVByb3BzKSB7XG4gICAgdmFyIGNvbHVtbkNvdW50ID0gcHJvcHMuY29sdW1uQ291bnQsXG4gICAgICAgIHdpZHRoID0gcHJvcHMud2lkdGg7XG4gICAgdmFyIGl0ZW1NZXRhZGF0YSA9IGdldEl0ZW1NZXRhZGF0YSgnY29sdW1uJywgcHJvcHMsIHN0YXJ0SW5kZXgsIGluc3RhbmNlUHJvcHMpO1xuICAgIHZhciBtYXhPZmZzZXQgPSBzY3JvbGxMZWZ0ICsgd2lkdGg7XG4gICAgdmFyIG9mZnNldCA9IGl0ZW1NZXRhZGF0YS5vZmZzZXQgKyBpdGVtTWV0YWRhdGEuc2l6ZTtcbiAgICB2YXIgc3RvcEluZGV4ID0gc3RhcnRJbmRleDtcblxuICAgIHdoaWxlIChzdG9wSW5kZXggPCBjb2x1bW5Db3VudCAtIDEgJiYgb2Zmc2V0IDwgbWF4T2Zmc2V0KSB7XG4gICAgICBzdG9wSW5kZXgrKztcbiAgICAgIG9mZnNldCArPSBnZXRJdGVtTWV0YWRhdGEoJ2NvbHVtbicsIHByb3BzLCBzdG9wSW5kZXgsIGluc3RhbmNlUHJvcHMpLnNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3BJbmRleDtcbiAgfSxcbiAgZ2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uIGdldENvbHVtbldpZHRoKHByb3BzLCBpbmRleCwgaW5zdGFuY2VQcm9wcykge1xuICAgIHJldHVybiBpbnN0YW5jZVByb3BzLmNvbHVtbk1ldGFkYXRhTWFwW2luZGV4XS5zaXplO1xuICB9LFxuICBnZXRFc3RpbWF0ZWRUb3RhbEhlaWdodDogZ2V0RXN0aW1hdGVkVG90YWxIZWlnaHQsXG4gIGdldEVzdGltYXRlZFRvdGFsV2lkdGg6IGdldEVzdGltYXRlZFRvdGFsV2lkdGgsXG4gIGdldE9mZnNldEZvckNvbHVtbkFuZEFsaWdubWVudDogZnVuY3Rpb24gZ2V0T2Zmc2V0Rm9yQ29sdW1uQW5kQWxpZ25tZW50KHByb3BzLCBpbmRleCwgYWxpZ24sIHNjcm9sbE9mZnNldCwgaW5zdGFuY2VQcm9wcywgc2Nyb2xsYmFyU2l6ZSkge1xuICAgIHJldHVybiBnZXRPZmZzZXRGb3JJbmRleEFuZEFsaWdubWVudCgnY29sdW1uJywgcHJvcHMsIGluZGV4LCBhbGlnbiwgc2Nyb2xsT2Zmc2V0LCBpbnN0YW5jZVByb3BzLCBzY3JvbGxiYXJTaXplKTtcbiAgfSxcbiAgZ2V0T2Zmc2V0Rm9yUm93QW5kQWxpZ25tZW50OiBmdW5jdGlvbiBnZXRPZmZzZXRGb3JSb3dBbmRBbGlnbm1lbnQocHJvcHMsIGluZGV4LCBhbGlnbiwgc2Nyb2xsT2Zmc2V0LCBpbnN0YW5jZVByb3BzLCBzY3JvbGxiYXJTaXplKSB7XG4gICAgcmV0dXJuIGdldE9mZnNldEZvckluZGV4QW5kQWxpZ25tZW50KCdyb3cnLCBwcm9wcywgaW5kZXgsIGFsaWduLCBzY3JvbGxPZmZzZXQsIGluc3RhbmNlUHJvcHMsIHNjcm9sbGJhclNpemUpO1xuICB9LFxuICBnZXRSb3dPZmZzZXQ6IGZ1bmN0aW9uIGdldFJvd09mZnNldChwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpIHtcbiAgICByZXR1cm4gZ2V0SXRlbU1ldGFkYXRhKCdyb3cnLCBwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpLm9mZnNldDtcbiAgfSxcbiAgZ2V0Um93SGVpZ2h0OiBmdW5jdGlvbiBnZXRSb3dIZWlnaHQocHJvcHMsIGluZGV4LCBpbnN0YW5jZVByb3BzKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlUHJvcHMucm93TWV0YWRhdGFNYXBbaW5kZXhdLnNpemU7XG4gIH0sXG4gIGdldFJvd1N0YXJ0SW5kZXhGb3JPZmZzZXQ6IGZ1bmN0aW9uIGdldFJvd1N0YXJ0SW5kZXhGb3JPZmZzZXQocHJvcHMsIHNjcm9sbFRvcCwgaW5zdGFuY2VQcm9wcykge1xuICAgIHJldHVybiBmaW5kTmVhcmVzdEl0ZW0oJ3JvdycsIHByb3BzLCBpbnN0YW5jZVByb3BzLCBzY3JvbGxUb3ApO1xuICB9LFxuICBnZXRSb3dTdG9wSW5kZXhGb3JTdGFydEluZGV4OiBmdW5jdGlvbiBnZXRSb3dTdG9wSW5kZXhGb3JTdGFydEluZGV4KHByb3BzLCBzdGFydEluZGV4LCBzY3JvbGxUb3AsIGluc3RhbmNlUHJvcHMpIHtcbiAgICB2YXIgcm93Q291bnQgPSBwcm9wcy5yb3dDb3VudCxcbiAgICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0O1xuICAgIHZhciBpdGVtTWV0YWRhdGEgPSBnZXRJdGVtTWV0YWRhdGEoJ3JvdycsIHByb3BzLCBzdGFydEluZGV4LCBpbnN0YW5jZVByb3BzKTtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gc2Nyb2xsVG9wICsgaGVpZ2h0O1xuICAgIHZhciBvZmZzZXQgPSBpdGVtTWV0YWRhdGEub2Zmc2V0ICsgaXRlbU1ldGFkYXRhLnNpemU7XG4gICAgdmFyIHN0b3BJbmRleCA9IHN0YXJ0SW5kZXg7XG5cbiAgICB3aGlsZSAoc3RvcEluZGV4IDwgcm93Q291bnQgLSAxICYmIG9mZnNldCA8IG1heE9mZnNldCkge1xuICAgICAgc3RvcEluZGV4Kys7XG4gICAgICBvZmZzZXQgKz0gZ2V0SXRlbU1ldGFkYXRhKCdyb3cnLCBwcm9wcywgc3RvcEluZGV4LCBpbnN0YW5jZVByb3BzKS5zaXplO1xuICAgIH1cblxuICAgIHJldHVybiBzdG9wSW5kZXg7XG4gIH0sXG4gIGluaXRJbnN0YW5jZVByb3BzOiBmdW5jdGlvbiBpbml0SW5zdGFuY2VQcm9wcyhwcm9wcywgaW5zdGFuY2UpIHtcbiAgICB2YXIgX3JlZjUgPSBwcm9wcyxcbiAgICAgICAgZXN0aW1hdGVkQ29sdW1uV2lkdGggPSBfcmVmNS5lc3RpbWF0ZWRDb2x1bW5XaWR0aCxcbiAgICAgICAgZXN0aW1hdGVkUm93SGVpZ2h0ID0gX3JlZjUuZXN0aW1hdGVkUm93SGVpZ2h0O1xuICAgIHZhciBpbnN0YW5jZVByb3BzID0ge1xuICAgICAgY29sdW1uTWV0YWRhdGFNYXA6IHt9LFxuICAgICAgZXN0aW1hdGVkQ29sdW1uV2lkdGg6IGVzdGltYXRlZENvbHVtbldpZHRoIHx8IERFRkFVTFRfRVNUSU1BVEVEX0lURU1fU0laRSxcbiAgICAgIGVzdGltYXRlZFJvd0hlaWdodDogZXN0aW1hdGVkUm93SGVpZ2h0IHx8IERFRkFVTFRfRVNUSU1BVEVEX0lURU1fU0laRSxcbiAgICAgIGxhc3RNZWFzdXJlZENvbHVtbkluZGV4OiAtMSxcbiAgICAgIGxhc3RNZWFzdXJlZFJvd0luZGV4OiAtMSxcbiAgICAgIHJvd01ldGFkYXRhTWFwOiB7fVxuICAgIH07XG5cbiAgICBpbnN0YW5jZS5yZXNldEFmdGVyQ29sdW1uSW5kZXggPSBmdW5jdGlvbiAoY29sdW1uSW5kZXgsIHNob3VsZEZvcmNlVXBkYXRlKSB7XG4gICAgICBpZiAoc2hvdWxkRm9yY2VVcGRhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBzaG91bGRGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLnJlc2V0QWZ0ZXJJbmRpY2VzKHtcbiAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbkluZGV4LFxuICAgICAgICBzaG91bGRGb3JjZVVwZGF0ZTogc2hvdWxkRm9yY2VVcGRhdGVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5yZXNldEFmdGVyUm93SW5kZXggPSBmdW5jdGlvbiAocm93SW5kZXgsIHNob3VsZEZvcmNlVXBkYXRlKSB7XG4gICAgICBpZiAoc2hvdWxkRm9yY2VVcGRhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBzaG91bGRGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLnJlc2V0QWZ0ZXJJbmRpY2VzKHtcbiAgICAgICAgcm93SW5kZXg6IHJvd0luZGV4LFxuICAgICAgICBzaG91bGRGb3JjZVVwZGF0ZTogc2hvdWxkRm9yY2VVcGRhdGVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5yZXNldEFmdGVySW5kaWNlcyA9IGZ1bmN0aW9uIChfcmVmNikge1xuICAgICAgdmFyIGNvbHVtbkluZGV4ID0gX3JlZjYuY29sdW1uSW5kZXgsXG4gICAgICAgICAgcm93SW5kZXggPSBfcmVmNi5yb3dJbmRleCxcbiAgICAgICAgICBfcmVmNiRzaG91bGRGb3JjZVVwZGEgPSBfcmVmNi5zaG91bGRGb3JjZVVwZGF0ZSxcbiAgICAgICAgICBzaG91bGRGb3JjZVVwZGF0ZSA9IF9yZWY2JHNob3VsZEZvcmNlVXBkYSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWY2JHNob3VsZEZvcmNlVXBkYTtcblxuICAgICAgaWYgKHR5cGVvZiBjb2x1bW5JbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5zdGFuY2VQcm9wcy5sYXN0TWVhc3VyZWRDb2x1bW5JbmRleCA9IE1hdGgubWluKGluc3RhbmNlUHJvcHMubGFzdE1lYXN1cmVkQ29sdW1uSW5kZXgsIGNvbHVtbkluZGV4IC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygcm93SW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIGluc3RhbmNlUHJvcHMubGFzdE1lYXN1cmVkUm93SW5kZXggPSBNYXRoLm1pbihpbnN0YW5jZVByb3BzLmxhc3RNZWFzdXJlZFJvd0luZGV4LCByb3dJbmRleCAtIDEpO1xuICAgICAgfSAvLyBXZSBjb3VsZCBwb3RlbnRpYWxseSBvcHRpbWl6ZSBmdXJ0aGVyIGJ5IG9ubHkgZXZpY3Rpbmcgc3R5bGVzIGFmdGVyIHRoaXMgaW5kZXgsXG4gICAgICAvLyBCdXQgc2luY2Ugc3R5bGVzIGFyZSBvbmx5IGNhY2hlZCB3aGlsZSBzY3JvbGxpbmcgaXMgaW4gcHJvZ3Jlc3MtXG4gICAgICAvLyBJdCBzZWVtcyBhbiB1bm5lY2Vzc2FyeSBvcHRpbWl6YXRpb24uXG4gICAgICAvLyBJdCdzIHVubGlrZWx5IHRoYXQgcmVzZXRBZnRlckluZGV4KCkgd2lsbCBiZSBjYWxsZWQgd2hpbGUgYSB1c2VyIGlzIHNjcm9sbGluZy5cblxuXG4gICAgICBpbnN0YW5jZS5fZ2V0SXRlbVN0eWxlQ2FjaGUoLTEpO1xuXG4gICAgICBpZiAoc2hvdWxkRm9yY2VVcGRhdGUpIHtcbiAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGluc3RhbmNlUHJvcHM7XG4gIH0sXG4gIHNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2U6IGZhbHNlLFxuICB2YWxpZGF0ZVByb3BzOiBmdW5jdGlvbiB2YWxpZGF0ZVByb3BzKF9yZWY3KSB7XG4gICAgdmFyIGNvbHVtbldpZHRoID0gX3JlZjcuY29sdW1uV2lkdGgsXG4gICAgICAgIHJvd0hlaWdodCA9IF9yZWY3LnJvd0hlaWdodDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbHVtbldpZHRoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwiY29sdW1uV2lkdGhcIiBwcm9wIGhhcyBiZWVuIHNwZWNpZmllZC4gJyArICdWYWx1ZSBzaG91bGQgYmUgYSBmdW5jdGlvbi4gJyArIChcIlxcXCJcIiArIChjb2x1bW5XaWR0aCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBjb2x1bW5XaWR0aCkgKyBcIlxcXCIgd2FzIHNwZWNpZmllZC5cIikpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygcm93SGVpZ2h0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwicm93SGVpZ2h0XCIgcHJvcCBoYXMgYmVlbiBzcGVjaWZpZWQuICcgKyAnVmFsdWUgc2hvdWxkIGJlIGEgZnVuY3Rpb24uICcgKyAoXCJcXFwiXCIgKyAocm93SGVpZ2h0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJvd0hlaWdodCkgKyBcIlxcXCIgd2FzIHNwZWNpZmllZC5cIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBJU19TQ1JPTExJTkdfREVCT1VOQ0VfSU5URVJWQUwkMSA9IDE1MDtcblxudmFyIGRlZmF1bHRJdGVtS2V5JDEgPSBmdW5jdGlvbiBkZWZhdWx0SXRlbUtleShpbmRleCwgZGF0YSkge1xuICByZXR1cm4gaW5kZXg7XG59OyAvLyBJbiBERVYgbW9kZSwgdGhpcyBTZXQgaGVscHMgdXMgb25seSBsb2cgYSB3YXJuaW5nIG9uY2UgcGVyIGNvbXBvbmVudCBpbnN0YW5jZS5cbi8vIFRoaXMgYXZvaWRzIHNwYW1taW5nIHRoZSBjb25zb2xlIGV2ZXJ5IHRpbWUgYSByZW5kZXIgaGFwcGVucy5cblxuXG52YXIgZGV2V2FybmluZ3NEaXJlY3Rpb24gPSBudWxsO1xudmFyIGRldldhcm5pbmdzVGFnTmFtZSQxID0gbnVsbDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkZXZXYXJuaW5nc0RpcmVjdGlvbiA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha1NldCgpO1xuICAgIGRldldhcm5pbmdzVGFnTmFtZSQxID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlzdENvbXBvbmVudChfcmVmKSB7XG4gIHZhciBfY2xhc3M7XG5cbiAgdmFyIGdldEl0ZW1PZmZzZXQgPSBfcmVmLmdldEl0ZW1PZmZzZXQsXG4gICAgICBnZXRFc3RpbWF0ZWRUb3RhbFNpemUgPSBfcmVmLmdldEVzdGltYXRlZFRvdGFsU2l6ZSxcbiAgICAgIGdldEl0ZW1TaXplID0gX3JlZi5nZXRJdGVtU2l6ZSxcbiAgICAgIGdldE9mZnNldEZvckluZGV4QW5kQWxpZ25tZW50ID0gX3JlZi5nZXRPZmZzZXRGb3JJbmRleEFuZEFsaWdubWVudCxcbiAgICAgIGdldFN0YXJ0SW5kZXhGb3JPZmZzZXQgPSBfcmVmLmdldFN0YXJ0SW5kZXhGb3JPZmZzZXQsXG4gICAgICBnZXRTdG9wSW5kZXhGb3JTdGFydEluZGV4ID0gX3JlZi5nZXRTdG9wSW5kZXhGb3JTdGFydEluZGV4LFxuICAgICAgaW5pdEluc3RhbmNlUHJvcHMgPSBfcmVmLmluaXRJbnN0YW5jZVByb3BzLFxuICAgICAgc2hvdWxkUmVzZXRTdHlsZUNhY2hlT25JdGVtU2l6ZUNoYW5nZSA9IF9yZWYuc2hvdWxkUmVzZXRTdHlsZUNhY2hlT25JdGVtU2l6ZUNoYW5nZSxcbiAgICAgIHZhbGlkYXRlUHJvcHMgPSBfcmVmLnZhbGlkYXRlUHJvcHM7XG4gIHJldHVybiBfY2xhc3MgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QdXJlQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTGlzdCwgX1B1cmVDb21wb25lbnQpO1xuXG4gICAgLy8gQWx3YXlzIHVzZSBleHBsaWNpdCBjb25zdHJ1Y3RvciBmb3IgUmVhY3QgY29tcG9uZW50cy5cbiAgICAvLyBJdCBwcm9kdWNlcyBsZXNzIGNvZGUgYWZ0ZXIgdHJhbnNwaWxhdGlvbi4gKCMyNilcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jb25zdHJ1Y3RvclxuICAgIGZ1bmN0aW9uIExpc3QocHJvcHMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfUHVyZUNvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuX2luc3RhbmNlUHJvcHMgPSBpbml0SW5zdGFuY2VQcm9wcyhfdGhpcy5wcm9wcywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgX3RoaXMuX291dGVyUmVmID0gdm9pZCAwO1xuICAgICAgX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmdUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgIGluc3RhbmNlOiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSxcbiAgICAgICAgaXNTY3JvbGxpbmc6IGZhbHNlLFxuICAgICAgICBzY3JvbGxEaXJlY3Rpb246ICdmb3J3YXJkJyxcbiAgICAgICAgc2Nyb2xsT2Zmc2V0OiB0eXBlb2YgX3RoaXMucHJvcHMuaW5pdGlhbFNjcm9sbE9mZnNldCA9PT0gJ251bWJlcicgPyBfdGhpcy5wcm9wcy5pbml0aWFsU2Nyb2xsT2Zmc2V0IDogMCxcbiAgICAgICAgc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIF90aGlzLl9jYWxsT25JdGVtc1JlbmRlcmVkID0gdm9pZCAwO1xuICAgICAgX3RoaXMuX2NhbGxPbkl0ZW1zUmVuZGVyZWQgPSBtZW1vaXplT25lKGZ1bmN0aW9uIChvdmVyc2NhblN0YXJ0SW5kZXgsIG92ZXJzY2FuU3RvcEluZGV4LCB2aXNpYmxlU3RhcnRJbmRleCwgdmlzaWJsZVN0b3BJbmRleCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMub25JdGVtc1JlbmRlcmVkKHtcbiAgICAgICAgICBvdmVyc2NhblN0YXJ0SW5kZXg6IG92ZXJzY2FuU3RhcnRJbmRleCxcbiAgICAgICAgICBvdmVyc2NhblN0b3BJbmRleDogb3ZlcnNjYW5TdG9wSW5kZXgsXG4gICAgICAgICAgdmlzaWJsZVN0YXJ0SW5kZXg6IHZpc2libGVTdGFydEluZGV4LFxuICAgICAgICAgIHZpc2libGVTdG9wSW5kZXg6IHZpc2libGVTdG9wSW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLl9jYWxsT25TY3JvbGwgPSB2b2lkIDA7XG4gICAgICBfdGhpcy5fY2FsbE9uU2Nyb2xsID0gbWVtb2l6ZU9uZShmdW5jdGlvbiAoc2Nyb2xsRGlyZWN0aW9uLCBzY3JvbGxPZmZzZXQsIHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZCkge1xuICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMub25TY3JvbGwoe1xuICAgICAgICAgIHNjcm9sbERpcmVjdGlvbjogc2Nyb2xsRGlyZWN0aW9uLFxuICAgICAgICAgIHNjcm9sbE9mZnNldDogc2Nyb2xsT2Zmc2V0LFxuICAgICAgICAgIHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZDogc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBfdGhpcy5fZ2V0SXRlbVN0eWxlID0gdm9pZCAwO1xuXG4gICAgICBfdGhpcy5fZ2V0SXRlbVN0eWxlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgICAgZGlyZWN0aW9uID0gX3RoaXMkcHJvcHMuZGlyZWN0aW9uLFxuICAgICAgICAgICAgaXRlbVNpemUgPSBfdGhpcyRwcm9wcy5pdGVtU2l6ZSxcbiAgICAgICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzLmxheW91dDtcblxuICAgICAgICB2YXIgaXRlbVN0eWxlQ2FjaGUgPSBfdGhpcy5fZ2V0SXRlbVN0eWxlQ2FjaGUoc2hvdWxkUmVzZXRTdHlsZUNhY2hlT25JdGVtU2l6ZUNoYW5nZSAmJiBpdGVtU2l6ZSwgc2hvdWxkUmVzZXRTdHlsZUNhY2hlT25JdGVtU2l6ZUNoYW5nZSAmJiBsYXlvdXQsIHNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2UgJiYgZGlyZWN0aW9uKTtcblxuICAgICAgICB2YXIgc3R5bGU7XG5cbiAgICAgICAgaWYgKGl0ZW1TdHlsZUNhY2hlLmhhc093blByb3BlcnR5KGluZGV4KSkge1xuICAgICAgICAgIHN0eWxlID0gaXRlbVN0eWxlQ2FjaGVbaW5kZXhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfb2Zmc2V0ID0gZ2V0SXRlbU9mZnNldChfdGhpcy5wcm9wcywgaW5kZXgsIF90aGlzLl9pbnN0YW5jZVByb3BzKTtcblxuICAgICAgICAgIHZhciBzaXplID0gZ2V0SXRlbVNpemUoX3RoaXMucHJvcHMsIGluZGV4LCBfdGhpcy5faW5zdGFuY2VQcm9wcyk7IC8vIFRPRE8gRGVwcmVjYXRlIGRpcmVjdGlvbiBcImhvcml6b250YWxcIlxuXG4gICAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnIHx8IGxheW91dCA9PT0gJ2hvcml6b250YWwnO1xuICAgICAgICAgIHZhciBpc1J0bCA9IGRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgICAgICAgdmFyIG9mZnNldEhvcml6b250YWwgPSBpc0hvcml6b250YWwgPyBfb2Zmc2V0IDogMDtcbiAgICAgICAgICBpdGVtU3R5bGVDYWNoZVtpbmRleF0gPSBzdHlsZSA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgbGVmdDogaXNSdGwgPyB1bmRlZmluZWQgOiBvZmZzZXRIb3Jpem9udGFsLFxuICAgICAgICAgICAgcmlnaHQ6IGlzUnRsID8gb2Zmc2V0SG9yaXpvbnRhbCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRvcDogIWlzSG9yaXpvbnRhbCA/IF9vZmZzZXQgOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAhaXNIb3Jpem9udGFsID8gc2l6ZSA6ICcxMDAlJyxcbiAgICAgICAgICAgIHdpZHRoOiBpc0hvcml6b250YWwgPyBzaXplIDogJzEwMCUnXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLl9nZXRJdGVtU3R5bGVDYWNoZSA9IHZvaWQgMDtcbiAgICAgIF90aGlzLl9nZXRJdGVtU3R5bGVDYWNoZSA9IG1lbW9pemVPbmUoZnVuY3Rpb24gKF8sIF9fLCBfX18pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLl9vblNjcm9sbEhvcml6b250YWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9ldmVudCRjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgICAgIGNsaWVudFdpZHRoID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbFdpZHRoID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQuc2Nyb2xsV2lkdGg7XG5cbiAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgICAgICAgIGlmIChwcmV2U3RhdGUuc2Nyb2xsT2Zmc2V0ID09PSBzY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAvLyBTY3JvbGwgcG9zaXRpb24gbWF5IGhhdmUgYmVlbiB1cGRhdGVkIGJ5IGNETS9jRFUsXG4gICAgICAgICAgICAvLyBJbiB3aGljaCBjYXNlIHdlIGRvbid0IG5lZWQgdG8gdHJpZ2dlciBhbm90aGVyIHJlbmRlcixcbiAgICAgICAgICAgIC8vIEFuZCB3ZSBkb24ndCB3YW50IHRvIHVwZGF0ZSBzdGF0ZS5pc1Njcm9sbGluZy5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBfdGhpcy5wcm9wcy5kaXJlY3Rpb247XG4gICAgICAgICAgdmFyIHNjcm9sbE9mZnNldCA9IHNjcm9sbExlZnQ7XG5cbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgLy8gVFJJQ0tZIEFjY29yZGluZyB0byB0aGUgc3BlYywgc2Nyb2xsTGVmdCBzaG91bGQgYmUgbmVnYXRpdmUgZm9yIFJUTCBhbGlnbmVkIGVsZW1lbnRzLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBub3QgdGhlIGNhc2UgZm9yIGFsbCBicm93c2VycyB0aG91Z2ggKGUuZy4gQ2hyb21lIHJlcG9ydHMgdmFsdWVzIGFzIHBvc2l0aXZlLCBtZWFzdXJlZCByZWxhdGl2ZSB0byB0aGUgbGVmdCkuXG4gICAgICAgICAgICAvLyBJdCdzIGFsc28gZWFzaWVyIGZvciB0aGlzIGNvbXBvbmVudCBpZiB3ZSBjb252ZXJ0IG9mZnNldHMgdG8gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZXkgd291bGQgYmUgaW4gZm9yIGx0ci5cbiAgICAgICAgICAgIC8vIFNvIHRoZSBzaW1wbGVzdCBzb2x1dGlvbiBpcyB0byBkZXRlcm1pbmUgd2hpY2ggYnJvd3NlciBiZWhhdmlvciB3ZSdyZSBkZWFsaW5nIHdpdGgsIGFuZCBjb252ZXJ0IGJhc2VkIG9uIGl0LlxuICAgICAgICAgICAgc3dpdGNoIChnZXRSVExPZmZzZXRUeXBlKCkpIHtcbiAgICAgICAgICAgICAgY2FzZSAnbmVnYXRpdmUnOlxuICAgICAgICAgICAgICAgIHNjcm9sbE9mZnNldCA9IC1zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ3Bvc2l0aXZlLWRlc2NlbmRpbmcnOlxuICAgICAgICAgICAgICAgIHNjcm9sbE9mZnNldCA9IHNjcm9sbFdpZHRoIC0gY2xpZW50V2lkdGggLSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gUHJldmVudCBTYWZhcmkncyBlbGFzdGljIHNjcm9sbGluZyBmcm9tIGNhdXNpbmcgdmlzdWFsIHNoYWtpbmcgd2hlbiBzY3JvbGxpbmcgcGFzdCBib3VuZHMuXG5cblxuICAgICAgICAgIHNjcm9sbE9mZnNldCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbE9mZnNldCwgc2Nyb2xsV2lkdGggLSBjbGllbnRXaWR0aCkpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1Njcm9sbGluZzogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbERpcmVjdGlvbjogcHJldlN0YXRlLnNjcm9sbE9mZnNldCA8IHNjcm9sbE9mZnNldCA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCcsXG4gICAgICAgICAgICBzY3JvbGxPZmZzZXQ6IHNjcm9sbE9mZnNldCxcbiAgICAgICAgICAgIHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9LCBfdGhpcy5fcmVzZXRJc1Njcm9sbGluZ0RlYm91bmNlZCk7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5fb25TY3JvbGxWZXJ0aWNhbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX2V2ZW50JGN1cnJlbnRUYXJnZXQyID0gZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgICAgIGNsaWVudEhlaWdodCA9IF9ldmVudCRjdXJyZW50VGFyZ2V0Mi5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICBzY3JvbGxIZWlnaHQgPSBfZXZlbnQkY3VycmVudFRhcmdldDIuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgc2Nyb2xsVG9wID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQyLnNjcm9sbFRvcDtcblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICAgICAgaWYgKHByZXZTdGF0ZS5zY3JvbGxPZmZzZXQgPT09IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgLy8gU2Nyb2xsIHBvc2l0aW9uIG1heSBoYXZlIGJlZW4gdXBkYXRlZCBieSBjRE0vY0RVLFxuICAgICAgICAgICAgLy8gSW4gd2hpY2ggY2FzZSB3ZSBkb24ndCBuZWVkIHRvIHRyaWdnZXIgYW5vdGhlciByZW5kZXIsXG4gICAgICAgICAgICAvLyBBbmQgd2UgZG9uJ3Qgd2FudCB0byB1cGRhdGUgc3RhdGUuaXNTY3JvbGxpbmcuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IC8vIFByZXZlbnQgU2FmYXJpJ3MgZWxhc3RpYyBzY3JvbGxpbmcgZnJvbSBjYXVzaW5nIHZpc3VhbCBzaGFraW5nIHdoZW4gc2Nyb2xsaW5nIHBhc3QgYm91bmRzLlxuXG5cbiAgICAgICAgICB2YXIgc2Nyb2xsT2Zmc2V0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQgLSBjbGllbnRIZWlnaHQpKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNTY3JvbGxpbmc6IHRydWUsXG4gICAgICAgICAgICBzY3JvbGxEaXJlY3Rpb246IHByZXZTdGF0ZS5zY3JvbGxPZmZzZXQgPCBzY3JvbGxPZmZzZXQgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnLFxuICAgICAgICAgICAgc2Nyb2xsT2Zmc2V0OiBzY3JvbGxPZmZzZXQsXG4gICAgICAgICAgICBzY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmdEZWJvdW5jZWQpO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuX291dGVyUmVmU2V0dGVyID0gZnVuY3Rpb24gKHJlZikge1xuICAgICAgICB2YXIgb3V0ZXJSZWYgPSBfdGhpcy5wcm9wcy5vdXRlclJlZjtcbiAgICAgICAgX3RoaXMuX291dGVyUmVmID0gcmVmO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3V0ZXJSZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvdXRlclJlZihyZWYpO1xuICAgICAgICB9IGVsc2UgaWYgKG91dGVyUmVmICE9IG51bGwgJiYgdHlwZW9mIG91dGVyUmVmID09PSAnb2JqZWN0JyAmJiBvdXRlclJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgICAgb3V0ZXJSZWYuY3VycmVudCA9IHJlZjtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmdEZWJvdW5jZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5fcmVzZXRJc1Njcm9sbGluZ1RpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNhbmNlbFRpbWVvdXQoX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmdUaW1lb3V0SWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmdUaW1lb3V0SWQgPSByZXF1ZXN0VGltZW91dChfdGhpcy5fcmVzZXRJc1Njcm9sbGluZywgSVNfU0NST0xMSU5HX0RFQk9VTkNFX0lOVEVSVkFMJDEpO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuX3Jlc2V0SXNTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkID0gbnVsbDtcblxuICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaXNTY3JvbGxpbmc6IGZhbHNlXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBDbGVhciBzdHlsZSBjYWNoZSBhZnRlciBzdGF0ZSB1cGRhdGUgaGFzIGJlZW4gY29tbWl0dGVkLlxuICAgICAgICAgIC8vIFRoaXMgd2F5IHdlIGRvbid0IGJyZWFrIHB1cmUgc0NVIGZvciBpdGVtcyB0aGF0IGRvbid0IHVzZSBpc1Njcm9sbGluZyBwYXJhbS5cbiAgICAgICAgICBfdGhpcy5fZ2V0SXRlbVN0eWxlQ2FjaGUoLTEsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBMaXN0LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgdmFsaWRhdGVTaGFyZWRQcm9wcyQxKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIHZhbGlkYXRlUHJvcHMobmV4dFByb3BzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgX3Byb3RvID0gTGlzdC5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc2Nyb2xsVG8gPSBmdW5jdGlvbiBzY3JvbGxUbyhzY3JvbGxPZmZzZXQpIHtcbiAgICAgIHNjcm9sbE9mZnNldCA9IE1hdGgubWF4KDAsIHNjcm9sbE9mZnNldCk7XG4gICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgICAgaWYgKHByZXZTdGF0ZS5zY3JvbGxPZmZzZXQgPT09IHNjcm9sbE9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzY3JvbGxEaXJlY3Rpb246IHByZXZTdGF0ZS5zY3JvbGxPZmZzZXQgPCBzY3JvbGxPZmZzZXQgPyAnZm9yd2FyZCcgOiAnYmFja3dhcmQnLFxuICAgICAgICAgIHNjcm9sbE9mZnNldDogc2Nyb2xsT2Zmc2V0LFxuICAgICAgICAgIHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSwgdGhpcy5fcmVzZXRJc1Njcm9sbGluZ0RlYm91bmNlZCk7XG4gICAgfTtcblxuICAgIF9wcm90by5zY3JvbGxUb0l0ZW0gPSBmdW5jdGlvbiBzY3JvbGxUb0l0ZW0oaW5kZXgsIGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09IHZvaWQgMCkge1xuICAgICAgICBhbGlnbiA9ICdhdXRvJztcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgaXRlbUNvdW50ID0gX3RoaXMkcHJvcHMyLml0ZW1Db3VudCxcbiAgICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wczIubGF5b3V0O1xuICAgICAgdmFyIHNjcm9sbE9mZnNldCA9IHRoaXMuc3RhdGUuc2Nyb2xsT2Zmc2V0O1xuICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgaXRlbUNvdW50IC0gMSkpOyAvLyBUaGUgc2Nyb2xsYmFyIHNpemUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgd2hlbiBzY3JvbGxpbmcgYW4gaXRlbSBpbnRvIHZpZXcsIHRvIGVuc3VyZSBpdCdzIGZ1bGx5IHZpc2libGUuXG4gICAgICAvLyBCdXQgd2Ugb25seSBuZWVkIHRvIGFjY291bnQgZm9yIGl0cyBzaXplIHdoZW4gaXQncyBhY3R1YWxseSB2aXNpYmxlLlxuICAgICAgLy8gVGhpcyBpcyBhbiBlZGdlIGNhc2UgZm9yIGxpc3RzOyBub3JtYWxseSB0aGV5IG9ubHkgc2Nyb2xsIGluIHRoZSBkb21pbmFudCBkaXJlY3Rpb24uXG5cbiAgICAgIHZhciBzY3JvbGxiYXJTaXplID0gMDtcblxuICAgICAgaWYgKHRoaXMuX291dGVyUmVmKSB7XG4gICAgICAgIHZhciBvdXRlclJlZiA9IHRoaXMuX291dGVyUmVmO1xuXG4gICAgICAgIGlmIChsYXlvdXQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICBzY3JvbGxiYXJTaXplID0gb3V0ZXJSZWYuc2Nyb2xsV2lkdGggPiBvdXRlclJlZi5jbGllbnRXaWR0aCA/IGdldFNjcm9sbGJhclNpemUoKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Nyb2xsYmFyU2l6ZSA9IG91dGVyUmVmLnNjcm9sbEhlaWdodCA+IG91dGVyUmVmLmNsaWVudEhlaWdodCA/IGdldFNjcm9sbGJhclNpemUoKSA6IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGxUbyhnZXRPZmZzZXRGb3JJbmRleEFuZEFsaWdubWVudCh0aGlzLnByb3BzLCBpbmRleCwgYWxpZ24sIHNjcm9sbE9mZnNldCwgdGhpcy5faW5zdGFuY2VQcm9wcywgc2Nyb2xsYmFyU2l6ZSkpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IF90aGlzJHByb3BzMy5kaXJlY3Rpb24sXG4gICAgICAgICAgaW5pdGlhbFNjcm9sbE9mZnNldCA9IF90aGlzJHByb3BzMy5pbml0aWFsU2Nyb2xsT2Zmc2V0LFxuICAgICAgICAgIGxheW91dCA9IF90aGlzJHByb3BzMy5sYXlvdXQ7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFNjcm9sbE9mZnNldCA9PT0gJ251bWJlcicgJiYgdGhpcy5fb3V0ZXJSZWYgIT0gbnVsbCkge1xuICAgICAgICB2YXIgb3V0ZXJSZWYgPSB0aGlzLl9vdXRlclJlZjsgLy8gVE9ETyBEZXByZWNhdGUgZGlyZWN0aW9uIFwiaG9yaXpvbnRhbFwiXG5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnIHx8IGxheW91dCA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgb3V0ZXJSZWYuc2Nyb2xsTGVmdCA9IGluaXRpYWxTY3JvbGxPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ZXJSZWYuc2Nyb2xsVG9wID0gaW5pdGlhbFNjcm9sbE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYWxsUHJvcHNDYWxsYmFja3MoKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGRpcmVjdGlvbiA9IF90aGlzJHByb3BzNC5kaXJlY3Rpb24sXG4gICAgICAgICAgbGF5b3V0ID0gX3RoaXMkcHJvcHM0LmxheW91dDtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgc2Nyb2xsT2Zmc2V0ID0gX3RoaXMkc3RhdGUuc2Nyb2xsT2Zmc2V0LFxuICAgICAgICAgIHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZCA9IF90aGlzJHN0YXRlLnNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZDtcblxuICAgICAgaWYgKHNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZCAmJiB0aGlzLl9vdXRlclJlZiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvdXRlclJlZiA9IHRoaXMuX291dGVyUmVmOyAvLyBUT0RPIERlcHJlY2F0ZSBkaXJlY3Rpb24gXCJob3Jpem9udGFsXCJcblxuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgfHwgbGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgLy8gVFJJQ0tZIEFjY29yZGluZyB0byB0aGUgc3BlYywgc2Nyb2xsTGVmdCBzaG91bGQgYmUgbmVnYXRpdmUgZm9yIFJUTCBhbGlnbmVkIGVsZW1lbnRzLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBub3QgdGhlIGNhc2UgZm9yIGFsbCBicm93c2VycyB0aG91Z2ggKGUuZy4gQ2hyb21lIHJlcG9ydHMgdmFsdWVzIGFzIHBvc2l0aXZlLCBtZWFzdXJlZCByZWxhdGl2ZSB0byB0aGUgbGVmdCkuXG4gICAgICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGljaCBicm93c2VyIGJlaGF2aW9yIHdlJ3JlIGRlYWxpbmcgd2l0aCwgYW5kIG1pbWljIGl0LlxuICAgICAgICAgICAgc3dpdGNoIChnZXRSVExPZmZzZXRUeXBlKCkpIHtcbiAgICAgICAgICAgICAgY2FzZSAnbmVnYXRpdmUnOlxuICAgICAgICAgICAgICAgIG91dGVyUmVmLnNjcm9sbExlZnQgPSAtc2Nyb2xsT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ3Bvc2l0aXZlLWFzY2VuZGluZyc6XG4gICAgICAgICAgICAgICAgb3V0ZXJSZWYuc2Nyb2xsTGVmdCA9IHNjcm9sbE9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBjbGllbnRXaWR0aCA9IG91dGVyUmVmLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxXaWR0aCA9IG91dGVyUmVmLnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgICAgIG91dGVyUmVmLnNjcm9sbExlZnQgPSBzY3JvbGxXaWR0aCAtIGNsaWVudFdpZHRoIC0gc2Nyb2xsT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRlclJlZi5zY3JvbGxMZWZ0ID0gc2Nyb2xsT2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRlclJlZi5zY3JvbGxUb3AgPSBzY3JvbGxPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FsbFByb3BzQ2FsbGJhY2tzKCk7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuX3Jlc2V0SXNTY3JvbGxpbmdUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgY2FuY2VsVGltZW91dCh0aGlzLl9yZXNldElzU2Nyb2xsaW5nVGltZW91dElkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczUgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHM1LmNoaWxkcmVuLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzNS5jbGFzc05hbWUsXG4gICAgICAgICAgZGlyZWN0aW9uID0gX3RoaXMkcHJvcHM1LmRpcmVjdGlvbixcbiAgICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczUuaGVpZ2h0LFxuICAgICAgICAgIGlubmVyUmVmID0gX3RoaXMkcHJvcHM1LmlubmVyUmVmLFxuICAgICAgICAgIGlubmVyRWxlbWVudFR5cGUgPSBfdGhpcyRwcm9wczUuaW5uZXJFbGVtZW50VHlwZSxcbiAgICAgICAgICBpbm5lclRhZ05hbWUgPSBfdGhpcyRwcm9wczUuaW5uZXJUYWdOYW1lLFxuICAgICAgICAgIGl0ZW1Db3VudCA9IF90aGlzJHByb3BzNS5pdGVtQ291bnQsXG4gICAgICAgICAgaXRlbURhdGEgPSBfdGhpcyRwcm9wczUuaXRlbURhdGEsXG4gICAgICAgICAgX3RoaXMkcHJvcHM1JGl0ZW1LZXkgPSBfdGhpcyRwcm9wczUuaXRlbUtleSxcbiAgICAgICAgICBpdGVtS2V5ID0gX3RoaXMkcHJvcHM1JGl0ZW1LZXkgPT09IHZvaWQgMCA/IGRlZmF1bHRJdGVtS2V5JDEgOiBfdGhpcyRwcm9wczUkaXRlbUtleSxcbiAgICAgICAgICBsYXlvdXQgPSBfdGhpcyRwcm9wczUubGF5b3V0LFxuICAgICAgICAgIG91dGVyRWxlbWVudFR5cGUgPSBfdGhpcyRwcm9wczUub3V0ZXJFbGVtZW50VHlwZSxcbiAgICAgICAgICBvdXRlclRhZ05hbWUgPSBfdGhpcyRwcm9wczUub3V0ZXJUYWdOYW1lLFxuICAgICAgICAgIHN0eWxlID0gX3RoaXMkcHJvcHM1LnN0eWxlLFxuICAgICAgICAgIHVzZUlzU2Nyb2xsaW5nID0gX3RoaXMkcHJvcHM1LnVzZUlzU2Nyb2xsaW5nLFxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM1LndpZHRoO1xuICAgICAgdmFyIGlzU2Nyb2xsaW5nID0gdGhpcy5zdGF0ZS5pc1Njcm9sbGluZzsgLy8gVE9ETyBEZXByZWNhdGUgZGlyZWN0aW9uIFwiaG9yaXpvbnRhbFwiXG5cbiAgICAgIHZhciBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyB8fCBsYXlvdXQgPT09ICdob3Jpem9udGFsJztcbiAgICAgIHZhciBvblNjcm9sbCA9IGlzSG9yaXpvbnRhbCA/IHRoaXMuX29uU2Nyb2xsSG9yaXpvbnRhbCA6IHRoaXMuX29uU2Nyb2xsVmVydGljYWw7XG5cbiAgICAgIHZhciBfdGhpcyRfZ2V0UmFuZ2VUb1JlbmQgPSB0aGlzLl9nZXRSYW5nZVRvUmVuZGVyKCksXG4gICAgICAgICAgc3RhcnRJbmRleCA9IF90aGlzJF9nZXRSYW5nZVRvUmVuZFswXSxcbiAgICAgICAgICBzdG9wSW5kZXggPSBfdGhpcyRfZ2V0UmFuZ2VUb1JlbmRbMV07XG5cbiAgICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgICBpZiAoaXRlbUNvdW50ID4gMCkge1xuICAgICAgICBmb3IgKHZhciBfaW5kZXggPSBzdGFydEluZGV4OyBfaW5kZXggPD0gc3RvcEluZGV4OyBfaW5kZXgrKykge1xuICAgICAgICAgIGl0ZW1zLnB1c2goY3JlYXRlRWxlbWVudChjaGlsZHJlbiwge1xuICAgICAgICAgICAgZGF0YTogaXRlbURhdGEsXG4gICAgICAgICAgICBrZXk6IGl0ZW1LZXkoX2luZGV4LCBpdGVtRGF0YSksXG4gICAgICAgICAgICBpbmRleDogX2luZGV4LFxuICAgICAgICAgICAgaXNTY3JvbGxpbmc6IHVzZUlzU2Nyb2xsaW5nID8gaXNTY3JvbGxpbmcgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzdHlsZTogdGhpcy5fZ2V0SXRlbVN0eWxlKF9pbmRleClcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVhZCB0aGlzIHZhbHVlIEFGVEVSIGl0ZW1zIGhhdmUgYmVlbiBjcmVhdGVkLFxuICAgICAgLy8gU28gdGhlaXIgYWN0dWFsIHNpemVzIChpZiB2YXJpYWJsZSkgYXJlIHRha2VuIGludG8gY29uc2lkZXJhdGlvbi5cblxuXG4gICAgICB2YXIgZXN0aW1hdGVkVG90YWxTaXplID0gZ2V0RXN0aW1hdGVkVG90YWxTaXplKHRoaXMucHJvcHMsIHRoaXMuX2luc3RhbmNlUHJvcHMpO1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQob3V0ZXJFbGVtZW50VHlwZSB8fCBvdXRlclRhZ05hbWUgfHwgJ2RpdicsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIG9uU2Nyb2xsOiBvblNjcm9sbCxcbiAgICAgICAgcmVmOiB0aGlzLl9vdXRlclJlZlNldHRlcixcbiAgICAgICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgICAgICBXZWJraXRPdmVyZmxvd1Njcm9sbGluZzogJ3RvdWNoJyxcbiAgICAgICAgICB3aWxsQ2hhbmdlOiAndHJhbnNmb3JtJyxcbiAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICB9LCBzdHlsZSlcbiAgICAgIH0sIGNyZWF0ZUVsZW1lbnQoaW5uZXJFbGVtZW50VHlwZSB8fCBpbm5lclRhZ05hbWUgfHwgJ2RpdicsIHtcbiAgICAgICAgY2hpbGRyZW46IGl0ZW1zLFxuICAgICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGhlaWdodDogaXNIb3Jpem9udGFsID8gJzEwMCUnIDogZXN0aW1hdGVkVG90YWxTaXplLFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IGlzU2Nyb2xsaW5nID8gJ25vbmUnIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHdpZHRoOiBpc0hvcml6b250YWwgPyBlc3RpbWF0ZWRUb3RhbFNpemUgOiAnMTAwJSdcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2NhbGxQcm9wc0NhbGxiYWNrcyA9IGZ1bmN0aW9uIF9jYWxsUHJvcHNDYWxsYmFja3MoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMub25JdGVtc1JlbmRlcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpdGVtQ291bnQgPSB0aGlzLnByb3BzLml0ZW1Db3VudDtcblxuICAgICAgICBpZiAoaXRlbUNvdW50ID4gMCkge1xuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0UmFuZ2VUb1JlbmQyID0gdGhpcy5fZ2V0UmFuZ2VUb1JlbmRlcigpLFxuICAgICAgICAgICAgICBfb3ZlcnNjYW5TdGFydEluZGV4ID0gX3RoaXMkX2dldFJhbmdlVG9SZW5kMlswXSxcbiAgICAgICAgICAgICAgX292ZXJzY2FuU3RvcEluZGV4ID0gX3RoaXMkX2dldFJhbmdlVG9SZW5kMlsxXSxcbiAgICAgICAgICAgICAgX3Zpc2libGVTdGFydEluZGV4ID0gX3RoaXMkX2dldFJhbmdlVG9SZW5kMlsyXSxcbiAgICAgICAgICAgICAgX3Zpc2libGVTdG9wSW5kZXggPSBfdGhpcyRfZ2V0UmFuZ2VUb1JlbmQyWzNdO1xuXG4gICAgICAgICAgdGhpcy5fY2FsbE9uSXRlbXNSZW5kZXJlZChfb3ZlcnNjYW5TdGFydEluZGV4LCBfb3ZlcnNjYW5TdG9wSW5kZXgsIF92aXNpYmxlU3RhcnRJbmRleCwgX3Zpc2libGVTdG9wSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy5vblNjcm9sbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgX3RoaXMkc3RhdGUyID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgIF9zY3JvbGxEaXJlY3Rpb24gPSBfdGhpcyRzdGF0ZTIuc2Nyb2xsRGlyZWN0aW9uLFxuICAgICAgICAgICAgX3Njcm9sbE9mZnNldCA9IF90aGlzJHN0YXRlMi5zY3JvbGxPZmZzZXQsXG4gICAgICAgICAgICBfc2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkID0gX3RoaXMkc3RhdGUyLnNjcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZDtcblxuICAgICAgICB0aGlzLl9jYWxsT25TY3JvbGwoX3Njcm9sbERpcmVjdGlvbiwgX3Njcm9sbE9mZnNldCwgX3Njcm9sbFVwZGF0ZVdhc1JlcXVlc3RlZCk7XG4gICAgICB9XG4gICAgfSAvLyBMYXppbHkgY3JlYXRlIGFuZCBjYWNoZSBpdGVtIHN0eWxlcyB3aGlsZSBzY3JvbGxpbmcsXG4gICAgLy8gU28gdGhhdCBwdXJlIGNvbXBvbmVudCBzQ1Ugd2lsbCBwcmV2ZW50IHJlLXJlbmRlcnMuXG4gICAgLy8gV2UgbWFpbnRhaW4gdGhpcyBjYWNoZSwgYW5kIHBhc3MgYSBzdHlsZSBwcm9wIHJhdGhlciB0aGFuIGluZGV4LFxuICAgIC8vIFNvIHRoYXQgTGlzdCBjYW4gY2xlYXIgY2FjaGVkIHN0eWxlcyBhbmQgZm9yY2UgaXRlbSByZS1yZW5kZXIgaWYgbmVjZXNzYXJ5LlxuICAgIDtcblxuICAgIF9wcm90by5fZ2V0UmFuZ2VUb1JlbmRlciA9IGZ1bmN0aW9uIF9nZXRSYW5nZVRvUmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgaXRlbUNvdW50ID0gX3RoaXMkcHJvcHM2Lml0ZW1Db3VudCxcbiAgICAgICAgICBvdmVyc2NhbkNvdW50ID0gX3RoaXMkcHJvcHM2Lm92ZXJzY2FuQ291bnQ7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUzID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgICBpc1Njcm9sbGluZyA9IF90aGlzJHN0YXRlMy5pc1Njcm9sbGluZyxcbiAgICAgICAgICBzY3JvbGxEaXJlY3Rpb24gPSBfdGhpcyRzdGF0ZTMuc2Nyb2xsRGlyZWN0aW9uLFxuICAgICAgICAgIHNjcm9sbE9mZnNldCA9IF90aGlzJHN0YXRlMy5zY3JvbGxPZmZzZXQ7XG5cbiAgICAgIGlmIChpdGVtQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBnZXRTdGFydEluZGV4Rm9yT2Zmc2V0KHRoaXMucHJvcHMsIHNjcm9sbE9mZnNldCwgdGhpcy5faW5zdGFuY2VQcm9wcyk7XG4gICAgICB2YXIgc3RvcEluZGV4ID0gZ2V0U3RvcEluZGV4Rm9yU3RhcnRJbmRleCh0aGlzLnByb3BzLCBzdGFydEluZGV4LCBzY3JvbGxPZmZzZXQsIHRoaXMuX2luc3RhbmNlUHJvcHMpOyAvLyBPdmVyc2NhbiBieSBvbmUgaXRlbSBpbiBlYWNoIGRpcmVjdGlvbiBzbyB0aGF0IHRhYi9mb2N1cyB3b3Jrcy5cbiAgICAgIC8vIElmIHRoZXJlIGlzbid0IGF0IGxlYXN0IG9uZSBleHRyYSBpdGVtLCB0YWIgbG9vcHMgYmFjayBhcm91bmQuXG5cbiAgICAgIHZhciBvdmVyc2NhbkJhY2t3YXJkID0gIWlzU2Nyb2xsaW5nIHx8IHNjcm9sbERpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyA/IE1hdGgubWF4KDEsIG92ZXJzY2FuQ291bnQpIDogMTtcbiAgICAgIHZhciBvdmVyc2NhbkZvcndhcmQgPSAhaXNTY3JvbGxpbmcgfHwgc2Nyb2xsRGlyZWN0aW9uID09PSAnZm9yd2FyZCcgPyBNYXRoLm1heCgxLCBvdmVyc2NhbkNvdW50KSA6IDE7XG4gICAgICByZXR1cm4gW01hdGgubWF4KDAsIHN0YXJ0SW5kZXggLSBvdmVyc2NhbkJhY2t3YXJkKSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oaXRlbUNvdW50IC0gMSwgc3RvcEluZGV4ICsgb3ZlcnNjYW5Gb3J3YXJkKSksIHN0YXJ0SW5kZXgsIHN0b3BJbmRleF07XG4gICAgfTtcblxuICAgIHJldHVybiBMaXN0O1xuICB9KFB1cmVDb21wb25lbnQpLCBfY2xhc3MuZGVmYXVsdFByb3BzID0ge1xuICAgIGRpcmVjdGlvbjogJ2x0cicsXG4gICAgaXRlbURhdGE6IHVuZGVmaW5lZCxcbiAgICBsYXlvdXQ6ICd2ZXJ0aWNhbCcsXG4gICAgb3ZlcnNjYW5Db3VudDogMixcbiAgICB1c2VJc1Njcm9sbGluZzogZmFsc2VcbiAgfSwgX2NsYXNzO1xufSAvLyBOT1RFOiBJIGNvbnNpZGVyZWQgZnVydGhlciB3cmFwcGluZyBpbmRpdmlkdWFsIGl0ZW1zIHdpdGggYSBwdXJlIExpc3RJdGVtIGNvbXBvbmVudC5cbi8vIFRoaXMgd291bGQgYXZvaWQgZXZlciBjYWxsaW5nIHRoZSByZW5kZXIgZnVuY3Rpb24gZm9yIHRoZSBzYW1lIGluZGV4IG1vcmUgdGhhbiBvbmNlLFxuLy8gQnV0IGl0IHdvdWxkIGFsc28gYWRkIHRoZSBvdmVyaGVhZCBvZiBhIGxvdCBvZiBjb21wb25lbnRzL2ZpYmVycy5cbi8vIEkgYXNzdW1lIHBlb3BsZSBhbHJlYWR5IGRvIHRoaXMgKHJlbmRlciBmdW5jdGlvbiByZXR1cm5pbmcgYSBjbGFzcyBjb21wb25lbnQpLFxuLy8gU28gbXkgZG9pbmcgaXQgd291bGQganVzdCB1bm5lY2Vzc2FyaWx5IGRvdWJsZSB0aGUgd3JhcHBlcnMuXG5cbnZhciB2YWxpZGF0ZVNoYXJlZFByb3BzJDEgPSBmdW5jdGlvbiB2YWxpZGF0ZVNoYXJlZFByb3BzKF9yZWYyLCBfcmVmMykge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmMi5jaGlsZHJlbixcbiAgICAgIGRpcmVjdGlvbiA9IF9yZWYyLmRpcmVjdGlvbixcbiAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodCxcbiAgICAgIGxheW91dCA9IF9yZWYyLmxheW91dCxcbiAgICAgIGlubmVyVGFnTmFtZSA9IF9yZWYyLmlubmVyVGFnTmFtZSxcbiAgICAgIG91dGVyVGFnTmFtZSA9IF9yZWYyLm91dGVyVGFnTmFtZSxcbiAgICAgIHdpZHRoID0gX3JlZjIud2lkdGg7XG4gIHZhciBpbnN0YW5jZSA9IF9yZWYzLmluc3RhbmNlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGlubmVyVGFnTmFtZSAhPSBudWxsIHx8IG91dGVyVGFnTmFtZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZGV2V2FybmluZ3NUYWdOYW1lJDEgJiYgIWRldldhcm5pbmdzVGFnTmFtZSQxLmhhcyhpbnN0YW5jZSkpIHtcbiAgICAgICAgZGV2V2FybmluZ3NUYWdOYW1lJDEuYWRkKGluc3RhbmNlKTtcbiAgICAgICAgY29uc29sZS53YXJuKCdUaGUgaW5uZXJUYWdOYW1lIGFuZCBvdXRlclRhZ05hbWUgcHJvcHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQuICcgKyAnUGxlYXNlIHVzZSB0aGUgaW5uZXJFbGVtZW50VHlwZSBhbmQgb3V0ZXJFbGVtZW50VHlwZSBwcm9wcyBpbnN0ZWFkLicpO1xuICAgICAgfVxuICAgIH0gLy8gVE9ETyBEZXByZWNhdGUgZGlyZWN0aW9uIFwiaG9yaXpvbnRhbFwiXG5cblxuICAgIHZhciBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyB8fCBsYXlvdXQgPT09ICdob3Jpem9udGFsJztcblxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgaWYgKGRldldhcm5pbmdzRGlyZWN0aW9uICYmICFkZXZXYXJuaW5nc0RpcmVjdGlvbi5oYXMoaW5zdGFuY2UpKSB7XG4gICAgICAgICAgZGV2V2FybmluZ3NEaXJlY3Rpb24uYWRkKGluc3RhbmNlKTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBkaXJlY3Rpb24gcHJvcCBzaG91bGQgYmUgZWl0aGVyIFwibHRyXCIgKGRlZmF1bHQpIG9yIFwicnRsXCIuICcgKyAnUGxlYXNlIHVzZSB0aGUgbGF5b3V0IHByb3AgdG8gc3BlY2lmeSBcInZlcnRpY2FsXCIgKGRlZmF1bHQpIG9yIFwiaG9yaXpvbnRhbFwiIG9yaWVudGF0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2x0cic6XG4gICAgICBjYXNlICdydGwnOlxuICAgICAgICAvLyBWYWxpZCB2YWx1ZXNcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwiZGlyZWN0aW9uXCIgcHJvcCBoYXMgYmVlbiBzcGVjaWZpZWQuICcgKyAnVmFsdWUgc2hvdWxkIGJlIGVpdGhlciBcImx0clwiIG9yIFwicnRsXCIuICcgKyAoXCJcXFwiXCIgKyBkaXJlY3Rpb24gKyBcIlxcXCIgd2FzIHNwZWNpZmllZC5cIikpO1xuICAgIH1cblxuICAgIHN3aXRjaCAobGF5b3V0KSB7XG4gICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgLy8gVmFsaWQgdmFsdWVzXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcignQW4gaW52YWxpZCBcImxheW91dFwiIHByb3AgaGFzIGJlZW4gc3BlY2lmaWVkLiAnICsgJ1ZhbHVlIHNob3VsZCBiZSBlaXRoZXIgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLiAnICsgKFwiXFxcIlwiICsgbGF5b3V0ICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FuIGludmFsaWQgXCJjaGlsZHJlblwiIHByb3AgaGFzIGJlZW4gc3BlY2lmaWVkLiAnICsgJ1ZhbHVlIHNob3VsZCBiZSBhIFJlYWN0IGNvbXBvbmVudC4gJyArIChcIlxcXCJcIiArIChjaGlsZHJlbiA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBjaGlsZHJlbikgKyBcIlxcXCIgd2FzIHNwZWNpZmllZC5cIikpO1xuICAgIH1cblxuICAgIGlmIChpc0hvcml6b250YWwgJiYgdHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FuIGludmFsaWQgXCJ3aWR0aFwiIHByb3AgaGFzIGJlZW4gc3BlY2lmaWVkLiAnICsgJ0hvcml6b250YWwgbGlzdHMgbXVzdCBzcGVjaWZ5IGEgbnVtYmVyIGZvciB3aWR0aC4gJyArIChcIlxcXCJcIiArICh3aWR0aCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB3aWR0aCkgKyBcIlxcXCIgd2FzIHNwZWNpZmllZC5cIikpO1xuICAgIH0gZWxzZSBpZiAoIWlzSG9yaXpvbnRhbCAmJiB0eXBlb2YgaGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FuIGludmFsaWQgXCJoZWlnaHRcIiBwcm9wIGhhcyBiZWVuIHNwZWNpZmllZC4gJyArICdWZXJ0aWNhbCBsaXN0cyBtdXN0IHNwZWNpZnkgYSBudW1iZXIgZm9yIGhlaWdodC4gJyArIChcIlxcXCJcIiArIChoZWlnaHQgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgaGVpZ2h0KSArIFwiXFxcIiB3YXMgc3BlY2lmaWVkLlwiKSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgREVGQVVMVF9FU1RJTUFURURfSVRFTV9TSVpFJDEgPSA1MDtcblxudmFyIGdldEl0ZW1NZXRhZGF0YSQxID0gZnVuY3Rpb24gZ2V0SXRlbU1ldGFkYXRhKHByb3BzLCBpbmRleCwgaW5zdGFuY2VQcm9wcykge1xuICB2YXIgX3JlZiA9IHByb3BzLFxuICAgICAgaXRlbVNpemUgPSBfcmVmLml0ZW1TaXplO1xuICB2YXIgaXRlbU1ldGFkYXRhTWFwID0gaW5zdGFuY2VQcm9wcy5pdGVtTWV0YWRhdGFNYXAsXG4gICAgICBsYXN0TWVhc3VyZWRJbmRleCA9IGluc3RhbmNlUHJvcHMubGFzdE1lYXN1cmVkSW5kZXg7XG5cbiAgaWYgKGluZGV4ID4gbGFzdE1lYXN1cmVkSW5kZXgpIHtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGlmIChsYXN0TWVhc3VyZWRJbmRleCA+PSAwKSB7XG4gICAgICB2YXIgaXRlbU1ldGFkYXRhID0gaXRlbU1ldGFkYXRhTWFwW2xhc3RNZWFzdXJlZEluZGV4XTtcbiAgICAgIG9mZnNldCA9IGl0ZW1NZXRhZGF0YS5vZmZzZXQgKyBpdGVtTWV0YWRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gbGFzdE1lYXN1cmVkSW5kZXggKyAxOyBpIDw9IGluZGV4OyBpKyspIHtcbiAgICAgIHZhciBzaXplID0gaXRlbVNpemUoaSk7XG4gICAgICBpdGVtTWV0YWRhdGFNYXBbaV0gPSB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBzaXplOiBzaXplXG4gICAgICB9O1xuICAgICAgb2Zmc2V0ICs9IHNpemU7XG4gICAgfVxuXG4gICAgaW5zdGFuY2VQcm9wcy5sYXN0TWVhc3VyZWRJbmRleCA9IGluZGV4O1xuICB9XG5cbiAgcmV0dXJuIGl0ZW1NZXRhZGF0YU1hcFtpbmRleF07XG59O1xuXG52YXIgZmluZE5lYXJlc3RJdGVtJDEgPSBmdW5jdGlvbiBmaW5kTmVhcmVzdEl0ZW0ocHJvcHMsIGluc3RhbmNlUHJvcHMsIG9mZnNldCkge1xuICB2YXIgaXRlbU1ldGFkYXRhTWFwID0gaW5zdGFuY2VQcm9wcy5pdGVtTWV0YWRhdGFNYXAsXG4gICAgICBsYXN0TWVhc3VyZWRJbmRleCA9IGluc3RhbmNlUHJvcHMubGFzdE1lYXN1cmVkSW5kZXg7XG4gIHZhciBsYXN0TWVhc3VyZWRJdGVtT2Zmc2V0ID0gbGFzdE1lYXN1cmVkSW5kZXggPiAwID8gaXRlbU1ldGFkYXRhTWFwW2xhc3RNZWFzdXJlZEluZGV4XS5vZmZzZXQgOiAwO1xuXG4gIGlmIChsYXN0TWVhc3VyZWRJdGVtT2Zmc2V0ID49IG9mZnNldCkge1xuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgbWVhc3VyZWQgaXRlbXMgd2l0aGluIHRoaXMgcmFuZ2UganVzdCB1c2UgYSBiaW5hcnkgc2VhcmNoIGFzIGl0J3MgZmFzdGVyLlxuICAgIHJldHVybiBmaW5kTmVhcmVzdEl0ZW1CaW5hcnlTZWFyY2gkMShwcm9wcywgaW5zdGFuY2VQcm9wcywgbGFzdE1lYXN1cmVkSW5kZXgsIDAsIG9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgd2UgaGF2ZW4ndCB5ZXQgbWVhc3VyZWQgdGhpcyBoaWdoLCBmYWxsYmFjayB0byBhbiBleHBvbmVudGlhbCBzZWFyY2ggd2l0aCBhbiBpbm5lciBiaW5hcnkgc2VhcmNoLlxuICAgIC8vIFRoZSBleHBvbmVudGlhbCBzZWFyY2ggYXZvaWRzIHByZS1jb21wdXRpbmcgc2l6ZXMgZm9yIHRoZSBmdWxsIHNldCBvZiBpdGVtcyBhcyBhIGJpbmFyeSBzZWFyY2ggd291bGQuXG4gICAgLy8gVGhlIG92ZXJhbGwgY29tcGxleGl0eSBmb3IgdGhpcyBhcHByb2FjaCBpcyBPKGxvZyBuKS5cbiAgICByZXR1cm4gZmluZE5lYXJlc3RJdGVtRXhwb25lbnRpYWxTZWFyY2gkMShwcm9wcywgaW5zdGFuY2VQcm9wcywgTWF0aC5tYXgoMCwgbGFzdE1lYXN1cmVkSW5kZXgpLCBvZmZzZXQpO1xuICB9XG59O1xuXG52YXIgZmluZE5lYXJlc3RJdGVtQmluYXJ5U2VhcmNoJDEgPSBmdW5jdGlvbiBmaW5kTmVhcmVzdEl0ZW1CaW5hcnlTZWFyY2gocHJvcHMsIGluc3RhbmNlUHJvcHMsIGhpZ2gsIGxvdywgb2Zmc2V0KSB7XG4gIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgIHZhciBtaWRkbGUgPSBsb3cgKyBNYXRoLmZsb29yKChoaWdoIC0gbG93KSAvIDIpO1xuICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gZ2V0SXRlbU1ldGFkYXRhJDEocHJvcHMsIG1pZGRsZSwgaW5zdGFuY2VQcm9wcykub2Zmc2V0O1xuXG4gICAgaWYgKGN1cnJlbnRPZmZzZXQgPT09IG9mZnNldCkge1xuICAgICAgcmV0dXJuIG1pZGRsZTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRPZmZzZXQgPCBvZmZzZXQpIHtcbiAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50T2Zmc2V0ID4gb2Zmc2V0KSB7XG4gICAgICBoaWdoID0gbWlkZGxlIC0gMTtcbiAgICB9XG4gIH1cblxuICBpZiAobG93ID4gMCkge1xuICAgIHJldHVybiBsb3cgLSAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG52YXIgZmluZE5lYXJlc3RJdGVtRXhwb25lbnRpYWxTZWFyY2gkMSA9IGZ1bmN0aW9uIGZpbmROZWFyZXN0SXRlbUV4cG9uZW50aWFsU2VhcmNoKHByb3BzLCBpbnN0YW5jZVByb3BzLCBpbmRleCwgb2Zmc2V0KSB7XG4gIHZhciBpdGVtQ291bnQgPSBwcm9wcy5pdGVtQ291bnQ7XG4gIHZhciBpbnRlcnZhbCA9IDE7XG5cbiAgd2hpbGUgKGluZGV4IDwgaXRlbUNvdW50ICYmIGdldEl0ZW1NZXRhZGF0YSQxKHByb3BzLCBpbmRleCwgaW5zdGFuY2VQcm9wcykub2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgaW5kZXggKz0gaW50ZXJ2YWw7XG4gICAgaW50ZXJ2YWwgKj0gMjtcbiAgfVxuXG4gIHJldHVybiBmaW5kTmVhcmVzdEl0ZW1CaW5hcnlTZWFyY2gkMShwcm9wcywgaW5zdGFuY2VQcm9wcywgTWF0aC5taW4oaW5kZXgsIGl0ZW1Db3VudCAtIDEpLCBNYXRoLmZsb29yKGluZGV4IC8gMiksIG9mZnNldCk7XG59O1xuXG52YXIgZ2V0RXN0aW1hdGVkVG90YWxTaXplID0gZnVuY3Rpb24gZ2V0RXN0aW1hdGVkVG90YWxTaXplKF9yZWYyLCBfcmVmMykge1xuICB2YXIgaXRlbUNvdW50ID0gX3JlZjIuaXRlbUNvdW50O1xuICB2YXIgaXRlbU1ldGFkYXRhTWFwID0gX3JlZjMuaXRlbU1ldGFkYXRhTWFwLFxuICAgICAgZXN0aW1hdGVkSXRlbVNpemUgPSBfcmVmMy5lc3RpbWF0ZWRJdGVtU2l6ZSxcbiAgICAgIGxhc3RNZWFzdXJlZEluZGV4ID0gX3JlZjMubGFzdE1lYXN1cmVkSW5kZXg7XG4gIHZhciB0b3RhbFNpemVPZk1lYXN1cmVkSXRlbXMgPSAwOyAvLyBFZGdlIGNhc2UgY2hlY2sgZm9yIHdoZW4gdGhlIG51bWJlciBvZiBpdGVtcyBkZWNyZWFzZXMgd2hpbGUgYSBzY3JvbGwgaXMgaW4gcHJvZ3Jlc3MuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9idmF1Z2huL3JlYWN0LXdpbmRvdy9wdWxsLzEzOFxuXG4gIGlmIChsYXN0TWVhc3VyZWRJbmRleCA+PSBpdGVtQ291bnQpIHtcbiAgICBsYXN0TWVhc3VyZWRJbmRleCA9IGl0ZW1Db3VudCAtIDE7XG4gIH1cblxuICBpZiAobGFzdE1lYXN1cmVkSW5kZXggPj0gMCkge1xuICAgIHZhciBpdGVtTWV0YWRhdGEgPSBpdGVtTWV0YWRhdGFNYXBbbGFzdE1lYXN1cmVkSW5kZXhdO1xuICAgIHRvdGFsU2l6ZU9mTWVhc3VyZWRJdGVtcyA9IGl0ZW1NZXRhZGF0YS5vZmZzZXQgKyBpdGVtTWV0YWRhdGEuc2l6ZTtcbiAgfVxuXG4gIHZhciBudW1Vbm1lYXN1cmVkSXRlbXMgPSBpdGVtQ291bnQgLSBsYXN0TWVhc3VyZWRJbmRleCAtIDE7XG4gIHZhciB0b3RhbFNpemVPZlVubWVhc3VyZWRJdGVtcyA9IG51bVVubWVhc3VyZWRJdGVtcyAqIGVzdGltYXRlZEl0ZW1TaXplO1xuICByZXR1cm4gdG90YWxTaXplT2ZNZWFzdXJlZEl0ZW1zICsgdG90YWxTaXplT2ZVbm1lYXN1cmVkSXRlbXM7XG59O1xuXG52YXIgVmFyaWFibGVTaXplTGlzdCA9IC8qI19fUFVSRV9fKi9jcmVhdGVMaXN0Q29tcG9uZW50KHtcbiAgZ2V0SXRlbU9mZnNldDogZnVuY3Rpb24gZ2V0SXRlbU9mZnNldChwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpIHtcbiAgICByZXR1cm4gZ2V0SXRlbU1ldGFkYXRhJDEocHJvcHMsIGluZGV4LCBpbnN0YW5jZVByb3BzKS5vZmZzZXQ7XG4gIH0sXG4gIGdldEl0ZW1TaXplOiBmdW5jdGlvbiBnZXRJdGVtU2l6ZShwcm9wcywgaW5kZXgsIGluc3RhbmNlUHJvcHMpIHtcbiAgICByZXR1cm4gaW5zdGFuY2VQcm9wcy5pdGVtTWV0YWRhdGFNYXBbaW5kZXhdLnNpemU7XG4gIH0sXG4gIGdldEVzdGltYXRlZFRvdGFsU2l6ZTogZ2V0RXN0aW1hdGVkVG90YWxTaXplLFxuICBnZXRPZmZzZXRGb3JJbmRleEFuZEFsaWdubWVudDogZnVuY3Rpb24gZ2V0T2Zmc2V0Rm9ySW5kZXhBbmRBbGlnbm1lbnQocHJvcHMsIGluZGV4LCBhbGlnbiwgc2Nyb2xsT2Zmc2V0LCBpbnN0YW5jZVByb3BzLCBzY3JvbGxiYXJTaXplKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHByb3BzLmRpcmVjdGlvbixcbiAgICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgICAgICBsYXlvdXQgPSBwcm9wcy5sYXlvdXQsXG4gICAgICAgIHdpZHRoID0gcHJvcHMud2lkdGg7IC8vIFRPRE8gRGVwcmVjYXRlIGRpcmVjdGlvbiBcImhvcml6b250YWxcIlxuXG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnIHx8IGxheW91dCA9PT0gJ2hvcml6b250YWwnO1xuICAgIHZhciBzaXplID0gaXNIb3Jpem9udGFsID8gd2lkdGggOiBoZWlnaHQ7XG4gICAgdmFyIGl0ZW1NZXRhZGF0YSA9IGdldEl0ZW1NZXRhZGF0YSQxKHByb3BzLCBpbmRleCwgaW5zdGFuY2VQcm9wcyk7IC8vIEdldCBlc3RpbWF0ZWQgdG90YWwgc2l6ZSBhZnRlciBJdGVtTWV0YWRhdGEgaXMgY29tcHV0ZWQsXG4gICAgLy8gVG8gZW5zdXJlIGl0IHJlZmxlY3RzIGFjdHVhbCBtZWFzdXJlbWVudHMgaW5zdGVhZCBvZiBqdXN0IGVzdGltYXRlcy5cblxuICAgIHZhciBlc3RpbWF0ZWRUb3RhbFNpemUgPSBnZXRFc3RpbWF0ZWRUb3RhbFNpemUocHJvcHMsIGluc3RhbmNlUHJvcHMpO1xuICAgIHZhciBtYXhPZmZzZXQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlc3RpbWF0ZWRUb3RhbFNpemUgLSBzaXplLCBpdGVtTWV0YWRhdGEub2Zmc2V0KSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IE1hdGgubWF4KDAsIGl0ZW1NZXRhZGF0YS5vZmZzZXQgLSBzaXplICsgaXRlbU1ldGFkYXRhLnNpemUgKyBzY3JvbGxiYXJTaXplKTtcblxuICAgIGlmIChhbGlnbiA9PT0gJ3NtYXJ0Jykge1xuICAgICAgaWYgKHNjcm9sbE9mZnNldCA+PSBtaW5PZmZzZXQgLSBzaXplICYmIHNjcm9sbE9mZnNldCA8PSBtYXhPZmZzZXQgKyBzaXplKSB7XG4gICAgICAgIGFsaWduID0gJ2F1dG8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIHJldHVybiBtYXhPZmZzZXQ7XG5cbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHJldHVybiBtaW5PZmZzZXQ7XG5cbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1pbk9mZnNldCArIChtYXhPZmZzZXQgLSBtaW5PZmZzZXQpIC8gMik7XG5cbiAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNjcm9sbE9mZnNldCA+PSBtaW5PZmZzZXQgJiYgc2Nyb2xsT2Zmc2V0IDw9IG1heE9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBzY3JvbGxPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsT2Zmc2V0IDwgbWluT2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIG1pbk9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWF4T2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICB9XG4gIH0sXG4gIGdldFN0YXJ0SW5kZXhGb3JPZmZzZXQ6IGZ1bmN0aW9uIGdldFN0YXJ0SW5kZXhGb3JPZmZzZXQocHJvcHMsIG9mZnNldCwgaW5zdGFuY2VQcm9wcykge1xuICAgIHJldHVybiBmaW5kTmVhcmVzdEl0ZW0kMShwcm9wcywgaW5zdGFuY2VQcm9wcywgb2Zmc2V0KTtcbiAgfSxcbiAgZ2V0U3RvcEluZGV4Rm9yU3RhcnRJbmRleDogZnVuY3Rpb24gZ2V0U3RvcEluZGV4Rm9yU3RhcnRJbmRleChwcm9wcywgc3RhcnRJbmRleCwgc2Nyb2xsT2Zmc2V0LCBpbnN0YW5jZVByb3BzKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IHByb3BzLmRpcmVjdGlvbixcbiAgICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgICAgICBpdGVtQ291bnQgPSBwcm9wcy5pdGVtQ291bnQsXG4gICAgICAgIGxheW91dCA9IHByb3BzLmxheW91dCxcbiAgICAgICAgd2lkdGggPSBwcm9wcy53aWR0aDsgLy8gVE9ETyBEZXByZWNhdGUgZGlyZWN0aW9uIFwiaG9yaXpvbnRhbFwiXG5cbiAgICB2YXIgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgfHwgbGF5b3V0ID09PSAnaG9yaXpvbnRhbCc7XG4gICAgdmFyIHNpemUgPSBpc0hvcml6b250YWwgPyB3aWR0aCA6IGhlaWdodDtcbiAgICB2YXIgaXRlbU1ldGFkYXRhID0gZ2V0SXRlbU1ldGFkYXRhJDEocHJvcHMsIHN0YXJ0SW5kZXgsIGluc3RhbmNlUHJvcHMpO1xuICAgIHZhciBtYXhPZmZzZXQgPSBzY3JvbGxPZmZzZXQgKyBzaXplO1xuICAgIHZhciBvZmZzZXQgPSBpdGVtTWV0YWRhdGEub2Zmc2V0ICsgaXRlbU1ldGFkYXRhLnNpemU7XG4gICAgdmFyIHN0b3BJbmRleCA9IHN0YXJ0SW5kZXg7XG5cbiAgICB3aGlsZSAoc3RvcEluZGV4IDwgaXRlbUNvdW50IC0gMSAmJiBvZmZzZXQgPCBtYXhPZmZzZXQpIHtcbiAgICAgIHN0b3BJbmRleCsrO1xuICAgICAgb2Zmc2V0ICs9IGdldEl0ZW1NZXRhZGF0YSQxKHByb3BzLCBzdG9wSW5kZXgsIGluc3RhbmNlUHJvcHMpLnNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0b3BJbmRleDtcbiAgfSxcbiAgaW5pdEluc3RhbmNlUHJvcHM6IGZ1bmN0aW9uIGluaXRJbnN0YW5jZVByb3BzKHByb3BzLCBpbnN0YW5jZSkge1xuICAgIHZhciBfcmVmNCA9IHByb3BzLFxuICAgICAgICBlc3RpbWF0ZWRJdGVtU2l6ZSA9IF9yZWY0LmVzdGltYXRlZEl0ZW1TaXplO1xuICAgIHZhciBpbnN0YW5jZVByb3BzID0ge1xuICAgICAgaXRlbU1ldGFkYXRhTWFwOiB7fSxcbiAgICAgIGVzdGltYXRlZEl0ZW1TaXplOiBlc3RpbWF0ZWRJdGVtU2l6ZSB8fCBERUZBVUxUX0VTVElNQVRFRF9JVEVNX1NJWkUkMSxcbiAgICAgIGxhc3RNZWFzdXJlZEluZGV4OiAtMVxuICAgIH07XG5cbiAgICBpbnN0YW5jZS5yZXNldEFmdGVySW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIHNob3VsZEZvcmNlVXBkYXRlKSB7XG4gICAgICBpZiAoc2hvdWxkRm9yY2VVcGRhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBzaG91bGRGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlUHJvcHMubGFzdE1lYXN1cmVkSW5kZXggPSBNYXRoLm1pbihpbnN0YW5jZVByb3BzLmxhc3RNZWFzdXJlZEluZGV4LCBpbmRleCAtIDEpOyAvLyBXZSBjb3VsZCBwb3RlbnRpYWxseSBvcHRpbWl6ZSBmdXJ0aGVyIGJ5IG9ubHkgZXZpY3Rpbmcgc3R5bGVzIGFmdGVyIHRoaXMgaW5kZXgsXG4gICAgICAvLyBCdXQgc2luY2Ugc3R5bGVzIGFyZSBvbmx5IGNhY2hlZCB3aGlsZSBzY3JvbGxpbmcgaXMgaW4gcHJvZ3Jlc3MtXG4gICAgICAvLyBJdCBzZWVtcyBhbiB1bm5lY2Vzc2FyeSBvcHRpbWl6YXRpb24uXG4gICAgICAvLyBJdCdzIHVubGlrZWx5IHRoYXQgcmVzZXRBZnRlckluZGV4KCkgd2lsbCBiZSBjYWxsZWQgd2hpbGUgYSB1c2VyIGlzIHNjcm9sbGluZy5cblxuICAgICAgaW5zdGFuY2UuX2dldEl0ZW1TdHlsZUNhY2hlKC0xKTtcblxuICAgICAgaWYgKHNob3VsZEZvcmNlVXBkYXRlKSB7XG4gICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBpbnN0YW5jZVByb3BzO1xuICB9LFxuICBzaG91bGRSZXNldFN0eWxlQ2FjaGVPbkl0ZW1TaXplQ2hhbmdlOiBmYWxzZSxcbiAgdmFsaWRhdGVQcm9wczogZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhfcmVmNSkge1xuICAgIHZhciBpdGVtU2l6ZSA9IF9yZWY1Lml0ZW1TaXplO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgaXRlbVNpemUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0FuIGludmFsaWQgXCJpdGVtU2l6ZVwiIHByb3AgaGFzIGJlZW4gc3BlY2lmaWVkLiAnICsgJ1ZhbHVlIHNob3VsZCBiZSBhIGZ1bmN0aW9uLiAnICsgKFwiXFxcIlwiICsgKGl0ZW1TaXplID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIGl0ZW1TaXplKSArIFwiXFxcIiB3YXMgc3BlY2lmaWVkLlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxudmFyIEZpeGVkU2l6ZUdyaWQgPSAvKiNfX1BVUkVfXyovY3JlYXRlR3JpZENvbXBvbmVudCh7XG4gIGdldENvbHVtbk9mZnNldDogZnVuY3Rpb24gZ2V0Q29sdW1uT2Zmc2V0KF9yZWYsIGluZGV4KSB7XG4gICAgdmFyIGNvbHVtbldpZHRoID0gX3JlZi5jb2x1bW5XaWR0aDtcbiAgICByZXR1cm4gaW5kZXggKiBjb2x1bW5XaWR0aDtcbiAgfSxcbiAgZ2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uIGdldENvbHVtbldpZHRoKF9yZWYyLCBpbmRleCkge1xuICAgIHZhciBjb2x1bW5XaWR0aCA9IF9yZWYyLmNvbHVtbldpZHRoO1xuICAgIHJldHVybiBjb2x1bW5XaWR0aDtcbiAgfSxcbiAgZ2V0Um93T2Zmc2V0OiBmdW5jdGlvbiBnZXRSb3dPZmZzZXQoX3JlZjMsIGluZGV4KSB7XG4gICAgdmFyIHJvd0hlaWdodCA9IF9yZWYzLnJvd0hlaWdodDtcbiAgICByZXR1cm4gaW5kZXggKiByb3dIZWlnaHQ7XG4gIH0sXG4gIGdldFJvd0hlaWdodDogZnVuY3Rpb24gZ2V0Um93SGVpZ2h0KF9yZWY0LCBpbmRleCkge1xuICAgIHZhciByb3dIZWlnaHQgPSBfcmVmNC5yb3dIZWlnaHQ7XG4gICAgcmV0dXJuIHJvd0hlaWdodDtcbiAgfSxcbiAgZ2V0RXN0aW1hdGVkVG90YWxIZWlnaHQ6IGZ1bmN0aW9uIGdldEVzdGltYXRlZFRvdGFsSGVpZ2h0KF9yZWY1KSB7XG4gICAgdmFyIHJvd0NvdW50ID0gX3JlZjUucm93Q291bnQsXG4gICAgICAgIHJvd0hlaWdodCA9IF9yZWY1LnJvd0hlaWdodDtcbiAgICByZXR1cm4gcm93SGVpZ2h0ICogcm93Q291bnQ7XG4gIH0sXG4gIGdldEVzdGltYXRlZFRvdGFsV2lkdGg6IGZ1bmN0aW9uIGdldEVzdGltYXRlZFRvdGFsV2lkdGgoX3JlZjYpIHtcbiAgICB2YXIgY29sdW1uQ291bnQgPSBfcmVmNi5jb2x1bW5Db3VudCxcbiAgICAgICAgY29sdW1uV2lkdGggPSBfcmVmNi5jb2x1bW5XaWR0aDtcbiAgICByZXR1cm4gY29sdW1uV2lkdGggKiBjb2x1bW5Db3VudDtcbiAgfSxcbiAgZ2V0T2Zmc2V0Rm9yQ29sdW1uQW5kQWxpZ25tZW50OiBmdW5jdGlvbiBnZXRPZmZzZXRGb3JDb2x1bW5BbmRBbGlnbm1lbnQoX3JlZjcsIGNvbHVtbkluZGV4LCBhbGlnbiwgc2Nyb2xsTGVmdCwgaW5zdGFuY2VQcm9wcywgc2Nyb2xsYmFyU2l6ZSkge1xuICAgIHZhciBjb2x1bW5Db3VudCA9IF9yZWY3LmNvbHVtbkNvdW50LFxuICAgICAgICBjb2x1bW5XaWR0aCA9IF9yZWY3LmNvbHVtbldpZHRoLFxuICAgICAgICB3aWR0aCA9IF9yZWY3LndpZHRoO1xuICAgIHZhciBsYXN0Q29sdW1uT2Zmc2V0ID0gTWF0aC5tYXgoMCwgY29sdW1uQ291bnQgKiBjb2x1bW5XaWR0aCAtIHdpZHRoKTtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gTWF0aC5taW4obGFzdENvbHVtbk9mZnNldCwgY29sdW1uSW5kZXggKiBjb2x1bW5XaWR0aCk7XG4gICAgdmFyIG1pbk9mZnNldCA9IE1hdGgubWF4KDAsIGNvbHVtbkluZGV4ICogY29sdW1uV2lkdGggLSB3aWR0aCArIHNjcm9sbGJhclNpemUgKyBjb2x1bW5XaWR0aCk7XG5cbiAgICBpZiAoYWxpZ24gPT09ICdzbWFydCcpIHtcbiAgICAgIGlmIChzY3JvbGxMZWZ0ID49IG1pbk9mZnNldCAtIHdpZHRoICYmIHNjcm9sbExlZnQgPD0gbWF4T2Zmc2V0ICsgd2lkdGgpIHtcbiAgICAgICAgYWxpZ24gPSAnYXV0byc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgcmV0dXJuIG1heE9mZnNldDtcblxuICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgcmV0dXJuIG1pbk9mZnNldDtcblxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgLy8gXCJDZW50ZXJlZFwiIG9mZnNldCBpcyB1c3VhbGx5IHRoZSBhdmVyYWdlIG9mIHRoZSBtaW4gYW5kIG1heC5cbiAgICAgICAgLy8gQnV0IG5lYXIgdGhlIGVkZ2VzIG9mIHRoZSBsaXN0LCB0aGlzIGRvZXNuJ3QgaG9sZCB0cnVlLlxuICAgICAgICB2YXIgbWlkZGxlT2Zmc2V0ID0gTWF0aC5yb3VuZChtaW5PZmZzZXQgKyAobWF4T2Zmc2V0IC0gbWluT2Zmc2V0KSAvIDIpO1xuXG4gICAgICAgIGlmIChtaWRkbGVPZmZzZXQgPCBNYXRoLmNlaWwod2lkdGggLyAyKSkge1xuICAgICAgICAgIHJldHVybiAwOyAvLyBuZWFyIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgfSBlbHNlIGlmIChtaWRkbGVPZmZzZXQgPiBsYXN0Q29sdW1uT2Zmc2V0ICsgTWF0aC5mbG9vcih3aWR0aCAvIDIpKSB7XG4gICAgICAgICAgcmV0dXJuIGxhc3RDb2x1bW5PZmZzZXQ7IC8vIG5lYXIgdGhlIGVuZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtaWRkbGVPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnYXV0byc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2Nyb2xsTGVmdCA+PSBtaW5PZmZzZXQgJiYgc2Nyb2xsTGVmdCA8PSBtYXhPZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2Nyb2xsTGVmdDtcbiAgICAgICAgfSBlbHNlIGlmIChtaW5PZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgICAgICAvLyBCZWNhdXNlIHdlIG9ubHkgdGFrZSBpbnRvIGFjY291bnQgdGhlIHNjcm9sbGJhciBzaXplIHdoZW4gY2FsY3VsYXRpbmcgbWluT2Zmc2V0XG4gICAgICAgICAgLy8gdGhpcyB2YWx1ZSBjYW4gYmUgbGFyZ2VyIHRoYW4gbWF4T2Zmc2V0IHdoZW4gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgICAgICAgIHJldHVybiBtaW5PZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc2Nyb2xsTGVmdCA8IG1pbk9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBtaW5PZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1heE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9LFxuICBnZXRPZmZzZXRGb3JSb3dBbmRBbGlnbm1lbnQ6IGZ1bmN0aW9uIGdldE9mZnNldEZvclJvd0FuZEFsaWdubWVudChfcmVmOCwgcm93SW5kZXgsIGFsaWduLCBzY3JvbGxUb3AsIGluc3RhbmNlUHJvcHMsIHNjcm9sbGJhclNpemUpIHtcbiAgICB2YXIgcm93SGVpZ2h0ID0gX3JlZjgucm93SGVpZ2h0LFxuICAgICAgICBoZWlnaHQgPSBfcmVmOC5oZWlnaHQsXG4gICAgICAgIHJvd0NvdW50ID0gX3JlZjgucm93Q291bnQ7XG4gICAgdmFyIGxhc3RSb3dPZmZzZXQgPSBNYXRoLm1heCgwLCByb3dDb3VudCAqIHJvd0hlaWdodCAtIGhlaWdodCk7XG4gICAgdmFyIG1heE9mZnNldCA9IE1hdGgubWluKGxhc3RSb3dPZmZzZXQsIHJvd0luZGV4ICogcm93SGVpZ2h0KTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gTWF0aC5tYXgoMCwgcm93SW5kZXggKiByb3dIZWlnaHQgLSBoZWlnaHQgKyBzY3JvbGxiYXJTaXplICsgcm93SGVpZ2h0KTtcblxuICAgIGlmIChhbGlnbiA9PT0gJ3NtYXJ0Jykge1xuICAgICAgaWYgKHNjcm9sbFRvcCA+PSBtaW5PZmZzZXQgLSBoZWlnaHQgJiYgc2Nyb2xsVG9wIDw9IG1heE9mZnNldCArIGhlaWdodCkge1xuICAgICAgICBhbGlnbiA9ICdhdXRvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsaWduID0gJ2NlbnRlcic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICByZXR1cm4gbWF4T2Zmc2V0O1xuXG4gICAgICBjYXNlICdlbmQnOlxuICAgICAgICByZXR1cm4gbWluT2Zmc2V0O1xuXG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAvLyBcIkNlbnRlcmVkXCIgb2Zmc2V0IGlzIHVzdWFsbHkgdGhlIGF2ZXJhZ2Ugb2YgdGhlIG1pbiBhbmQgbWF4LlxuICAgICAgICAvLyBCdXQgbmVhciB0aGUgZWRnZXMgb2YgdGhlIGxpc3QsIHRoaXMgZG9lc24ndCBob2xkIHRydWUuXG4gICAgICAgIHZhciBtaWRkbGVPZmZzZXQgPSBNYXRoLnJvdW5kKG1pbk9mZnNldCArIChtYXhPZmZzZXQgLSBtaW5PZmZzZXQpIC8gMik7XG5cbiAgICAgICAgaWYgKG1pZGRsZU9mZnNldCA8IE1hdGguY2VpbChoZWlnaHQgLyAyKSkge1xuICAgICAgICAgIHJldHVybiAwOyAvLyBuZWFyIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgfSBlbHNlIGlmIChtaWRkbGVPZmZzZXQgPiBsYXN0Um93T2Zmc2V0ICsgTWF0aC5mbG9vcihoZWlnaHQgLyAyKSkge1xuICAgICAgICAgIHJldHVybiBsYXN0Um93T2Zmc2V0OyAvLyBuZWFyIHRoZSBlbmRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbWlkZGxlT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHNjcm9sbFRvcCA+PSBtaW5PZmZzZXQgJiYgc2Nyb2xsVG9wIDw9IG1heE9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBzY3JvbGxUb3A7XG4gICAgICAgIH0gZWxzZSBpZiAobWluT2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgLy8gQmVjYXVzZSB3ZSBvbmx5IHRha2UgaW50byBhY2NvdW50IHRoZSBzY3JvbGxiYXIgc2l6ZSB3aGVuIGNhbGN1bGF0aW5nIG1pbk9mZnNldFxuICAgICAgICAgIC8vIHRoaXMgdmFsdWUgY2FuIGJlIGxhcmdlciB0aGFuIG1heE9mZnNldCB3aGVuIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICAgICAgICByZXR1cm4gbWluT2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbFRvcCA8IG1pbk9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBtaW5PZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1heE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9LFxuICBnZXRDb2x1bW5TdGFydEluZGV4Rm9yT2Zmc2V0OiBmdW5jdGlvbiBnZXRDb2x1bW5TdGFydEluZGV4Rm9yT2Zmc2V0KF9yZWY5LCBzY3JvbGxMZWZ0KSB7XG4gICAgdmFyIGNvbHVtbldpZHRoID0gX3JlZjkuY29sdW1uV2lkdGgsXG4gICAgICAgIGNvbHVtbkNvdW50ID0gX3JlZjkuY29sdW1uQ291bnQ7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKGNvbHVtbkNvdW50IC0gMSwgTWF0aC5mbG9vcihzY3JvbGxMZWZ0IC8gY29sdW1uV2lkdGgpKSk7XG4gIH0sXG4gIGdldENvbHVtblN0b3BJbmRleEZvclN0YXJ0SW5kZXg6IGZ1bmN0aW9uIGdldENvbHVtblN0b3BJbmRleEZvclN0YXJ0SW5kZXgoX3JlZjEwLCBzdGFydEluZGV4LCBzY3JvbGxMZWZ0KSB7XG4gICAgdmFyIGNvbHVtbldpZHRoID0gX3JlZjEwLmNvbHVtbldpZHRoLFxuICAgICAgICBjb2x1bW5Db3VudCA9IF9yZWYxMC5jb2x1bW5Db3VudCxcbiAgICAgICAgd2lkdGggPSBfcmVmMTAud2lkdGg7XG4gICAgdmFyIGxlZnQgPSBzdGFydEluZGV4ICogY29sdW1uV2lkdGg7XG4gICAgdmFyIG51bVZpc2libGVDb2x1bW5zID0gTWF0aC5jZWlsKCh3aWR0aCArIHNjcm9sbExlZnQgLSBsZWZ0KSAvIGNvbHVtbldpZHRoKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oY29sdW1uQ291bnQgLSAxLCBzdGFydEluZGV4ICsgbnVtVmlzaWJsZUNvbHVtbnMgLSAxIC8vIC0xIGlzIGJlY2F1c2Ugc3RvcCBpbmRleCBpcyBpbmNsdXNpdmVcbiAgICApKTtcbiAgfSxcbiAgZ2V0Um93U3RhcnRJbmRleEZvck9mZnNldDogZnVuY3Rpb24gZ2V0Um93U3RhcnRJbmRleEZvck9mZnNldChfcmVmMTEsIHNjcm9sbFRvcCkge1xuICAgIHZhciByb3dIZWlnaHQgPSBfcmVmMTEucm93SGVpZ2h0LFxuICAgICAgICByb3dDb3VudCA9IF9yZWYxMS5yb3dDb3VudDtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4ocm93Q291bnQgLSAxLCBNYXRoLmZsb29yKHNjcm9sbFRvcCAvIHJvd0hlaWdodCkpKTtcbiAgfSxcbiAgZ2V0Um93U3RvcEluZGV4Rm9yU3RhcnRJbmRleDogZnVuY3Rpb24gZ2V0Um93U3RvcEluZGV4Rm9yU3RhcnRJbmRleChfcmVmMTIsIHN0YXJ0SW5kZXgsIHNjcm9sbFRvcCkge1xuICAgIHZhciByb3dIZWlnaHQgPSBfcmVmMTIucm93SGVpZ2h0LFxuICAgICAgICByb3dDb3VudCA9IF9yZWYxMi5yb3dDb3VudCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjEyLmhlaWdodDtcbiAgICB2YXIgdG9wID0gc3RhcnRJbmRleCAqIHJvd0hlaWdodDtcbiAgICB2YXIgbnVtVmlzaWJsZVJvd3MgPSBNYXRoLmNlaWwoKGhlaWdodCArIHNjcm9sbFRvcCAtIHRvcCkgLyByb3dIZWlnaHQpO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihyb3dDb3VudCAtIDEsIHN0YXJ0SW5kZXggKyBudW1WaXNpYmxlUm93cyAtIDEgLy8gLTEgaXMgYmVjYXVzZSBzdG9wIGluZGV4IGlzIGluY2x1c2l2ZVxuICAgICkpO1xuICB9LFxuICBpbml0SW5zdGFuY2VQcm9wczogZnVuY3Rpb24gaW5pdEluc3RhbmNlUHJvcHMocHJvcHMpIHsvLyBOb29wXG4gIH0sXG4gIHNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2U6IHRydWUsXG4gIHZhbGlkYXRlUHJvcHM6IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoX3JlZjEzKSB7XG4gICAgdmFyIGNvbHVtbldpZHRoID0gX3JlZjEzLmNvbHVtbldpZHRoLFxuICAgICAgICByb3dIZWlnaHQgPSBfcmVmMTMucm93SGVpZ2h0O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgY29sdW1uV2lkdGggIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwiY29sdW1uV2lkdGhcIiBwcm9wIGhhcyBiZWVuIHNwZWNpZmllZC4gJyArICdWYWx1ZSBzaG91bGQgYmUgYSBudW1iZXIuICcgKyAoXCJcXFwiXCIgKyAoY29sdW1uV2lkdGggPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgY29sdW1uV2lkdGgpICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiByb3dIZWlnaHQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwicm93SGVpZ2h0XCIgcHJvcCBoYXMgYmVlbiBzcGVjaWZpZWQuICcgKyAnVmFsdWUgc2hvdWxkIGJlIGEgbnVtYmVyLiAnICsgKFwiXFxcIlwiICsgKHJvd0hlaWdodCA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByb3dIZWlnaHQpICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgRml4ZWRTaXplTGlzdCA9IC8qI19fUFVSRV9fKi9jcmVhdGVMaXN0Q29tcG9uZW50KHtcbiAgZ2V0SXRlbU9mZnNldDogZnVuY3Rpb24gZ2V0SXRlbU9mZnNldChfcmVmLCBpbmRleCkge1xuICAgIHZhciBpdGVtU2l6ZSA9IF9yZWYuaXRlbVNpemU7XG4gICAgcmV0dXJuIGluZGV4ICogaXRlbVNpemU7XG4gIH0sXG4gIGdldEl0ZW1TaXplOiBmdW5jdGlvbiBnZXRJdGVtU2l6ZShfcmVmMiwgaW5kZXgpIHtcbiAgICB2YXIgaXRlbVNpemUgPSBfcmVmMi5pdGVtU2l6ZTtcbiAgICByZXR1cm4gaXRlbVNpemU7XG4gIH0sXG4gIGdldEVzdGltYXRlZFRvdGFsU2l6ZTogZnVuY3Rpb24gZ2V0RXN0aW1hdGVkVG90YWxTaXplKF9yZWYzKSB7XG4gICAgdmFyIGl0ZW1Db3VudCA9IF9yZWYzLml0ZW1Db3VudCxcbiAgICAgICAgaXRlbVNpemUgPSBfcmVmMy5pdGVtU2l6ZTtcbiAgICByZXR1cm4gaXRlbVNpemUgKiBpdGVtQ291bnQ7XG4gIH0sXG4gIGdldE9mZnNldEZvckluZGV4QW5kQWxpZ25tZW50OiBmdW5jdGlvbiBnZXRPZmZzZXRGb3JJbmRleEFuZEFsaWdubWVudChfcmVmNCwgaW5kZXgsIGFsaWduLCBzY3JvbGxPZmZzZXQsIGluc3RhbmNlUHJvcHMsIHNjcm9sbGJhclNpemUpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gX3JlZjQuZGlyZWN0aW9uLFxuICAgICAgICBoZWlnaHQgPSBfcmVmNC5oZWlnaHQsXG4gICAgICAgIGl0ZW1Db3VudCA9IF9yZWY0Lml0ZW1Db3VudCxcbiAgICAgICAgaXRlbVNpemUgPSBfcmVmNC5pdGVtU2l6ZSxcbiAgICAgICAgbGF5b3V0ID0gX3JlZjQubGF5b3V0LFxuICAgICAgICB3aWR0aCA9IF9yZWY0LndpZHRoO1xuICAgIC8vIFRPRE8gRGVwcmVjYXRlIGRpcmVjdGlvbiBcImhvcml6b250YWxcIlxuICAgIHZhciBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyB8fCBsYXlvdXQgPT09ICdob3Jpem9udGFsJztcbiAgICB2YXIgc2l6ZSA9IGlzSG9yaXpvbnRhbCA/IHdpZHRoIDogaGVpZ2h0O1xuICAgIHZhciBsYXN0SXRlbU9mZnNldCA9IE1hdGgubWF4KDAsIGl0ZW1Db3VudCAqIGl0ZW1TaXplIC0gc2l6ZSk7XG4gICAgdmFyIG1heE9mZnNldCA9IE1hdGgubWluKGxhc3RJdGVtT2Zmc2V0LCBpbmRleCAqIGl0ZW1TaXplKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gTWF0aC5tYXgoMCwgaW5kZXggKiBpdGVtU2l6ZSAtIHNpemUgKyBpdGVtU2l6ZSArIHNjcm9sbGJhclNpemUpO1xuXG4gICAgaWYgKGFsaWduID09PSAnc21hcnQnKSB7XG4gICAgICBpZiAoc2Nyb2xsT2Zmc2V0ID49IG1pbk9mZnNldCAtIHNpemUgJiYgc2Nyb2xsT2Zmc2V0IDw9IG1heE9mZnNldCArIHNpemUpIHtcbiAgICAgICAgYWxpZ24gPSAnYXV0byc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgcmV0dXJuIG1heE9mZnNldDtcblxuICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgcmV0dXJuIG1pbk9mZnNldDtcblxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFwiQ2VudGVyZWRcIiBvZmZzZXQgaXMgdXN1YWxseSB0aGUgYXZlcmFnZSBvZiB0aGUgbWluIGFuZCBtYXguXG4gICAgICAgICAgLy8gQnV0IG5lYXIgdGhlIGVkZ2VzIG9mIHRoZSBsaXN0LCB0aGlzIGRvZXNuJ3QgaG9sZCB0cnVlLlxuICAgICAgICAgIHZhciBtaWRkbGVPZmZzZXQgPSBNYXRoLnJvdW5kKG1pbk9mZnNldCArIChtYXhPZmZzZXQgLSBtaW5PZmZzZXQpIC8gMik7XG5cbiAgICAgICAgICBpZiAobWlkZGxlT2Zmc2V0IDwgTWF0aC5jZWlsKHNpemUgLyAyKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIG5lYXIgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgIH0gZWxzZSBpZiAobWlkZGxlT2Zmc2V0ID4gbGFzdEl0ZW1PZmZzZXQgKyBNYXRoLmZsb29yKHNpemUgLyAyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RJdGVtT2Zmc2V0OyAvLyBuZWFyIHRoZSBlbmRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1pZGRsZU9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnYXV0byc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoc2Nyb2xsT2Zmc2V0ID49IG1pbk9mZnNldCAmJiBzY3JvbGxPZmZzZXQgPD0gbWF4T2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNjcm9sbE9mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxPZmZzZXQgPCBtaW5PZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gbWluT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBtYXhPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfSxcbiAgZ2V0U3RhcnRJbmRleEZvck9mZnNldDogZnVuY3Rpb24gZ2V0U3RhcnRJbmRleEZvck9mZnNldChfcmVmNSwgb2Zmc2V0KSB7XG4gICAgdmFyIGl0ZW1Db3VudCA9IF9yZWY1Lml0ZW1Db3VudCxcbiAgICAgICAgaXRlbVNpemUgPSBfcmVmNS5pdGVtU2l6ZTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oaXRlbUNvdW50IC0gMSwgTWF0aC5mbG9vcihvZmZzZXQgLyBpdGVtU2l6ZSkpKTtcbiAgfSxcbiAgZ2V0U3RvcEluZGV4Rm9yU3RhcnRJbmRleDogZnVuY3Rpb24gZ2V0U3RvcEluZGV4Rm9yU3RhcnRJbmRleChfcmVmNiwgc3RhcnRJbmRleCwgc2Nyb2xsT2Zmc2V0KSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IF9yZWY2LmRpcmVjdGlvbixcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjYuaGVpZ2h0LFxuICAgICAgICBpdGVtQ291bnQgPSBfcmVmNi5pdGVtQ291bnQsXG4gICAgICAgIGl0ZW1TaXplID0gX3JlZjYuaXRlbVNpemUsXG4gICAgICAgIGxheW91dCA9IF9yZWY2LmxheW91dCxcbiAgICAgICAgd2lkdGggPSBfcmVmNi53aWR0aDtcbiAgICAvLyBUT0RPIERlcHJlY2F0ZSBkaXJlY3Rpb24gXCJob3Jpem9udGFsXCJcbiAgICB2YXIgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgfHwgbGF5b3V0ID09PSAnaG9yaXpvbnRhbCc7XG4gICAgdmFyIG9mZnNldCA9IHN0YXJ0SW5kZXggKiBpdGVtU2l6ZTtcbiAgICB2YXIgc2l6ZSA9IGlzSG9yaXpvbnRhbCA/IHdpZHRoIDogaGVpZ2h0O1xuICAgIHZhciBudW1WaXNpYmxlSXRlbXMgPSBNYXRoLmNlaWwoKHNpemUgKyBzY3JvbGxPZmZzZXQgLSBvZmZzZXQpIC8gaXRlbVNpemUpO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihpdGVtQ291bnQgLSAxLCBzdGFydEluZGV4ICsgbnVtVmlzaWJsZUl0ZW1zIC0gMSAvLyAtMSBpcyBiZWNhdXNlIHN0b3AgaW5kZXggaXMgaW5jbHVzaXZlXG4gICAgKSk7XG4gIH0sXG4gIGluaXRJbnN0YW5jZVByb3BzOiBmdW5jdGlvbiBpbml0SW5zdGFuY2VQcm9wcyhwcm9wcykgey8vIE5vb3BcbiAgfSxcbiAgc2hvdWxkUmVzZXRTdHlsZUNhY2hlT25JdGVtU2l6ZUNoYW5nZTogdHJ1ZSxcbiAgdmFsaWRhdGVQcm9wczogZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhfcmVmNykge1xuICAgIHZhciBpdGVtU2l6ZSA9IF9yZWY3Lml0ZW1TaXplO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgaXRlbVNpemUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdBbiBpbnZhbGlkIFwiaXRlbVNpemVcIiBwcm9wIGhhcyBiZWVuIHNwZWNpZmllZC4gJyArICdWYWx1ZSBzaG91bGQgYmUgYSBudW1iZXIuICcgKyAoXCJcXFwiXCIgKyAoaXRlbVNpemUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgaXRlbVNpemUpICsgXCJcXFwiIHdhcyBzcGVjaWZpZWQuXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBQdWxsZWQgZnJvbSByZWFjdC1jb21wYXRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvcHJlYWN0LWNvbXBhdC9ibG9iLzdjNWRlMDBlN2M4NWUyZmZkMDExYmYzYWYwMjg5OWI2M2Y2OTlkM2Evc3JjL2luZGV4LmpzI0wzNDlcbmZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKHByZXYsIG5leHQpIHtcbiAgZm9yICh2YXIgYXR0cmlidXRlIGluIHByZXYpIHtcbiAgICBpZiAoIShhdHRyaWJ1dGUgaW4gbmV4dCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9hdHRyaWJ1dGUgaW4gbmV4dCkge1xuICAgIGlmIChwcmV2W19hdHRyaWJ1dGVdICE9PSBuZXh0W19hdHRyaWJ1dGVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJzdHlsZVwiXSxcbiAgICBfZXhjbHVkZWQyID0gW1wic3R5bGVcIl07XG4vLyBJdCBrbm93cyB0byBjb21wYXJlIGluZGl2aWR1YWwgc3R5bGUgcHJvcHMgYW5kIGlnbm9yZSB0aGUgd3JhcHBlciBvYmplY3QuXG4vLyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0bWVtb1xuXG5mdW5jdGlvbiBhcmVFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykge1xuICB2YXIgcHJldlN0eWxlID0gcHJldlByb3BzLnN0eWxlLFxuICAgICAgcHJldlJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcmV2UHJvcHMsIF9leGNsdWRlZCk7XG5cbiAgdmFyIG5leHRTdHlsZSA9IG5leHRQcm9wcy5zdHlsZSxcbiAgICAgIG5leHRSZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UobmV4dFByb3BzLCBfZXhjbHVkZWQyKTtcblxuICByZXR1cm4gIXNoYWxsb3dEaWZmZXJzKHByZXZTdHlsZSwgbmV4dFN0eWxlKSAmJiAhc2hhbGxvd0RpZmZlcnMocHJldlJlc3QsIG5leHRSZXN0KTtcbn1cblxuLy8gSXQga25vd3MgdG8gY29tcGFyZSBpbmRpdmlkdWFsIHN0eWxlIHByb3BzIGFuZCBpZ25vcmUgdGhlIHdyYXBwZXIgb2JqZWN0LlxuLy8gU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1jb21wb25lbnQuaHRtbCNzaG91bGRjb21wb25lbnR1cGRhdGVcblxuZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gIHJldHVybiAhYXJlRXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fCBzaGFsbG93RGlmZmVycyh0aGlzLnN0YXRlLCBuZXh0U3RhdGUpO1xufVxuXG5leHBvcnQgeyBGaXhlZFNpemVHcmlkLCBGaXhlZFNpemVMaXN0LCBWYXJpYWJsZVNpemVHcmlkLCBWYXJpYWJsZVNpemVMaXN0LCBhcmVFcXVhbCwgc2hvdWxkQ29tcG9uZW50VXBkYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiX2luaGVyaXRzTG9vc2UiLCJtZW1vaXplT25lIiwiY3JlYXRlRWxlbWVudCIsIlB1cmVDb21wb25lbnQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImhhc05hdGl2ZVBlcmZvcm1hbmNlTm93IiwicGVyZm9ybWFuY2UiLCJub3ciLCJEYXRlIiwiY2FuY2VsVGltZW91dCIsInRpbWVvdXRJRCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaWQiLCJyZXF1ZXN0VGltZW91dCIsImNhbGxiYWNrIiwiZGVsYXkiLCJzdGFydCIsInRpY2siLCJjYWxsIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2l6ZSIsImdldFNjcm9sbGJhclNpemUiLCJyZWNhbGN1bGF0ZSIsImRpdiIsImRvY3VtZW50Iiwic3R5bGUiLCJ3aWR0aCIsImhlaWdodCIsIm92ZXJmbG93IiwiYm9keSIsImFwcGVuZENoaWxkIiwib2Zmc2V0V2lkdGgiLCJjbGllbnRXaWR0aCIsInJlbW92ZUNoaWxkIiwiY2FjaGVkUlRMUmVzdWx0IiwiZ2V0UlRMT2Zmc2V0VHlwZSIsIm91dGVyRGl2Iiwib3V0ZXJTdHlsZSIsImRpcmVjdGlvbiIsImlubmVyRGl2IiwiaW5uZXJTdHlsZSIsInNjcm9sbExlZnQiLCJJU19TQ1JPTExJTkdfREVCT1VOQ0VfSU5URVJWQUwiLCJkZWZhdWx0SXRlbUtleSIsIl9yZWYiLCJjb2x1bW5JbmRleCIsImRhdGEiLCJyb3dJbmRleCIsImRldldhcm5pbmdzT3ZlcnNjYW5Db3VudCIsImRldldhcm5pbmdzT3ZlcnNjYW5Sb3dzQ29sdW1uc0NvdW50IiwiZGV2V2FybmluZ3NUYWdOYW1lIiwicHJvY2VzcyIsIndpbmRvdyIsIldlYWtTZXQiLCJjcmVhdGVHcmlkQ29tcG9uZW50IiwiX3JlZjIiLCJfY2xhc3MiLCJnZXRDb2x1bW5PZmZzZXQiLCJnZXRDb2x1bW5TdGFydEluZGV4Rm9yT2Zmc2V0IiwiZ2V0Q29sdW1uU3RvcEluZGV4Rm9yU3RhcnRJbmRleCIsImdldENvbHVtbldpZHRoIiwiZ2V0RXN0aW1hdGVkVG90YWxIZWlnaHQiLCJnZXRFc3RpbWF0ZWRUb3RhbFdpZHRoIiwiZ2V0T2Zmc2V0Rm9yQ29sdW1uQW5kQWxpZ25tZW50IiwiZ2V0T2Zmc2V0Rm9yUm93QW5kQWxpZ25tZW50IiwiZ2V0Um93SGVpZ2h0IiwiZ2V0Um93T2Zmc2V0IiwiZ2V0Um93U3RhcnRJbmRleEZvck9mZnNldCIsImdldFJvd1N0b3BJbmRleEZvclN0YXJ0SW5kZXgiLCJpbml0SW5zdGFuY2VQcm9wcyIsInNob3VsZFJlc2V0U3R5bGVDYWNoZU9uSXRlbVNpemVDaGFuZ2UiLCJ2YWxpZGF0ZVByb3BzIiwiX1B1cmVDb21wb25lbnQiLCJHcmlkIiwicHJvcHMiLCJfdGhpcyIsIl9pbnN0YW5jZVByb3BzIiwiX3Jlc2V0SXNTY3JvbGxpbmdUaW1lb3V0SWQiLCJfb3V0ZXJSZWYiLCJzdGF0ZSIsImluc3RhbmNlIiwiaXNTY3JvbGxpbmciLCJob3Jpem9udGFsU2Nyb2xsRGlyZWN0aW9uIiwiaW5pdGlhbFNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJpbml0aWFsU2Nyb2xsVG9wIiwic2Nyb2xsVXBkYXRlV2FzUmVxdWVzdGVkIiwidmVydGljYWxTY3JvbGxEaXJlY3Rpb24iLCJfY2FsbE9uSXRlbXNSZW5kZXJlZCIsIm92ZXJzY2FuQ29sdW1uU3RhcnRJbmRleCIsIm92ZXJzY2FuQ29sdW1uU3RvcEluZGV4Iiwib3ZlcnNjYW5Sb3dTdGFydEluZGV4Iiwib3ZlcnNjYW5Sb3dTdG9wSW5kZXgiLCJ2aXNpYmxlQ29sdW1uU3RhcnRJbmRleCIsInZpc2libGVDb2x1bW5TdG9wSW5kZXgiLCJ2aXNpYmxlUm93U3RhcnRJbmRleCIsInZpc2libGVSb3dTdG9wSW5kZXgiLCJvbkl0ZW1zUmVuZGVyZWQiLCJfY2FsbE9uU2Nyb2xsIiwib25TY3JvbGwiLCJfZ2V0SXRlbVN0eWxlIiwiX3RoaXMkcHJvcHMiLCJjb2x1bW5XaWR0aCIsInJvd0hlaWdodCIsIml0ZW1TdHlsZUNhY2hlIiwiX2dldEl0ZW1TdHlsZUNhY2hlIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJfb2Zmc2V0IiwiaXNSdGwiLCJwb3NpdGlvbiIsImxlZnQiLCJ1bmRlZmluZWQiLCJyaWdodCIsInRvcCIsIl8iLCJfXyIsIl9fXyIsIl9vblNjcm9sbCIsImV2ZW50IiwiX2V2ZW50JGN1cnJlbnRUYXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJzZXRTdGF0ZSIsInByZXZTdGF0ZSIsImNhbGN1bGF0ZWRTY3JvbGxMZWZ0IiwiTWF0aCIsIm1heCIsIm1pbiIsImNhbGN1bGF0ZWRTY3JvbGxUb3AiLCJfcmVzZXRJc1Njcm9sbGluZ0RlYm91bmNlZCIsIl9vdXRlclJlZlNldHRlciIsInJlZiIsIm91dGVyUmVmIiwiY3VycmVudCIsIl9yZXNldElzU2Nyb2xsaW5nIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibmV4dFByb3BzIiwidmFsaWRhdGVTaGFyZWRQcm9wcyIsIl9wcm90byIsInByb3RvdHlwZSIsInNjcm9sbFRvIiwiX3JlZjMiLCJzY3JvbGxUb0l0ZW0iLCJfcmVmNCIsIl9yZWY0JGFsaWduIiwiYWxpZ24iLCJfdGhpcyRwcm9wczIiLCJjb2x1bW5Db3VudCIsInJvd0NvdW50IiwiX3RoaXMkc3RhdGUiLCJzY3JvbGxiYXJTaXplIiwiZXN0aW1hdGVkVG90YWxIZWlnaHQiLCJlc3RpbWF0ZWRUb3RhbFdpZHRoIiwiaG9yaXpvbnRhbFNjcm9sbGJhclNpemUiLCJ2ZXJ0aWNhbFNjcm9sbGJhclNpemUiLCJjb21wb25lbnREaWRNb3VudCIsIl90aGlzJHByb3BzMyIsIl9jYWxsUHJvcHNDYWxsYmFja3MiLCJjb21wb25lbnREaWRVcGRhdGUiLCJfdGhpcyRzdGF0ZTIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbmRlciIsIl90aGlzJHByb3BzNCIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwiaW5uZXJSZWYiLCJpbm5lckVsZW1lbnRUeXBlIiwiaW5uZXJUYWdOYW1lIiwiaXRlbURhdGEiLCJfdGhpcyRwcm9wczQkaXRlbUtleSIsIml0ZW1LZXkiLCJvdXRlckVsZW1lbnRUeXBlIiwib3V0ZXJUYWdOYW1lIiwidXNlSXNTY3JvbGxpbmciLCJfdGhpcyRfZ2V0SG9yaXpvbnRhbFIiLCJfZ2V0SG9yaXpvbnRhbFJhbmdlVG9SZW5kZXIiLCJjb2x1bW5TdGFydEluZGV4IiwiY29sdW1uU3RvcEluZGV4IiwiX3RoaXMkX2dldFZlcnRpY2FsUmFuIiwiX2dldFZlcnRpY2FsUmFuZ2VUb1JlbmRlciIsInJvd1N0YXJ0SW5kZXgiLCJyb3dTdG9wSW5kZXgiLCJpdGVtcyIsIl9yb3dJbmRleCIsIl9jb2x1bW5JbmRleCIsInB1c2giLCJXZWJraXRPdmVyZmxvd1Njcm9sbGluZyIsIndpbGxDaGFuZ2UiLCJwb2ludGVyRXZlbnRzIiwiX3RoaXMkcHJvcHM1IiwiX3RoaXMkX2dldEhvcml6b250YWxSMiIsIl9vdmVyc2NhbkNvbHVtblN0YXJ0SW5kZXgiLCJfb3ZlcnNjYW5Db2x1bW5TdG9wSW5kZXgiLCJfdmlzaWJsZUNvbHVtblN0YXJ0SW5kZXgiLCJfdmlzaWJsZUNvbHVtblN0b3BJbmRleCIsIl90aGlzJF9nZXRWZXJ0aWNhbFJhbjIiLCJfb3ZlcnNjYW5Sb3dTdGFydEluZGV4IiwiX292ZXJzY2FuUm93U3RvcEluZGV4IiwiX3Zpc2libGVSb3dTdGFydEluZGV4IiwiX3Zpc2libGVSb3dTdG9wSW5kZXgiLCJfdGhpcyRzdGF0ZTMiLCJfaG9yaXpvbnRhbFNjcm9sbERpcmVjdGlvbiIsIl9zY3JvbGxMZWZ0IiwiX3Njcm9sbFRvcCIsIl9zY3JvbGxVcGRhdGVXYXNSZXF1ZXN0ZWQiLCJfdmVydGljYWxTY3JvbGxEaXJlY3Rpb24iLCJfdGhpcyRwcm9wczYiLCJvdmVyc2NhbkNvbHVtbkNvdW50Iiwib3ZlcnNjYW5Db2x1bW5zQ291bnQiLCJvdmVyc2NhbkNvdW50IiwiX3RoaXMkc3RhdGU0Iiwib3ZlcnNjYW5Db3VudFJlc29sdmVkIiwic3RhcnRJbmRleCIsInN0b3BJbmRleCIsIm92ZXJzY2FuQmFja3dhcmQiLCJvdmVyc2NhbkZvcndhcmQiLCJfdGhpcyRwcm9wczciLCJvdmVyc2NhblJvd0NvdW50Iiwib3ZlcnNjYW5Sb3dzQ291bnQiLCJfdGhpcyRzdGF0ZTUiLCJkZWZhdWx0UHJvcHMiLCJfcmVmNSIsIl9yZWY2IiwiaGFzIiwiYWRkIiwiY29uc29sZSIsIndhcm4iLCJFcnJvciIsIkRFRkFVTFRfRVNUSU1BVEVEX0lURU1fU0laRSIsInJvd01ldGFkYXRhTWFwIiwiZXN0aW1hdGVkUm93SGVpZ2h0IiwibGFzdE1lYXN1cmVkUm93SW5kZXgiLCJ0b3RhbFNpemVPZk1lYXN1cmVkUm93cyIsIml0ZW1NZXRhZGF0YSIsIm9mZnNldCIsIm51bVVubWVhc3VyZWRJdGVtcyIsInRvdGFsU2l6ZU9mVW5tZWFzdXJlZEl0ZW1zIiwiY29sdW1uTWV0YWRhdGFNYXAiLCJlc3RpbWF0ZWRDb2x1bW5XaWR0aCIsImxhc3RNZWFzdXJlZENvbHVtbkluZGV4IiwiZ2V0SXRlbU1ldGFkYXRhIiwiaXRlbVR5cGUiLCJpbmRleCIsImluc3RhbmNlUHJvcHMiLCJpdGVtTWV0YWRhdGFNYXAiLCJpdGVtU2l6ZSIsImxhc3RNZWFzdXJlZEluZGV4IiwiaSIsImZpbmROZWFyZXN0SXRlbSIsImxhc3RNZWFzdXJlZEl0ZW1PZmZzZXQiLCJmaW5kTmVhcmVzdEl0ZW1CaW5hcnlTZWFyY2giLCJmaW5kTmVhcmVzdEl0ZW1FeHBvbmVudGlhbFNlYXJjaCIsImhpZ2giLCJsb3ciLCJtaWRkbGUiLCJmbG9vciIsImN1cnJlbnRPZmZzZXQiLCJpdGVtQ291bnQiLCJpbnRlcnZhbCIsImdldE9mZnNldEZvckluZGV4QW5kQWxpZ25tZW50Iiwic2Nyb2xsT2Zmc2V0IiwiZXN0aW1hdGVkVG90YWxTaXplIiwibWF4T2Zmc2V0IiwibWluT2Zmc2V0Iiwicm91bmQiLCJWYXJpYWJsZVNpemVHcmlkIiwicmVzZXRBZnRlckNvbHVtbkluZGV4Iiwic2hvdWxkRm9yY2VVcGRhdGUiLCJyZXNldEFmdGVySW5kaWNlcyIsInJlc2V0QWZ0ZXJSb3dJbmRleCIsIl9yZWY2JHNob3VsZEZvcmNlVXBkYSIsImZvcmNlVXBkYXRlIiwiX3JlZjciLCJJU19TQ1JPTExJTkdfREVCT1VOQ0VfSU5URVJWQUwkMSIsImRlZmF1bHRJdGVtS2V5JDEiLCJkZXZXYXJuaW5nc0RpcmVjdGlvbiIsImRldldhcm5pbmdzVGFnTmFtZSQxIiwiY3JlYXRlTGlzdENvbXBvbmVudCIsImdldEl0ZW1PZmZzZXQiLCJnZXRFc3RpbWF0ZWRUb3RhbFNpemUiLCJnZXRJdGVtU2l6ZSIsImdldFN0YXJ0SW5kZXhGb3JPZmZzZXQiLCJnZXRTdG9wSW5kZXhGb3JTdGFydEluZGV4IiwiTGlzdCIsInNjcm9sbERpcmVjdGlvbiIsImluaXRpYWxTY3JvbGxPZmZzZXQiLCJvdmVyc2NhblN0YXJ0SW5kZXgiLCJvdmVyc2NhblN0b3BJbmRleCIsInZpc2libGVTdGFydEluZGV4IiwidmlzaWJsZVN0b3BJbmRleCIsImxheW91dCIsImlzSG9yaXpvbnRhbCIsIm9mZnNldEhvcml6b250YWwiLCJfb25TY3JvbGxIb3Jpem9udGFsIiwiX29uU2Nyb2xsVmVydGljYWwiLCJfZXZlbnQkY3VycmVudFRhcmdldDIiLCJ2YWxpZGF0ZVNoYXJlZFByb3BzJDEiLCJfdGhpcyRwcm9wczUkaXRlbUtleSIsIl90aGlzJF9nZXRSYW5nZVRvUmVuZCIsIl9nZXRSYW5nZVRvUmVuZGVyIiwiX2luZGV4IiwiX3RoaXMkX2dldFJhbmdlVG9SZW5kMiIsIl9vdmVyc2NhblN0YXJ0SW5kZXgiLCJfb3ZlcnNjYW5TdG9wSW5kZXgiLCJfdmlzaWJsZVN0YXJ0SW5kZXgiLCJfdmlzaWJsZVN0b3BJbmRleCIsIl9zY3JvbGxEaXJlY3Rpb24iLCJfc2Nyb2xsT2Zmc2V0IiwiREVGQVVMVF9FU1RJTUFURURfSVRFTV9TSVpFJDEiLCJnZXRJdGVtTWV0YWRhdGEkMSIsImZpbmROZWFyZXN0SXRlbSQxIiwiZmluZE5lYXJlc3RJdGVtQmluYXJ5U2VhcmNoJDEiLCJmaW5kTmVhcmVzdEl0ZW1FeHBvbmVudGlhbFNlYXJjaCQxIiwiZXN0aW1hdGVkSXRlbVNpemUiLCJ0b3RhbFNpemVPZk1lYXN1cmVkSXRlbXMiLCJWYXJpYWJsZVNpemVMaXN0IiwicmVzZXRBZnRlckluZGV4IiwiRml4ZWRTaXplR3JpZCIsImxhc3RDb2x1bW5PZmZzZXQiLCJtaWRkbGVPZmZzZXQiLCJjZWlsIiwiX3JlZjgiLCJsYXN0Um93T2Zmc2V0IiwiX3JlZjkiLCJfcmVmMTAiLCJudW1WaXNpYmxlQ29sdW1ucyIsIl9yZWYxMSIsIl9yZWYxMiIsIm51bVZpc2libGVSb3dzIiwiX3JlZjEzIiwiRml4ZWRTaXplTGlzdCIsImxhc3RJdGVtT2Zmc2V0IiwibnVtVmlzaWJsZUl0ZW1zIiwic2hhbGxvd0RpZmZlcnMiLCJwcmV2IiwibmV4dCIsImF0dHJpYnV0ZSIsIl9hdHRyaWJ1dGUiLCJfZXhjbHVkZWQiLCJfZXhjbHVkZWQyIiwiYXJlRXF1YWwiLCJwcmV2UHJvcHMiLCJwcmV2U3R5bGUiLCJwcmV2UmVzdCIsIm5leHRTdHlsZSIsIm5leHRSZXN0Iiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwibmV4dFN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-window/dist/index.esm.js\n");

/***/ })

};
;